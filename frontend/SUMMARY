---
File: frontend/index.html
---
<!DOCTYPE html>
<!-- frontend/index.html - Root of GitHub Pages site -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DigThatData Papers Feed</title>
  
  <!-- Tabulator CSS and JS -->
  <link href="https://unpkg.com/tabulator-tables@6.3.0/dist/css/tabulator.min.css" rel="stylesheet">
  <script src="https://unpkg.com/tabulator-tables@6.3.0/dist/js/tabulator.min.js"></script>

  <!-- D3.js for color scales -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  
  <!-- Date parsing and normalizaiton -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chrono-node/1.0.5/chrono.min.js"></script>
  
  <!-- Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
  <link rel="stylesheet" href="papersfeed.css">
</head>
<body>
  <div class="header">
    <div class="header-title">
        <h1>What I Am Reading</h1>
        <p class="header-desc">By <a href="https://bsky.app/profile/digthatdata.bsky.social">@DigThatData</a>. Learn more <a href="https://github.com/dmarx/papers-feed-template">here</a>.</p>
    </div>

    <div class="heatmap-container">
      <div class="heatmap-title">
        <select id="heatmap-metric-selector" class="heatmap-dropdown">
          <option value="papers">Papers per day</option>
          <option value="time">Reading time per day</option>
          <option value="sessions">Sessions per day</option>
          <option value="discoveries">Papers discovered per day</option>
        </select>

        <div class="heatmap-legend">
          <span>Less</span>
          <div class="legend-cell" style="background-color: #ebedf0;"></div>
          <div class="legend-cell" style="background-color: #c6e48b;"></div>
          <div class="legend-cell" style="background-color: #7bc96f;"></div>
          <div class="legend-cell" style="background-color: #239a3b;"></div>
          <div class="legend-cell" style="background-color: #196127;"></div>
          <span>More</span>
        </div>

      </div>
      <div id="reading-heatmap"></div>
    </div>

    <div class="controls">
      <div class="search-box">
        <input type="text" id="search-input" placeholder="Search papers by title, author, or content...">
        <button class="clear-search-btn" id="clear-search" title="Clear search">×</button>
      </div>
      <button class="filter-button" id="sidebar-toggle">
        <i class="fas fa-filter"></i> Filters
      </button>
    </div>
  </div>

  <!-- Filter Status Bar -->
  <div class="filter-status-bar" id="filter-status-bar" style="display: none;">
    <div class="filter-status-content">
      <span class="filter-status-label">Active filters:</span>
      <div class="filter-badges" id="filter-badges"></div>
      <button class="clear-all-filters-btn" id="clear-all-filters">Clear All</button>
    </div>
  </div>
  
  <div class="dashboard-container">
    <div class="main-content">
      <div id="papers-table">
        <div class="loading">Loading papers data...</div>
      </div>
    </div>
    
    <!-- Filter Sidebar -->
    <div class="sidebar" id="sidebar">
      <h3>Filters</h3>
      
      <div class="filter-section">
        <h4>Publication Date</h4>
        <div id="date-filter-controls">
          <div>
            <label for="date-filter-from">From:</label>
            <input type="date" id="date-filter-from">
          </div>
          <div style="margin-top: 10px;">
            <label for="date-filter-to">To:</label>
            <input type="date" id="date-filter-to">
          </div>
          <div style="margin-top: 15px;">
            <button id="apply-date-filter" class="filter-button">Apply</button>
            <button id="clear-date-filter" class="filter-button">Clear</button>
          </div>
        </div>
      </div>
      
      <div class="filter-section">
        <h4>Reading Time</h4>
        <div>
          <label for="min-reading-time">Minimum (minutes):</label>
          <input type="number" id="min-reading-time" min="0" step="1">
        </div>
        <div style="margin-top: 10px;">
          <button id="apply-reading-filter" class="filter-button">Apply</button>
          <button id="clear-reading-filter" class="filter-button">Clear</button>
        </div>
      </div>
      
      <div class="filter-section">
        <h4>Interaction Days</h4>
        <div>
          <label for="min-interaction-days">Minimum days:</label>
          <input type="number" id="min-interaction-days" min="0" step="1">
        </div>
        <div style="margin-top: 10px;">
          <button id="apply-days-filter" class="filter-button">Apply</button>
          <button id="clear-days-filter" class="filter-button">Clear</button>
        </div>
      </div>
      
      <div class="filter-section">
        <h4>Reset All Filters</h4>
        <button id="reset-all-filters" class="filter-button">Reset All</button>
      </div>
    </div>
    
    <div class="sidebar" id="details-sidebar">
      <button class="close-button" onclick="hideDetails()">×</button>
      <div class="details-scroll-content">
        <div id="details-content"></div>
      </div>
    </div>
  </div>
  
  <button id="filter-toggle-btn" title="Toggle Filters">
    <i class="fas fa-filter"></i>
  </button>

  <script src="papersfeed.js"></script>
</body>
</html>



---
File: frontend/papersfeed.css
---
/* frontend/papersfeed.css */
body {
  margin: 0;
  padding: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  background-color: #f5f7fa;
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 30px;
  padding: 20px;
  background-color: white;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.header-title {
  flex-shrink: 0;
}

h1 {
  margin: 0 0 10px 0;
  color: #333;
}

/* Heatmap container styles */
.heatmap-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-width: 0; /* Allow shrinking */
  padding: 0 20px;
  width: 100%; /* Ensure full width */
}

.heatmap-title {
  font-size: 12px;
  color: #666;
  margin-bottom: 8px;
  font-weight: 500;
  min-height: 16px; /* Reserve space to prevent layout shift */
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 20px; /* Space between dropdown and legend */
  /* Width will be set dynamically by JavaScript to match heatmap */
}

.heatmap-dropdown {
  font-size: 12px;
  color: #666;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 2px 6px;
  cursor: pointer;
  font-weight: 500;
  outline: none;
  flex-shrink: 0; /* Don't shrink the dropdown */
}

.heatmap-dropdown:hover {
  border-color: #1a73e8;
}

.heatmap-dropdown:focus {
  border-color: #1a73e8;
  box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
}

.heatmap-legend {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 11px;
  color: #666;
  flex-shrink: 0; /* Don't shrink the legend */
}

.heatmap-legend {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 11px;
  color: #666;
  flex-shrink: 0; /* Don't shrink the legend */
}

.legend-cell {
  width: 10px;
  height: 10px;
  border: 1px solid #d1d5db;
  border-radius: 2px;
}

/* Heatmap SVG styles */
.heatmap-cell {
  stroke: #fff;
  stroke-width: 1px;
  cursor: pointer;
  rx: 2px;
  ry: 2px;
}

.heatmap-cell:hover {
  stroke: #333;
  stroke-width: 2px;
}

.month-label {
  font-size: 10px;
  fill: #666;
  font-weight: 500;
}

.day-label {
  font-size: 9px;
  fill: #666;
}

/* Heatmap tooltip */
.heatmap-tooltip {
  position: absolute;
  background: rgba(0, 0, 0, 0.9);
  color: white;
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 12px;
  pointer-events: none;
  z-index: 1000;
  white-space: nowrap;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.controls {
  flex: 1;
  max-width: 500px;
  position: relative;
}

.search-box {
  flex-grow: 1;
  position: relative;
}

#search-input {
  width: 100%;
  padding: 12px 40px 12px 16px;
  border: 2px solid #e1e5e9;
  border-radius: 8px;
  font-size: 16px;
  transition: border-color 0.2s;
  box-sizing: border-box;
}

#search-input:focus {
  outline: none;
  border-color: #1a73e8;
}

.clear-search-btn {
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  font-size: 18px;
  color: #666;
  cursor: pointer;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.clear-search-btn:hover {
  background-color: #f0f0f0;
  color: #333;
}

.filter-button {
  padding: 8px 15px;
  background-color: #f0f0f0;
  border: 1px solid #ddd;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 5px;
}

.filter-button:hover {
  background-color: #e8e8e8;
}

/* Filter Status Bar */
.filter-status-bar {
  background-color: #e3f2fd;
  border-bottom: 1px solid #bbdefb;
  padding: 10px 20px;
  transition: all 0.3s ease;
}

.filter-status-content {
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
}

.filter-status-label {
  font-weight: 600;
  color: #1565c0;
  font-size: 14px;
}

.filter-badges {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  flex: 1;
}

.filter-badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  background-color: #1976d2;
  color: white;
  padding: 4px 8px;
  border-radius: 16px;
  font-size: 12px;
  font-weight: 500;
}

.filter-badge-remove {
  background: none;
  border: none;
  color: white;
  cursor: pointer;
  font-size: 14px;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-left: 2px;
}

.filter-badge-remove:hover {
  background-color: rgba(255, 255, 255, 0.2);
}

.clear-all-filters-btn {
  background-color: #f44336;
  color: white;
  border: none;
  padding: 6px 12px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  font-weight: 500;
}

.clear-all-filters-btn:hover {
  background-color: #d32f2f;
}

.dashboard-container {
  display: flex;
  flex: 1;
  overflow: hidden;
  position: relative;
}

.main-content {
  flex: 1;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

#papers-table {
  flex: 1;
  width: 100%;
}

/* Shared sidebar styles */
.sidebar {
  background-color: white;
  box-shadow: -2px 0 5px rgba(0,0,0,0.1);
  overflow: hidden;
  transition: all 0.3s ease;
  position: absolute;
  right: 0;
  top: 0;
  bottom: 0;
  width: 0;
  z-index: 100;
}

.sidebar.active {
  width: 400px;
  padding: 20px;
}

/* Filter sidebar specific */
#sidebar h3 {
  margin-top: 0;
  margin-bottom: 15px;
}

.filter-section {
  margin-bottom: 20px;
}

.filter-section h4 {
  margin-top: 0;
  margin-bottom: 10px;
  border-bottom: 1px solid #eee;
  padding-bottom: 5px;
}

/* Details sidebar specific */
#details-sidebar {
  z-index: 101; /* Higher than filter sidebar */
}

.details-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 20px;
}

.close-button {
  position: absolute;
  top: 15px;
  right: 15px;
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
  color: #666;
  padding: 8px;
  z-index: 10;
}

.close-button:hover {
  color: #333;
}

.details-scroll-content {
  height: 100%;
  overflow-y: auto;
  padding: 20px 20px 20px 20px; /* Top padding leaves space for close button */
}

.details-header h2 {
  margin: 0;
  line-height: 1.3;
}

.detail-section {
  margin-bottom: 25px;
  background-color: #f9f9f9;
  border-radius: 6px;
  padding: 15px;
}

.detail-section h3 {
  margin-top: 0;
  margin-bottom: 15px;
  color: #333;
  font-size: 1.1em;
  border-bottom: 1px solid #eee;
  padding-bottom: 8px;
}

.detail-table {
  width: 100%;
  border-collapse: collapse;
}

.detail-table th {
  text-align: left;
  padding: 8px;
  color: #666;
  font-weight: 600;
  width: 30%;
  vertical-align: top;
}

.detail-table td {
  padding: 8px;
  vertical-align: top;
}

.abstract-box {
  max-height: 300px;
  overflow-y: auto;
  padding: 15px;
  background-color: white;
  border-radius: 4px;
  line-height: 1.5;
  white-space: pre-line;
}

.tag {
  display: inline-block;
  background-color: #e8f0fe;
  padding: 3px 8px;
  margin: 2px;
  border-radius: 12px;
  font-size: 12px;
}

.loading {
  text-align: center;
  padding: 40px;
  font-size: 18px;
  color: #666;
}

.sessions-table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 10px;
}

.sessions-table th {
  background-color: #f2f2f2;
  padding: 8px;
  text-align: left;
}

.sessions-table td {
  padding: 8px;
  border-bottom: 1px solid #eee;
}

/* Toggle button for the sidebar */
#filter-toggle-btn {
  position: fixed;
  right: 20px;
  bottom: 20px;
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background-color: #1a73e8;
  color: white;
  border: none;
  box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  transition: background-color 0.3s;
  z-index: 102; /* Above both sidebars */
}

#filter-toggle-btn:hover {
  background-color: #1558b7;
}

/* Tabulator customizations */
.tabulator {
  border: none;
  background-color: transparent;
}

.tabulator-row {
  border-bottom: 1px solid #f0f0f0;
  cursor: pointer;
}

.tabulator-row:hover {
  background-color: #f2f8fd !important;
}

.tabulator-row.tabulator-row-even {
  background-color: #fafafa;
}

/* Responsive adjustments */
@media (max-width: 1200px) {
  .heatmap-container {
    display: none; /* Hide heatmap on smaller screens */
  }
}

@media (max-width: 768px) {
  .header {
    flex-direction: column;
    align-items: stretch;
    gap: 15px;
  }
  
  .controls {
    max-width: none;
  }
  
  .sidebar.active {
    width: 85%;
  }
  
  .detail-grid {
    grid-template-columns: 1fr;
  }

  .filter-status-content {
    flex-direction: column;
    align-items: stretch;
    gap: 8px;
  }

  .filter-badges {
    justify-content: flex-start;
  }
}



---
File: frontend/papersfeed.js
---
// frontend/papersfeed.js
// Global variables
let table;
let allData = [];
let currentDetailsPaper = null;
let readingTimeColorScale = null;
let interactionDaysColorScale = null;
let readingActivityData = [];
let currentHeatmapMetric = 'papers';

// Utility function to normalize dates using Chrono
function normalizeDate(dateString) {
  if (!dateString) return null;
  
  try {
    // Try to parse with Chrono
    const parsedDate = chrono.parseDate(dateString);
    
    if (parsedDate) {
      // Return in YYYY-MM-DD format for consistency
      return parsedDate.toISOString().split('T')[0];
    }
    
    // Fallback to native Date parsing if Chrono fails
    const fallbackDate = new Date(dateString);
    if (!isNaN(fallbackDate.getTime())) {
      return fallbackDate.toISOString().split('T')[0];
    }
    
    // If all parsing fails, return original string
    console.warn(`Could not parse date: ${dateString}`);
    return dateString;
    
  } catch (error) {
    console.warn(`Date parsing error for "${dateString}":`, error);
    return dateString;
  }
}

/**
 * Calculate the number of days between two dates
 * @param {string} startDate - Date in 'YYYY-MM-DD' format
 * @param {string} endDate - Date in 'YYYY-MM-DD' format
 * @returns {number} Number of days between the dates (positive if endDate is after startDate)
 */
function daysBetween(startDate, endDate) {
  const start = new Date(startDate);
  const end = new Date(endDate);
  
  // Calculate the difference in milliseconds
  const diffTime = end - start;
  
  // Convert to days (1 day = 24 * 60 * 60 * 1000 milliseconds)
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  
  return diffDays;
}

// Filter Manager for unified filter state
class FilterManager {
  constructor(table) {
    this.table = table;
    this.filters = new Map(); // name -> {fn, description}
    this.listeners = new Set();
  }
  
  setFilter(name, filterFunction, description) {
    this.filters.set(name, { fn: filterFunction, desc: description });
    this.applyFilters();
    this.notifyListeners();
  }
  
  removeFilter(name) {
    this.filters.delete(name);
    this.applyFilters();
    this.notifyListeners();
  }
  
  clearAll() {
    this.filters.clear();
    this.applyFilters();
    this.notifyListeners();
  }
  
  applyFilters() {
    if (this.filters.size === 0) {
      this.table.clearFilter();
    } else {
      this.table.setFilter((data) => {
        return Array.from(this.filters.values())
          .every(filter => filter.fn(data));
      });
    }
    
    // Update heatmap with filtered data
    this.updateHeatmap();
  }
  
  updateHeatmap() {
    // If viewing paper details, show only that paper's activity
    if (currentDetailsPaper) {
      const singlePaperActivity = extractReadingActivityData([currentDetailsPaper], currentHeatmapMetric);
      createReadingHeatmap(singlePaperActivity);
      return;
    }
    
    // Otherwise, get currently filtered data from the table
    const filteredData = this.table.getData("active");
    console.log("Updating heatmap with", filteredData.length, "filtered papers");
    
    // Extract reading activity from filtered data
    const filteredActivityData = extractReadingActivityData(filteredData, currentHeatmapMetric);
    
    // Recreate the heatmap with filtered data
    createReadingHeatmap(filteredActivityData);
  }
  
  getActiveFilters() {
    return Array.from(this.filters.entries())
      .map(([name, {desc}]) => ({name, description: desc}));
  }
  
  addListener(callback) {
    this.listeners.add(callback);
  }
  
  removeListener(callback) {
    this.listeners.delete(callback);
  }
  
  notifyListeners() {
    this.listeners.forEach(callback => callback());
  }
}

// Filter Status Bar UI Component
class FilterStatusBar {
  constructor(filterManager) {
    this.filterManager = filterManager;
    this.container = document.getElementById('filter-status-bar');
    this.badgeContainer = document.getElementById('filter-badges');
    this.clearAllBtn = document.getElementById('clear-all-filters');
    
    // Listen for filter changes
    this.filterManager.addListener(() => this.render());
    
    // Set up clear all button
    this.clearAllBtn.addEventListener('click', () => {
      this.filterManager.clearAll();
    });
  }
  
  render() {
    const activeFilters = this.filterManager.getActiveFilters();
    
    if (activeFilters.length === 0) {
      this.container.style.display = 'none';
      return;
    }
    
    this.container.style.display = 'block';
    this.badgeContainer.innerHTML = '';
    
    activeFilters.forEach(({name, description}) => {
      const badge = this.createFilterBadge(name, description);
      this.badgeContainer.appendChild(badge);
    });
  }
  
  createFilterBadge(name, description) {
    const badge = document.createElement('div');
    badge.className = 'filter-badge';
    
    // Add preview styling for search preview
    if (name === 'search-preview') {
      badge.classList.add('preview');
    }
    
    const text = document.createElement('span');
    text.textContent = description;
    
    const removeBtn = document.createElement('button');
    removeBtn.className = 'filter-badge-remove';
    removeBtn.innerHTML = '×';
    removeBtn.title = `Remove ${description} filter`;
    removeBtn.addEventListener('click', () => {
      this.filterManager.removeFilter(name);
      
      // If removing search preview, also clear the input
      if (name === 'search-preview') {
        document.getElementById("search-input").value = "";
        currentPreviewSearchTerm = null;
      }
    });
    
    badge.appendChild(text);
    badge.appendChild(removeBtn);
    
    return badge;
  }
}

// Global filter manager instance
let filterManager;
let filterStatusBar;

// Extract reading activity data from interaction data
function extractReadingActivityData(data, metric = 'papers') {
  const dailyActivity = new Map();
  
  data.forEach(paper => {
    if (paper.rawInteractionData && paper.rawInteractionData.length > 0) {
      paper.rawInteractionData.forEach(interaction => {
        if (interaction.type === "reading_session" && interaction.timestamp) {
          const date = new Date(interaction.timestamp);
          const dateStr = d3.timeFormat("%Y-%m-%d")(date);
          
          if (!dailyActivity.has(dateStr)) {
            dailyActivity.set(dateStr, {
              papers: new Set(),
              totalTime: 0,
              sessions: 0,
              discoveries: new Set()
            });
          }
          
          const dayData = dailyActivity.get(dateStr);
          dayData.papers.add(paper.paperKey);
          dayData.totalTime += interaction.data.duration_seconds || 0;
          dayData.sessions += 1;
        }
      });
    }
    
    // Track paper discoveries (first read date)
    if (paper.firstRead) {
      const firstReadStr = paper.firstRead;
      if (!dailyActivity.has(firstReadStr)) {
        dailyActivity.set(firstReadStr, {
          papers: new Set(),
          totalTime: 0,
          sessions: 0,
          discoveries: new Set()
        });
      }
      dailyActivity.get(firstReadStr).discoveries.add(paper.paperKey);
    }
  });
  
  // Convert to array format based on selected metric
  const result = Array.from(dailyActivity.entries()).map(([dateStr, dayData]) => {
    let count;
    switch (metric) {
      case 'papers':
        count = dayData.papers.size;
        break;
      case 'time':
        count = Math.round(dayData.totalTime / 60); // Convert to minutes
        break;
      case 'sessions':
        count = dayData.sessions;
        break;
      case 'discoveries':
        count = dayData.discoveries.size;
        break;
      default:
        count = dayData.papers.size;
    }
    
    return {
      date: new Date(dateStr),
      count: count
    };
  });
  
  return result.filter(d => d.count > 0).sort((a, b) => a.date - b.date);
}

// Create reading activity heatmap
function createReadingHeatmap(data) {
  const container = d3.select("#reading-heatmap");
  container.selectAll("*").remove(); // Clear existing content
  
  if (!data || data.length === 0) {
    container.append("div")
      .style("text-align", "center")
      .style("color", "#666")
      .style("font-size", "12px")
      .style("padding", "20px")
      .text(currentDetailsPaper ? "No reading sessions for this paper" : "No reading activity data available");
    return;
  }
  
  // Calculate date range - 8 months back, ending today
  const endDateTime = new Date();
  endDateTime.setHours(23, 59, 59, 999); // End of today
  
  const startDateTime = new Date(endDateTime);
  startDateTime.setMonth(startDateTime.getMonth() - 8);
  startDateTime.setHours(0, 0, 0, 0); // Start of day 8 months ago
  
  // Calculate the Sunday of the week containing endDateTime (for right alignment)
  const endSunday = new Date(endDateTime);
  endSunday.setDate(endDateTime.getDate() - endDateTime.getDay());
  endSunday.setHours(0, 0, 0, 0);
  
  // Calculate how many weeks we need to show
  const totalWeeks = Math.ceil(d3.timeWeek.count(startDateTime, endSunday)) + 1;
  
  // Dimensions
  const cellSize = 11;
  const cellGap = 2;
  const width = totalWeeks * (cellSize + cellGap);
  const height = 7 * (cellSize + cellGap) + 20; // 7 days + month labels
  
  // Create SVG
  const svg = container
    .append("svg")
    .attr("width", width)
    .attr("height", height);
  
  // Set the header width to match the heatmap width
  const headerElement = document.querySelector('.heatmap-title');
  if (headerElement) {
    headerElement.style.width = width + 'px';
  }
  
  // Create tooltip
  let tooltip = d3.select("body").select(".heatmap-tooltip");
  if (tooltip.empty()) {
    tooltip = d3.select("body")
      .append("div")
      .attr("class", "heatmap-tooltip")
      .style("opacity", 0);
  }
  
  // Process data into a map for quick lookup
  const dataMap = new Map();
  data.forEach(d => {
    const dateStr = d3.timeFormat("%Y-%m-%d")(d.date);
    dataMap.set(dateStr, d.count);
  });
  
  // Create color scale - let D3 handle everything
  const maxCount = d3.max(data, d => d.count) || 1;

  const paletteHeatmap = d3.interpolateGreens; //d3.interpolateYlGn; //d3.interpolateBlues;
  const colorScale = maxCount > 10 
    ? d3.scaleSequentialLog(paletteHeatmap).domain([1, maxCount])
    : d3.scaleSequential(paletteHeatmap).domain([0, maxCount]);
  
  // Generate all dates in our range
  const allDates = d3.timeDays(startDateTime, new Date(endDateTime.getTime() + 24 * 60 * 60 * 1000));
  
  // Create cells
  const cells = svg.selectAll(".heatmap-cell")
    .data(allDates)
    .enter()
    .append("rect")
    .attr("class", "heatmap-cell")
    .attr("width", cellSize)
    .attr("height", cellSize)
    .attr("x", d => {
      // Calculate week position relative to the end date (right-aligned)
      const weeksSinceStart = d3.timeWeek.count(startDateTime, d);
      return weeksSinceStart * (cellSize + cellGap);
    })
    .attr("y", d => {
      const dayOfWeek = d.getDay();
      return dayOfWeek * (cellSize + cellGap) + 20; // Offset for month labels
    })
    .attr("fill", d => {
      const dateStr = d3.timeFormat("%Y-%m-%d")(d);
      const count = dataMap.get(dateStr) || 0;
      return colorScale(count);
    })
    .on("mouseover", function(event, d) {
      const dateStr = d3.timeFormat("%Y-%m-%d")(d);
      const count = dataMap.get(dateStr) || 0;
      const formatDate = d3.timeFormat("%B %d, %Y");
      
      tooltip.transition()
        .duration(200)
        .style("opacity", .9);
      
      // Adjust tooltip text based on context and metric
      let paperText;
      if (currentDetailsPaper) {
        paperText = count > 0 ? "Read this paper" : "No activity";
      } else {
        switch (currentHeatmapMetric) {
          case 'papers':
            paperText = `${count} paper${count !== 1 ? 's' : ''} read`;
            break;
          case 'time':
            paperText = `${count} minute${count !== 1 ? 's' : ''} reading`;
            break;
          case 'sessions':
            paperText = `${count} session${count !== 1 ? 's' : ''}`;
            break;
          case 'discoveries':
            paperText = `${count} paper${count !== 1 ? 's' : ''} discovered`;
            break;
          default:
            paperText = `${count} paper${count !== 1 ? 's' : ''} read`;
        }
      }
      
      tooltip.html(`
        <div><strong>${formatDate(d)}</strong></div>
        <div>${paperText}</div>
      `)
        .style("left", (event.pageX + 10) + "px")
        .style("top", (event.pageY - 28) + "px");
    })
    .on("mouseout", function(d) {
      tooltip.transition()
        .duration(500)
        .style("opacity", 0);
    })
    .on("click", function(event, d) {
      // Only allow filtering when not viewing paper details
      if (currentDetailsPaper) {
        return; // Disable click filtering when viewing single paper
      }
      
      // Filter table to show papers read on this date
      const dateStr = d3.timeFormat("%Y-%m-%d")(d);
      const count = dataMap.get(dateStr) || 0;
      
      if (count > 0) {
        const formatDate = d3.timeFormat("%B %d, %Y");
        const dateFilter = function(data) {
          if (!data.rawInteractionData || data.rawInteractionData.length === 0) return false;
          
          return data.rawInteractionData.some(interaction => {
            if (interaction.type === "reading_session" && interaction.timestamp) {
              const interactionDateStr = d3.timeFormat("%Y-%m-%d")(new Date(interaction.timestamp));
              return interactionDateStr === dateStr;
            }
            return false;
          });
        };
        
        // Remove any existing heatmap-date filter and add new one
        filterManager.removeFilter('heatmap-date');
        filterManager.setFilter('heatmap-date', dateFilter, `Read on ${formatDate(d)}`);
      }
    });
  
  // Add month labels - only show months that have visible weeks
  const monthsInRange = d3.timeMonths(startDateTime, endDateTime);
  svg.selectAll(".month-label")
    .data(monthsInRange)
    .enter()
    .append("text")
    .attr("class", "month-label")
    .attr("x", d => {
      const weeksSinceStart = d3.timeWeek.count(startDateTime, d);
      return weeksSinceStart * (cellSize + cellGap);
    })
    .attr("y", 12)
    .text(d => d3.timeFormat("%b")(d));
  
  // Add day labels (M, W, F)
  const dayLabels = ["M", "", "W", "", "F", "", ""];
  svg.selectAll(".day-label")
    .data(dayLabels)
    .enter()
    .append("text")
    .attr("class", "day-label")
    .attr("x", -8)
    .attr("y", (d, i) => i * (cellSize + cellGap) + 20 + cellSize/2 + 3)
    .attr("text-anchor", "end")
    .text(d => d);
}

// Format date to YYYY-MM-DD format
function formatDate(dateString) {
  if (!dateString) return '';
  const date = new Date(dateString);
  return date.toISOString().split('T')[0]; // YYYY-MM-DD format
}

// Custom cell formatter for tags
function formatTags(cell) {
  const tags = cell.getValue();
  if (!tags || !Array.isArray(tags) || tags.length === 0) {
    return '';
  }
  return tags.map(tag => 
    `<span class="tag">${tag}</span>`
  ).join(' ');
}

function formatReadingTimeWithColor(cell) {
  const seconds = cell.getValue();
  const backgroundColor = readingTimeColorScale(seconds);
  const textColor = getContrastColor(backgroundColor);
  const element = cell.getElement();
  element.style.backgroundColor = backgroundColor;
  element.style.color = textColor;
  return seconds;
}

function formatInteractionDaysWithColor(cell) {
  const seconds = cell.getValue();
  const backgroundColor = interactionDaysColorScale(seconds);
  const textColor = getContrastColor(backgroundColor);
  const element = cell.getElement();
  element.style.backgroundColor = backgroundColor;
  element.style.color = textColor;
  return seconds;
}

// Get contrasting text color for readability
function getContrastColor(rgbColor) {
  // D3 returns rgb() format, parse it
  const rgb = rgbColor.match(/\d+/g);
  if (!rgb) return '#000000';
  
  const r = parseInt(rgb[0]);
  const g = parseInt(rgb[1]); 
  const b = parseInt(rgb[2]);
  
  // Calculate relative luminance
  const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
  
  // Return black for light backgrounds, white for dark backgrounds
  return luminance > 0.5 ? '#000000' : '#ffffff';
}

function formatInteractions(interactions) {
  if (!interactions || interactions.length === 0) {
    return '<p>No reading sessions recorded</p>';
  }
  
  return `
    <table class="sessions-table">
      <thead>
        <tr>
          <th>Date</th>
          <th>Duration</th>
          <th>Session ID</th>
        </tr>
      </thead>
      <tbody>
        ${interactions.map(interaction => {
          const date = new Date(interaction.timestamp);
          return `
            <tr>
              <td>${date.toLocaleString()}</td>
              <td>${interaction.data.duration_seconds} seconds</td>
              <td>${interaction.data.session_id}</td>
            </tr>
          `;
        }).join('')}
      </tbody>
    </table>
  `;
}

function displayPaperDetails(paperId) {
  console.log("Displaying details for paper ID:", paperId);
  
  const paper = allData.find(p => p.paperKey === paperId);
  if (!paper) {
    console.error('Paper not found:', paperId);
    return;
  }
  
  currentDetailsPaper = paper;
  
  // Update heatmap to show only this paper's activity
  const singlePaperActivity = extractReadingActivityData([paper], currentHeatmapMetric);
  createReadingHeatmap(singlePaperActivity);
  
  const detailsSidebar = document.getElementById('details-sidebar');
  const detailsContent = document.getElementById('details-content');
  
  // Content no longer includes close button - it's now fixed in HTML
  detailsContent.innerHTML = `
    <div class="details-header">
      <h2>${paper.title}</h2>
    </div>
    
    <div class="detail-section">
      <h3>Paper Details</h3>
      <table class="detail-table">
        <tr>
          <th>ID:</th>
          <td>${paper.id}</td>
        </tr>
        <tr>
          <th>Authors:</th>
          <td>${paper.authors}</td>
        </tr>
        <tr>
          <th>Publication Date:</th>
          <td>${paper.published}</td>
        </tr>
        <tr>
          <th>Last Read:</th>
          <td>${paper.lastRead}</td>
        </tr>
        <tr>
          <th>Reading Time:</th>
          <td>${paper.readingTime}</td>
        </tr>
        <tr>
          <th>Interaction Days:</th>
          <td>${paper.interactionDays === 1 ? '1 day' : paper.interactionDays + ' days'}</td>
        </tr>
        <tr>
          <th>arXiv Tags:</th>
          <td>${formatTags({ getValue: () => paper.tags })}</td>
        </tr>
        <tr>
          <th>URL:</th>
          <td><a href="${paper.url}" target="_blank">${paper.url}</a></td>
        </tr>
      </table>
    </div>
    
    <div class="detail-section">
      <h3>Abstract</h3>
      <div class="abstract-box">
        ${paper.abstract}
      </div>
    </div>
    
    <div class="detail-section">
      <h3>Reading Sessions</h3>
      ${formatInteractions(paper.rawInteractionData)}
    </div>
  `;
  
  // Show the sidebar
  detailsSidebar.classList.add('active');
}

function hideDetails() {
  const detailsSidebar = document.getElementById('details-sidebar');
  detailsSidebar.classList.remove('active');
  currentDetailsPaper = null;
  
  // Restore heatmap to show filtered data or all data
  if (filterManager && filterManager.filters.size > 0) {
    // If filters are active, show filtered data
    filterManager.updateHeatmap();
  } else {
    // If no filters, show all data
    const activityData = extractReadingActivityData(allData, currentHeatmapMetric);
    createReadingHeatmap(activityData);
  }
}

function removePrefix(string, prefix, sep = ':') {
  if (string.startsWith(prefix + sep)) {
    return string.slice(prefix.length + sep.length);
  }
  return null;
}

function extractObjectId(string, prefix) {
  // Case 1: Format is "prefix:id"
  let result = removePrefix(string, prefix, ':');
  if (result !== null) return result;
  
  // Case 2: Format is "prefix.id"
  result = removePrefix(string, prefix, '.');
  if (result !== null) return result;
  
  // Case 3: Format is "prefix:prefix:id"
  result = removePrefix(string, prefix + ':' + prefix, ':');
  if (result !== null) return result;
  
  // Case 3 alternate: Format is "prefix.prefix.id"
  result = removePrefix(string, prefix + '.' + prefix, '.');
  if (result !== null) return result;
  
  // Case 4: If none of the above, return the original string
  return string;
}

function extractDomain(url) {
  try {
    const urlObj = new URL(url);
    let domain = urlObj.hostname;
    
    // Remove www. prefix
    if (domain.startsWith('www.')) {
      domain = domain.substring(4);
    }
    
    // Remove .com or .org suffix
    if (domain.endsWith('.com')) {
      domain = domain.substring(0, domain.length - 4);
    } else if (domain.endsWith('.org')) {
      domain = domain.substring(0, domain.length - 4);
    }
    
    return domain;
  } catch (error) {
    // Handle invalid URLs
    console.error("Invalid URL:", error);
    return null;
  }
}

// Simple color formatter for published dates
const publishedColorScale = d3.scaleSequential(d3.interpolateGreens)
  .domain([90, 0]); // 90 days ago = white, 0 days ago = green

function formatPublishedWithColor(cell) {
  const publishedDate = cell.getValue();
  const cellElement = cell.getElement();
  
  if (!publishedDate || publishedDate === 'N/A') {
    cellElement.style.backgroundColor = 'white';
    return publishedDate || '';
  }
  
  try {
    const pubDate = new Date(publishedDate);
    const today = new Date();
    const daysAgo = Math.floor((today - pubDate) / (1000 * 60 * 60 * 24));
    
    if (daysAgo < 0 || daysAgo > 90) {
      // More than 3 months old or future date - white
      cellElement.style.backgroundColor = 'white';
    } else {
      // 0-90 days: use D3 color scale
      const backgroundColor = publishedColorScale(daysAgo);
      const textColor = getContrastColor(backgroundColor);
      cellElement.style.backgroundColor = backgroundColor;
      cellElement.style.color = textColor;
    }
    
    return publishedDate;
  } catch (error) {
    cellElement.style.backgroundColor = 'white';
    return publishedDate;
  }
}

// read and reshape gh-store scnapshot
function processComplexData(data) {
  const result = [];
  const objects = data.objects;
  const paperKeys = Object.keys(objects).filter(key => key.startsWith("paper:"));
  
  for (const paperKey of paperKeys) {
    const paperId = extractObjectId(paperKey, "paper");
    const paperRaw = objects[paperKey];
    const paperData = paperRaw.data;
    const paperMeta = paperRaw.meta;
    const interactionKey = `interactions:${paperId}`;
    const interactionData = objects[interactionKey] ? objects[interactionKey].data : null;
    
    // Calculate reading time
    let totalReadingTime = 0;
    let lastReadDate = null;
    
    // Calculate unique days with interactions
    let uniqueInteractionDays = 0;
    
    if (interactionData && interactionData.interactions) {
      const uniqueDays = new Set();
      
      for (const interaction of interactionData.interactions) {
        if (interaction.type === "reading_session") {
          totalReadingTime += interaction.data.duration_seconds || 0;
          
          // Find the most recent reading session
          const sessionDate = new Date(interaction.timestamp);
          if (!lastReadDate || sessionDate > lastReadDate) {
            lastReadDate = sessionDate;
          }
          
          // Track unique days
          if (interaction.timestamp) {
            const date = new Date(interaction.timestamp);
            const dateString = date.toISOString().split('T')[0]; // YYYY-MM-DD
            uniqueDays.add(dateString);
          }
        }
      }
      
      uniqueInteractionDays = uniqueDays.size;
    }

    const source = paperData.sourceId === 'arxiv' || paperData.sourceType === 'arxiv' ? 
               'arxiv' : (paperData.url ? extractDomain(paperData.url) : null) ||
                 paperData.sourceId || paperData.sourceType;
    
    // Ensure all fields are properly typed
    const authors = Array.isArray(paperData.authors) ? paperData.authors.join(', ') : (paperData.authors || '');
    const title = paperData.title || '';
    const abstract = paperData.abstract || '';
    const tags = paperData.tags || paperData.arxiv_tags || [];
    
    let freshness = -1;
    if (lastReadDate && paperData.publishedDate) {
      const lastReadStr = lastReadDate.toISOString().split('T')[0];  // Convert to YYYY-MM-DD
      const publishedStr = normalizeDate(paperData.publishedDate);  // Normalize first
      freshness = daysBetween(publishedStr, lastReadStr);
    }
    
    // Create the row data
    result.push({
      paperKey: paperKey,
      id: paperId,
      source: source,
      title: title,
      authors: authors,
      abstract: abstract,
      paperFreshness: freshness,
      published: normalizeDate(paperData.publishedDate),
      firstRead: formatDate(paperMeta.created_at),
      lastRead: lastReadDate ? formatDate(lastReadDate) : formatDate(paperMeta.updated_at),
      lastReadTimestamp: lastReadDate ? lastReadDate : paperMeta.updated_at,
      readingTimeSeconds: totalReadingTime,
      interactionDays: uniqueInteractionDays,
      tags: tags,
      url: paperData.url,
      rawInteractionData: interactionData ? interactionData.interactions : []
    });
  }
  
  return result;
}

// Initialize the Tabulator table
function initTable(data) {

  const interactionDays = data.map(d => d.interactionDays).filter(t => t > 0);
  if (interactionDays.length > 0) {
    const max_id = d3.max(interactionDays);
    interactionDaysColorScale = d3.scaleSequential(d3.interpolateBlues)
      .domain([1, max_id]);
  }

  const readingTimes = data.map(d => d.readingTimeSeconds).filter(t => t > 0);
  if (readingTimes.length > 0) {
    const p75 = d3.quantile(readingTimes.sort(d3.ascending), 0.75);
    readingTimeColorScale = d3.scaleSequential(d3.interpolateBlues)
      .domain([1, p75]);
  }
  
  console.log("Reading time color scale domain:", readingTimeColorScale ? readingTimeColorScale.domain() : "No scale");
  
  table = new Tabulator("#papers-table", {
    data: data,
    layout: "fitColumns",
    responsiveLayout: "collapse",
    pagination: "local",
    paginationSize: 1000,
    paginationSizeSelector: [10, 25, 50, 100, 500, 1000, 2000, 5000],
    movableColumns: true,
    groupBy: "lastRead",
    initialSort: [
      {column: "lastReadTimestamp", dir: "desc"},
      {column: "lastRead", dir: "desc"}
    ],
    columns: [
      {
        title: "Read Dates", 
        field: "interactionDays", 
        widthGrow: 1,
        formatter: formatInteractionDaysWithColor
      },
      {
        title: "Read Time (s)", 
        field: "readingTimeSeconds",  
        widthGrow: 1,
        formatter: formatReadingTimeWithColor
      },
      {
        title: "Title", 
        field: "title", 
        widthGrow: 6,
        formatter: function(cell) {
          const value = cell.getValue();
          return value;
        }
      },
      {
        title: "Source", 
        field: "source", 
        widthGrow: 1
      },
      {
        title: "Published", 
        field: "published", 
        widthGrow: 1,
        formatter: formatPublishedWithColor
        // formatter: function(cell) {
        //   const cellElement = cell.getElement();
        //   const freshness = cell.getData().paperFreshness;
        //   cellElement.setAttribute("data-paper-freshness", freshness);
        //   return cell.getData().published;
        // }
      },
      {
        title: "Tags", 
        field: "tags", 
        widthGrow: 1,
        formatter: formatTags
      },
      {
        title: "Last Read Date", 
        field: "lastRead", 
        widthGrow: 1
      },
      {
        title: "Last Read time", 
        field: "lastReadTimestamp", 
        widthGrow: 1
      }
    ],
    rowFormatter: function(row) {
      // Add paper ID as data attribute
      const rowElement = row.getElement();
      const paper_Id = row.getData().paperKey;
      console.log("formatter detected paperId:", paper_Id);
      rowElement.setAttribute("data-paper-id", paper_Id);
    }
  });
  
  // Initialize filter manager and status bar
  filterManager = new FilterManager(table);
  filterStatusBar = new FilterStatusBar(filterManager);
  
  // Remove loading message
  document.querySelector(".loading").style.display = "none";
  
  // Set up global click handler for the table
  document.getElementById("papers-table").addEventListener("click", function(e) {
    // Find the closest row element
    const rowElement = e.target.closest(".tabulator-row");
    if (rowElement) {
      const paperId = rowElement.getAttribute("data-paper-id");
      console.log("detected click on row for paperId:", paperId);
      if (paperId) {
        displayPaperDetails(paperId);
      }
    }
  });
}

// Helper functions for filters
function createSearchFilter(searchTerm) {
  const term = searchTerm.toLowerCase().trim();
  return function(data) {
    if (!term) return true;
    
    const searchableText = [
      data.title,
      data.authors,
      data.abstract,
      ...(data.tags || [])
    ].join(' ').toLowerCase();
    
    return searchableText.includes(term);
  };
}

function createMultiSearchFilter(searchTerms) {
  // OR logic: papers must contain ANY of the search terms
  return function(data) {
    if (!searchTerms || searchTerms.length === 0) return true;
    
    const searchableText = [
      data.title,
      data.authors,
      data.abstract,
      ...(data.tags || [])
    ].join(' ').toLowerCase();
    
    return searchTerms.some(term => 
      searchableText.includes(term.toLowerCase().trim())
    );
  };
}

function createDateRangeFilter(fromDate, toDate) {
  return function(data) {
    if (!fromDate && !toDate) return true;
    if (!data.published) return false;
    
    const publishedDate = data.published;
    
    if (fromDate && toDate) {
      return publishedDate >= fromDate && publishedDate <= toDate;
    }
    
    if (fromDate) {
      return publishedDate >= fromDate;
    }
    
    if (toDate) {
      return publishedDate <= toDate;
    }
    
    return true;
  };
}

function createReadingTimeFilter(minMinutes) {
  const minSeconds = minMinutes * 60;
  return function(data) {
    return data.readingTimeSeconds >= minSeconds;
  };
}

function createInteractionDaysFilter(minDays) {
  return function(data) {
    return data.interactionDays >= minDays;
  };
}

// Multi-search state management
let searchTermCounter = 0;
let currentPreviewSearchTerm = null;

// Setup event listeners for filters and search
function setupEventListeners() {
  const searchInput = document.getElementById("search-input");
  
  // Heatmap metric selector
  document.getElementById("heatmap-metric-selector").addEventListener("change", function(e) {
    currentHeatmapMetric = e.target.value;
    console.log("Heatmap metric changed to:", currentHeatmapMetric);
    
    // Update heatmap based on current state
    if (currentDetailsPaper) {
      const singlePaperActivity = extractReadingActivityData([currentDetailsPaper], currentHeatmapMetric);
      createReadingHeatmap(singlePaperActivity);
    } else if (filterManager && filterManager.filters.size > 0) {
      filterManager.updateHeatmap();
    } else {
      const activityData = extractReadingActivityData(allData, currentHeatmapMetric);
      createReadingHeatmap(activityData);
    }
  });
  
  // Global search with debouncing for preview
  let searchTimeout;
  searchInput.addEventListener("input", function(e) {
    const searchTerm = e.target.value.trim();
    
    // Clear previous timeout
    clearTimeout(searchTimeout);
    
    // Debounce search input for preview
    searchTimeout = setTimeout(() => {
      if (searchTerm) {
        // Show preview of current search term
        currentPreviewSearchTerm = searchTerm;
        filterManager.setFilter('search-preview', createSearchFilter(searchTerm), `Search: "${searchTerm}"`);
      } else {
        // Clear preview when input is empty
        currentPreviewSearchTerm = null;
        filterManager.removeFilter('search-preview');
      }
    }, 300);
  });
  
  // Handle Enter key to commit search term
  searchInput.addEventListener("keydown", function(e) {
    if (e.key === "Enter") {
      e.preventDefault();
      const searchTerm = e.target.value.trim();
      
      if (searchTerm) {
        // Remove the preview filter
        filterManager.removeFilter('search-preview');
        currentPreviewSearchTerm = null;
        
        // Add committed search term with unique ID
        const searchId = `search-${++searchTermCounter}`;
        filterManager.setFilter(searchId, createSearchFilter(searchTerm), `Search: "${searchTerm}"`);
        
        // Clear the input for next search term
        e.target.value = "";
      }
    }
  });
  
  // Clear search button - clears current input and preview
  document.getElementById("clear-search").addEventListener("click", function() {
    document.getElementById("search-input").value = "";
    filterManager.removeFilter('search-preview');
    currentPreviewSearchTerm = null;
  });
  
  // Toggle filter sidebar
  document.getElementById("sidebar-toggle").addEventListener("click", function() {
    document.getElementById("sidebar").classList.toggle("active");
    
    // Close details sidebar if open (to avoid both being open at once)
    document.getElementById("details-sidebar").classList.remove("active");
  });
  
  // Floating filter button
  document.getElementById("filter-toggle-btn").addEventListener("click", function() {
    document.getElementById("sidebar").classList.toggle("active");
    
    // Close details sidebar if open (to avoid both being open at once)
    document.getElementById("details-sidebar").classList.remove("active");
  });
  
  // Toggle details with keyboard escape key
  document.addEventListener("keydown", function(e) {
    if (e.key === "Escape") {
      document.getElementById("details-sidebar").classList.remove("active");
      document.getElementById("sidebar").classList.remove("active");
    }
  });
  
  // Date range filters
  document.getElementById("apply-date-filter").addEventListener("click", function() {
    const fromDate = document.getElementById("date-filter-from").value;
    const toDate = document.getElementById("date-filter-to").value;
    
    if (fromDate || toDate) {
      const description = formatDateRangeDescription(fromDate, toDate);
      filterManager.setFilter('dateRange', createDateRangeFilter(fromDate, toDate), description);
    } else {
      filterManager.removeFilter('dateRange');
    }
  });
  
  document.getElementById("clear-date-filter").addEventListener("click", function() {
    document.getElementById("date-filter-from").value = "";
    document.getElementById("date-filter-to").value = "";
    filterManager.removeFilter('dateRange');
  });
  
  // Reading time filter
  document.getElementById("apply-reading-filter").addEventListener("click", function() {
    const minReading = document.getElementById("min-reading-time").value;
    
    if (minReading && minReading > 0) {
      filterManager.setFilter(
        'readingTime', 
        createReadingTimeFilter(parseInt(minReading)), 
        `Reading time: ≥${minReading} min`
      );
    } else {
      filterManager.removeFilter('readingTime');
    }
  });
  
  document.getElementById("clear-reading-filter").addEventListener("click", function() {
    document.getElementById("min-reading-time").value = "";
    filterManager.removeFilter('readingTime');
  });
  
  // Interaction days filter
  document.getElementById("apply-days-filter").addEventListener("click", function() {
    const minDays = document.getElementById("min-interaction-days").value;
    
    if (minDays && minDays > 0) {
      const days = parseInt(minDays);
      filterManager.setFilter(
        'interactionDays', 
        createInteractionDaysFilter(days), 
        `Interaction days: ≥${days}`
      );
    } else {
      filterManager.removeFilter('interactionDays');
    }
  });
  
  document.getElementById("clear-days-filter").addEventListener("click", function() {
    document.getElementById("min-interaction-days").value = "";
    filterManager.removeFilter('interactionDays');
  });
  
  // Reset all filters
  document.getElementById("reset-all-filters").addEventListener("click", function() {
    // Clear all input fields
    document.getElementById("search-input").value = "";
    document.getElementById("date-filter-from").value = "";
    document.getElementById("date-filter-to").value = "";
    document.getElementById("min-reading-time").value = "";
    document.getElementById("min-interaction-days").value = "";
    
    // Reset search counter and preview state
    searchTermCounter = 0;
    currentPreviewSearchTerm = null;
    
    // Clear all filters through filter manager
    filterManager.clearAll();
  });
}

// Helper function to format date range descriptions
function formatDateRangeDescription(fromDate, toDate) {
  if (fromDate && toDate) {
    return `Date: ${fromDate} to ${toDate}`;
  } else if (fromDate) {
    return `Date: from ${fromDate}`;
  } else if (toDate) {
    return `Date: until ${toDate}`;
  }
  return 'Date range';
}

// Load and initialize
document.addEventListener("DOMContentLoaded", function() {
  // Fetch data file
  fetch("gh-store-snapshot.json")
    .then(response => {
      if (!response.ok) {
        throw new Error("Failed to load data.json");
      }
      return response.json();
    })
    .then(data => {
      allData = processComplexData(data);
      
      // Initialize table and heatmap
      initTable(allData);
      
      // Create initial heatmap with default metric
      const activityData = extractReadingActivityData(allData, currentHeatmapMetric);
      createReadingHeatmap(activityData);
      
      setupEventListeners();
    })
    .catch(error => {
      document.querySelector(".loading").innerHTML = 
        `Error loading data: ${error.message}. Make sure data.json exists in the same directory as this HTML file.`;
    });
});


