\documentclass[numbers]{article}

\usepackage{microtype}
\usepackage{subfigure}
\usepackage{array}    %
\usepackage[table]{xcolor}
\usepackage{amssymb}
\usepackage{pifont}  %
\usepackage{graphicx}
\usepackage{breakurl}
\usepackage{subcaption} 
\usepackage{fontawesome}

\usepackage{url}




\usepackage[final]{neurips_2024}







\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\usepackage{wrapfig}

\usepackage{amsmath}
\usepackage{amssymb} %
\usepackage{mathtools}
\usepackage[utf8]{inputenc} %
\usepackage[T1]{fontenc}    %
\usepackage{hyperref}       %
\usepackage{url}            %
\usepackage{booktabs}       %
\usepackage{amsfonts}       %
\usepackage{nicefrac}       %
\usepackage{microtype}      %
\usepackage{xcolor}         %

\usepackage{xspace}

\usepackage{url}

\usepackage{pifont} %
\usepackage{tikz} %

\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%

\definecolor{correctgreen}{rgb}{0.0, 0.5, 0.0}
\definecolor{incorrectred}{rgb}{0.9, 0.0, 0.0}
\definecolor{debatableamber}{rgb}{1.0, 0.75, 0.0}
\newcommand{\qmark}{\textbf{?}} %
\definecolor{rowgray}{gray}{0.95}

\usepackage{caption}

\usepackage{multirow} %


\title{BitDelta: Your Fine-Tune May Only Be Worth One Bit}

\newcommand{\oursmethod}{BitDelta\xspace}



\author{
\hspace{-0.45cm}
James Liu$^{1}$\thanks{Correspondence to \href{mailto:jamesll@mit.edu}{\url{jamesll@mit.edu}}, \href{mailto:tianle.cai@princeton.edu}{\url{tianle.cai@princeton.edu}}. Tianleâ€™s contribution was partially
done during consulting at Together AI.} 
\space\space%
Guangxuan Xiao$^{1}$
\space
Kai Li$^2$
\space
Jason D. Lee$^2$
\space
Song Han$^{1,3}$
\space
Tri Dao$^{2,4}$
\space
Tianle Cai$^{2,4*}$ \\ \\
$^1$MIT \quad $^2$Princeton University \quad $^3$NVIDIA \quad $^4$Together AI  \\ \\
\faGithub \,\,\,\url{https://github.com/FasterDecoding/BitDelta}
}


\begin{document}


\maketitle


\begin{abstract}
Large Language Models (LLMs) are typically trained in two phases: pre-training on large internet-scale datasets, and fine-tuning for downstream tasks. Given the higher computational demand of pre-training, it is intuitive to assume that fine-tuning adds less new information to the model, and is thus more compressible. We explore this assumption by decomposing the weights of fine-tuned models into their pre-trained components and an additional \emph{delta}. We introduce a simple post-fine-tuning method, \oursmethod, which successfully quantizes this delta down to 1 bit without compromising performance. This interesting finding not only highlights the potential redundancy of information added during fine-tuning, but also has significant implications for the multi-tenant serving and multi-tenant storage of fine-tuned models. By enabling the use of a single high-precision base model accompanied by multiple 1-bit deltas, \oursmethod dramatically reduces GPU memory requirements by more than 10$\times$, thus reducing per-user generation latency by more than $10\times$ in multi-tenant settings. We validate \oursmethod through experiments across Llama-2, Mistral and MPT model families, and on models up to 70B parameters, showcasing minimal performance degradation in all tested settings. 
\end{abstract}


\section{Introduction}
\label{sec:intro}
After large-scale pretraining, foundation models are typically fine-tuned for specific downstream tasks \citep{devlin2019bert,radford2018improving,radford2019language}. This \textit{pretrain-finetune} paradigm has revolutionized machine learning; LLMs have not only proven effective for critical tasks such as instruction following and alignment \cite{ouyang2022training}, but are also performant on a wide array of niche yet highly impactful applications \cite{edgecloud,healthinfo}. Through fine-tuning, LLMs are adeptly equipped to align with distinct user preferences or specialized task requirements, showcasing an unprecedented level of adaptability. Thus, the prospect of serving millions of uniquely fine-tuned models, each tailored to individual tasks and user needs, presents a promising vision for the future of machine learning.

Realizing this vision is challenging due to two key reasons: 1) \textbf{Expensive Storage.} Each new fine-tuned model is large, even if we have relatively few base models, making them expensive to store and challenging to manage on disk. 2) \textbf{Expensive Serving.} Distinct fine-tuned models each demand significant GPU memory, making it difficult and expensive to concurrently serve such models without noticeable downtime. To tackle these issues, we decompose the fine-tuned model weights into the weights of the base pre-trained model and a \emph{delta} induced by the fine-tuning process. By compressing this delta while maintaining model performance, we aim to sidestep the prohibitive costs associated with storage and GPU memory demands.

From the delta decomposition point of view, parameter-efficient fine-tuning (PEFT) methods like LoRA~\citep{hu2021lora,houlsby2019parameter, rebuffi2017learning,dettmers2023qlora,chen2023longlora} effectively enforce a highly structured and compressed form of delta \emph{during fine-tuning}, a powerful insight for model serving of PEFT-based fine-tunes. \citet{sheng2023slora} and \citet{punica} explore multi-tenant serving of LoRA-based fine-tunes.

\setlength{\belowcaptionskip}{-5pt}
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.75\textwidth]{BitDelta.png}
    \caption{\textbf{Overview of \oursmethod}. \oursmethod applies 1-bit quantization to the weight delta between fine-tuned and base models. For each weight matrix, we quantize its delta as its sign bits and a trainable high-precision scale factor. The scale factor is initialized to achieve the best approximation error in $L_2$ norm and further refined with a few distillation steps. \oursmethod shows minimal degradation in model performance and reduces memory consumption in multi-tenancy serving by representing multiple fine-tuned models with a single high-precision base model and multiple 1-bit deltas.}
    \label{fig:enter-label}

\end{figure}
Nevertheless, recent work has shown that PEFT methods may not yet match the model quality of full parameter fine-tuning, especially on high resource tasks \cite{chen2022revisiting}, and are fairly sensitive to hyperparameter choice and prompting methods \cite{Anyscale2023}. \citet{biderman2024lora} show that LoRA's reduced expressivity, although providing desirable regularization, leads to significantly worse performance compared to full fine-tuning in math and programming tasks. As a result, we notice that among the 2307 LLMs (as of time of writing) on the Open LLM Leaderboard~\citep{open-llm-leaderboard} with a valid README file, only $< 20\%$ indicate that they exclusively use LoRA. Most models are full parameter fine-tunes, model merges \cite{yu2023language,jin2023dataless,wortsman2022model} of full parameter fine-tunes, or model merges of LoRA based fine-tunes (which are effectively high-rank).

\begin{wrapfigure}[16]{r}{0.5\textwidth} %
  \centering
  \includegraphics[width=0.4\textwidth]{highrank.png} %
  \caption{Cumulative Explained Variance (CEV) plot of a $4096 \times 4096$ weight delta between \textit{Llama 2-7B} and \textit{Vicuna-7B v1.5}. Deltas from full parameter fine-tuning are fairly high rank, making low-rank approximations difficult.}
  \label{fig:highrank}
\end{wrapfigure}

It is also attractive to approximate general deltas with low-rank matrices \emph{post-training} (in particular, \emph{post-fine-tuning}). However, experimental results show that this is challenging (Table \ref{lora-results}), as deltas from full parameter fine-tunes tend to be fairly high-rank (Figure \ref{fig:highrank}). 






We instead draw from the insight that motivates PEFT methods in general: Given the higher computational demand of pre-training, it is intuitive to assume that fine-tuning adds less new information to the model, and is thus \emph{much} more compressible. In fact, we find that we can efficiently \emph{quantize} the delta to merely \emph{1 bit} with almost no performance drop. We propose \oursmethod, an efficient post-training quantization (PTQ) solution that acts on the weight delta between a fine-tuned model and its underlying base model. 

\begin{table*}[htbp]
    \centering
    \caption{Comparison between \oursmethod and a SVD based method, with \textit{Llama 2-7B} and \textit{Llama 2-7B Chat} as the base and fine-tuned models. \oursmethod is performant across the board, whereas the SVD-based method fails to sufficiently capture the fine-tuned information.}
    \label{lora-results}
    \resizebox{0.8\textwidth}{!}{
    \begin{tabular}{@{}lccccc@{}}
        \toprule
        Model/Method & TruthfulQA & GSM8K & MT-Bench & Adjusted Average\ref{footnote1} $\uparrow$ \\
        
        \midrule
        \textit{Llama 2-7B} & 38.96 & 13.57 & -- & 60.53 \\

        \midrule
        \textit{Llama 2-7B Chat} & 45.32 & 22.74  & 6.56 & 59.81 \\

        \midrule
        BitDelta-Initial & 41.10 & 18.27 & 6.31 & 60.70 \\
        BitDelta & 44.95  & 20.24 & 6.47 & 59.88  \\
        
        \midrule
        SVD-Initial ($r=16$) & 42.57 & 7.13 & 4.73 & 60.58  \\
        SVD ($r=16$) & 42.42 & 5.05 & 4.99 & 60.71 \\

        \midrule
        SVD-Initial ($r=128$) & 43.90 & 17.82 & 5.68 & 60.21  \\
        SVD ($r=128$) & 43.32 & 11.83 & 5.85 & 60.58 \\

        \bottomrule
    \end{tabular}
    }
\end{table*}

\oursmethod consists of two stages: 1) We quantize the delta between a fine-tuned model's weight matrix and base model's weight matrix into a scaling factor multiplied by a binary matrix. Specifically, we take the sign of the weight delta to form the binary matrix and initialize the scaling factor as the average of the absolute values of the delta, minimizing $L_2$ quantization error. 2) We further calibrate the scaling factors through model distillation over a small calibration dataset while keeping the binary matrices frozen. Despite the small number of trainable parameters and calibration steps, we find that this distillation process is effective in further recovering model quality. Our experiments over 17 popular fine-tuned models affirm that \oursmethod can be applied across various model types and model sizes with minimal impact on performance.



\oursmethod creates opportunities to efficiently serve multiple fine-tuned models with shared servers: By only storing a single full-precision base model, and (dynamically) loading and performing batched inference over multiple 1-bit deltas, we can efficiently represent multiple fine-tuned models. Compared to naively using full precision fine-tuned models, deltas compressed by \oursmethod are more than 10$\times$ smaller, and can therefore be loaded faster. This addresses the storage challenge. Moreover, since LLM inference is memory-bound~\citep{leviathan2022fast,chen2023accelerating,cai2024medusa}, the latency of each decoding step is proportional to the GPU memory consumption of the model weights. With an efficient CUDA kernel implementation, we can translate this memory reduction into a latency reduction, similar to other quantization methods~\citep{frantar2022gptq,lin2023awq}. Using the $W_{INT1}A_{FP16}$ kernel from BitBLAS~\citep{ladder-osdi24}, we improve the multi-tenant serving latency of full-parameter fine-tuned models by more than $10\times$. 

Finally, we study a few extensions of \oursmethod, where we quantize the base model and where we iteratively apply \oursmethod. Experimental results show that our method is quite general and can be applied to various use cases.



\footnotetext[2]{Adjusted Average is over ARC, BBH, HellaSwag, WinoGrande, and excludes TruthfulQA, GSM8K, MT-Bench. \label{footnote1}}

\section{Related Work}
\label{sec:related}
\subsection{Full Model Compression}
\paragraph{Quantization.} Quantization techniques are widely used to reduce memory consumption and improve LLMs' generation latency. \citet{xiao2023smoothquant} implement a technique that rescales between activations and parameters, effectively mitigating outlier activations to facilitate smoother quantization. \citet{dettmers2022llm} develop an approach that decomposes matrix multiplications into 8-bit computations, with an additional 16-bit process for handling outliers. Exploring further, \citet{frantar2022gptq} introduce a method that iteratively rounds weight columns to 3-4 bits of precision. Similarly, \citet{lin2023awq} propose an activation-aware quantization scheme that selectively preserves crucial weights while compressing the majority to 3-4 bits. \citet{kim2023squeezellm} devise a sparse, low-precision pattern focusing on a small yet significant set of weights. \citet{chee2023quip} utilize incoherence processing to quantize model weights to as low as 2 bits with minimal impact on performance.

\paragraph{Pruning.}
Pruning also aims to reduce the memory consumption of neural networks. It accomplishes this by pushing certain parameter values to zero, inducing sparsity in the model~\citep{lecun1989obd,han2015learning,han2016deep,zhu2017prune}. However, these methods may fail to take advantage of modern hardware like GPUs unless using certain structured sparsity patterns like 2:4 (50\%) sparsity~\citep{mishra2021accelerating}. \citet{frantar2023sparsegpt} demonstrate a pruning method on LLMs that successfully utilizes the 2:4 sparsity pattern and achieves a 50\% sparsity ratio. It is challenging to obtain higher sparsity while being hardware-friendly. 


\paragraph{Early work on post-training delta compression.} Most related to our work, a few studies explore the idea of post-training delta compression by adopting existing compression techniques like GPTQ, unstructured pruning~\citep{han2016deep}, or even classic lossless compression algorithms. \citet{isik2023gptzip} focus on reducing the delta size to save storage. \citet{yu2023language} utilize pruning to improve model merging applications. \citet{yadav2023compeft} reduces the size of PEFT modules to save storage. \citet{ryu2023efficient} combines quantization with a low-rank approximation to reduce the delta size. The concurrent and independent work by \citet{yao2023deltazip} also explores using delta compression to improve multi-tenant serving, but focuses more on reducing the model loading time from disk to GPU. Compared to existing work, we offer a much simpler and faster method, \oursmethod, achieving a compression ratio of more than 10$\times$ while also being friendly to modern accelerators.


\section{\oursmethod}
\subsection{Method}
\label{sec:method}
\oursmethod consists of two stages: 1) We quantize each weight matrix into a scalar multiplied by a binary matrix\footnote{In our experiments, we only quantize the linear layers in the Transformer blocks as they contribute the majority of the parameters and computation.}. 2) We further calibrate the scalar factors using model distillation. We describe each stage in this section:

\paragraph{1-bit quantization.}  Let $W_\text{base}, W_\text{fine} \in \mathbb{R}^{n \times m}$ be weight matrices from the base model and fine-tuned model respectively. We define the weight delta as $\Delta = W_\text{fine} - W_\text{base}$, representing the modification in weights post-fine-tuning. For efficient representation of this weight delta, we aim to obtain a binarized estimator by encoding its sign bits, denoted as $\hat{\Delta}$:

\begin{equation}
    \hat{\Delta} = \alpha \odot \text{Sign}(\Delta),
\end{equation}
where
\begin{equation}
    \text{Sign}(W_{ij}) = 
    \begin{cases} 
      +1, & \text{if } W_{ij} > 0, \\
      -1, & \text{if } W_{ij} \leq 0,
    \end{cases}
\end{equation}
and $\alpha$ is a high-precision scaling factor for the entire matrix. To minimize the quantization error of $\Delta$ in $L_2$ norm:

\begin{equation}
    \left\lVert \Delta - \hat{\Delta} \right\rVert_2^2 = \sum_{ij}(|W_{ij}|- \alpha)^2,
\end{equation}
we initialize $\alpha$ as follows:
\begin{equation}
    \alpha = \frac{1}{nm} \sum_{ij} |\Delta_{ij}|.
\end{equation}

Surprisingly, we find that the above quantization approach already does quite well and retains most of the fine-tuned models' performance. 



\begin{table}[htbp]
    \centering
    \caption{\oursmethod works on Llama-2 and Mistral families and on a wide range of model sizes ranging from 7B to 70B parameters. \oursmethod works for many types of fine-tuned information, including SFT-based methods, RLHF-based methods, and context extension methods (RoPE scaling). Scale distillation is effective, raising TruthfulQA/GSM8K scores to within 1-2 points of the baseline fine-tune, and MT-Bench scores to within 0.1-0.2 points.}
    \label{main-results}
    \resizebox{0.85\textwidth}{!}{
    \begin{tabular}{@{}llcccc@{}}
        \toprule
         Model & Method & TruthfulQA & GSM8K & MT-Bench & Adjusted Average\ref{footnote1} $\uparrow$ \\

        \midrule
        \textit{Llama 2-7B} & -- & 38.96 & 13.57 & -- & 60.53 \\

        \midrule
        \multirow{3}{*}{\textit{Llama 2-7B Chat}} & Baseline & 45.32 & 22.74 & 6.56 & 59.81 \\
        & BitDelta-Initial & 41.10 & 18.27 & 6.31 & 60.7 \\
        & BitDelta & 44.95 & 20.24 & 6.47 & 59.88 \\

        \midrule
        \multirow{3}{*}{\textit{Vicuna-7B v1.5 16k}} & Baseline & 50.38 & 14.18 & 6.06 & 57.50 \\
        & BitDelta-Initial & 45.58 & 13.95 & 5.69 & 58.51\\
        & BitDelta & 48.75 & 14.48 & 6.24 & 57.64\\

        \midrule
        \textit{Llama 2-13B} & -- & 36.90 & 22.74 & -- & 64.68 \\
        
        \midrule
        \multirow{3}{*}{\textit{Llama 2-13B Chat}} & Baseline & 43.95 & 33.13 & 6.98 & 63.99 \\
        & BitDelta-Initial & 41.70 & 33.36 & 7.06 & 64.25 \\
        & BitDelta & 43.47 & 31.92 & 6.95 & 63.96 \\

        \midrule
        \multirow{3}{*}{\textit{Vicuna-13B v1.5 16k}} & Baseline & 50.38 & 29.72 & 6.90 & 57.5 \\
        & BitDelta-Initial & 41.7 & 26.76 & 6.60 & 64.25  \\
        & BitDelta & 48.75 & 28.73 & 6.88 & 57.64 \\

        \midrule
        \multirow{3}{*}{\textit{WizardLM-13B v1.2}} & Baseline & 47.17 & 42.38 & 6.95 & 61.61 \\
        & BitDelta-Initial & 44.89 & 42.08 & 6.73 & 61.91 \\
        & BitDelta & 46.67 & 41.62 & 6.93 & 61.86 \\

        \bottomrule
        
    \end{tabular}
    }
\end{table}





\paragraph{Scale distillation. } The scaling factor $\alpha$ intuitively plays a more significant role in the low-bit regime. Additionally, per-matrix $L_2$ weight error is not a perfect measure of degradation in \emph{overall} model quality. We further optimize these scales by performing model distillation to align the output logits of the quantized model to that of the original fine-tuned model. More concretely, we freeze the model weights and optimize for the following objective:

\begin{equation}
    \boldsymbol{\alpha}^* = \arg\min_{\boldsymbol{\alpha}} \mathbb{E}_{x \sim \mathbf{X}}\left[ \left\| \mathbf{Z}_{\text{fine}}(x) - \mathbf{Z}_{\text{bin}}(x; \boldsymbol{\alpha}) \right\|^2 \right]
\end{equation}

where $\mathbf{X}$ is a calibration dataset, and $\mathbf{Z}(\cdot)$ are the logits of the respective models. Scale distillation is fairly robust to choice $\mathbf{X}$, as 1) the process is extremely parameter efficient, and 2) the crucial aspect of the process is to logit match with the fine-tuned model, regardless of the actual text content.

For our experiments, we distill on the C4 dataset \citep{raffel2023exploring}, consisting of generic internet data, using 800 samples of length 128. We use the same subset of C4 over all models to control for seed-based variations. We use the Adam optimizer \cite{kingma2017adam} with $lr=10^{-4}$, $\beta = (0.9,0.999)$, $\epsilon=10^{-8}$. 1x80 GB A100 GPU is used to distill 7B and 13B models, and 6x80GB A100 GPUs are used to distill 70B models (2x for finetune, 4x for binarized). Scale distillation is fast; we can compress 70B models in roughly 10 minutes.




\subsection{Methodology Cost}
Compared to full parameter and parameter efficient fine-tuning methods, \oursmethod is extremely cheap. While fine-tuning methods require training thousands to millions of parameters, \oursmethod only necessitates training a single parameter per weight matrix. Moreover, \oursmethod operates efficiently with input sequences of length 128, unlike fine-tuning methods that demand longer sequences to saturate the context window (4k, 8k, etc.). Crucially, \oursmethod requires only 200 training steps (assuming a batch size of 4), which is significantly less compared to the 10000-1000000 steps at higher batch sizes needed by fine-tuning methods. Thus, in terms of methodology cost, we liken \oursmethod more to post-training quantization (PTQ) schemes like GPTQ \cite{frantar2022gptq} and AWQ \cite{lin2023awq}, rather than full parameter or parameter efficient fine-tuning, while being faster than most PTQ schemes.

\begin{table}[htbp]
    \centering
    \caption{Continuation of Table \ref{main-results}.}
    \resizebox{0.85\textwidth}{!}{
    \begin{tabular}{@{}llcccc@{}}
        \toprule
         Model & Method & TruthfulQA & GSM8K & MT-Bench & Adjusted Average\ref{footnote1} $\uparrow$ \\


        \midrule
        \textit{Llama 2-70B} & -- & 44.82 & 52.69 & -- & 71.81 \\
        
        \midrule
        \multirow{3}{*}{\textit{Llama 2-70B Chat}} & Baseline & 52.77 & 47.61 & 7.12 & 68.82 \\
        & BitDelta-Initial & 41.63 & 42.38 & 6.85 & 66.01 \\
        & BitDelta & 51.37  & 48.82 & 7.06 & 69.14 \\

        \midrule
        \multirow{3}{*}{\textit{Solar-0-70B}} & Baseline & 62.03 & 56.18 & 7.07 & 73.77 \\
        & BitDelta-Initial & 59.08 & 56.79 & 6.79 & 73.14 \\
        & BitDelta & 62.03 & 56.63 & 6.82 & 73.57 \\

        \midrule
        \textit{Mistral-7B v0.1} & -- & 42.60 & 37.76 & -- & 65.98 \\
        
        \midrule
        \multirow{3}{*}{\textit{Mistral-7B v0.1 Instruct}} & Baseline & 55.93 & 32.75 & 6.86 & 60.36 \\
        & BitDelta-Initial & 51.27 & 38.82 & 6.54 & 63.83 \\
        & BitDelta & 55.23 & 31.54 & 6.43 & 61.10 \\

        \midrule
        \multirow{3}{*}{\textit{Zephyr-7B-}$\beta$} & Baseline & 55.12 & 34.34 & 7.18 & 65.22 \\
        & BitDelta-Initial & 54.53 & 40.26 & 6.70 &  66.12 \\
        & BitDelta & 58.39 & 31.92 & 7.00 & 66.20 \\

                \midrule
        \multirow{3}{*}{\textit{Dolphin 2.2.1}} & Baseline & 54.02 & 54.28 & 7.36 & 67.31 \\
        & BitDelta-Initial & 48.14 & 50.27 & 7.10 & 67.58 \\
        & BitDelta & 54.91 & 52.84 & 7.20 & 66.97 \\

        \midrule
        \textit{MPT-7B} & -- & 33.37 & 6.22 & -- & 57.95 \\
        
        \midrule
        \multirow{3}{*}{\textit{MPT 7B-Chat}} & Baseline & 40.22 & 7.96 & 5.00 & 56.5 \\
        & BitDelta-Initial & 38.96 & 10.01 & 4.39 & 57.11 \\
        & BitDelta & 39.87 & 8.11 &  4.94 & 56.52 \\
        \bottomrule

    \end{tabular}
    }
\end{table}  



\subsection{Implication}
\label{sec:performance}
The ability to compress the delta to merely 1-bit opens up multiple opportunities for improving efficiency, enabling more effective model storage~\citep{isik2023gptzip} -- where a single base model can be maintained alongside multiple compressed deltas -- and facilitating model hot-swapping ~\citep{punica,sheng2023slora}. With hot-swapping, the base model remains in GPU memory, and compressed deltas are dynamically loaded in accordance to incoming requests. In both cases, the compression ratio can be directly translated into reductions in storage needs and loading times. 

Moreover, \oursmethod enables the possibility of a multi-tenant serving system like Punica~\citep{punica} or S-LoRA~\citep{sheng2023slora} but for general fine-tuned models instead of just LoRA models. Concretely, we consider the scenario where multiple models fine-tuned from the same base model are served with the same server. This setting greatly exploits the GPU resource and saves each fine-tuned model's inference cost when their traffic is low or unbalanced. With \oursmethod, we can keep one high-precision base model with multiple compressed deltas in the GPU memory. Compared to directly serving multiple fine-tuned models, this approach greatly saves memory consumption. 


Since LLM inference follows the memory-bound computation pattern where the generation latency is proportional to the GPU memory used by the model weights, the lower memory consumption also suggests the opportunity to improve the serving latency. For example, Punica and S-LoRA exploit LoRA's structure and memory saving by computing the activation product between the shared base weight, and low-rank fine-tuned delta weights separately. Similarly, we decompose the forward pass of each linear layer as follows:

\begin{equation}
    X'_i = W_{\text{fine}, i}X_i \approx W_{\text{base}}X_i + \underbrace{ \hat{\Delta}_iX_i}_{\text{\color{black}{\text{Kernel}}}}
    \label{eqn:kernel_decomp}
\end{equation}
where $X_i$ and $X_i'$ represent input and output features to the $i$-th fine-tuned model, and the base model weight and the 1-bit delta are computed separately. For a batch of requests, $W_{\text{base}}X_i$ can be computed with the classic batched GEMM kernel. We utilize the BitBLAS ~\citep{ladder-osdi24} $W_{INT1}A_{FP16}$ kernel that allows us to calculate $\hat{\Delta}_iX$ in a batched setting while keeping the 1-bit deltas quantized until they are transferred to the GPU cache. This kernel fuses the dequantization operation with the GEMM calculation, reducing the data moving overhead by a large factor.






\section{Experiments}
\label{sec:experiments}

\subsection{Setup}
\label{sec:setup}


\begin{table*}[htbp]
  \caption{Comparison of model responses from \textit{Zephyr-7B-}$\beta$ for Question 9 in MT-Bench, a concise advertisement task. \oursmethod-Initial is unable to follow the instructions, producing an advertisement that is overly formal and makes no attempt to adhere to the word limit. With the addition of scale distillation, \oursmethod successfully produces a concise, catchy advertisement slightly over the word limit. *Prompt slightly modified for clarity.
  }
  \label{tab:model_responses}
  \centering
  \resizebox{0.85\textwidth}{!}{
  \begin{tabular}{>{\raggedright\arraybackslash}m{0.2\textwidth}m{0.7\textwidth}}
    \toprule
    \textbf{Prompt} & Please create a slogan about bioenergy that satisfies the following: 1. Make the tone sound casual 2. Embed an advertisement for a company called "FlexPower" 3. Fewer than 10 words. \\
    \midrule

    \rowcolor{rowgray}
    \textbf{\oursmethod } & "FlexPower's groundbreaking bioenergy solution: Produce fuel without compromising food production!" (10 words)
    \newline \newline
    This headline is catchy, casual, and highlights the unique selling point of the... 
    \newline
    \textbf{GPT-4 Score: \textcolor{correctgreen}{8}}
    \\
    \midrule
    
    \textbf{\oursmethod-Initial} & "FlexPower's groundbreaking technology unlocks the key to harnessing the power of renewable bioenergy while minimizing ethical concerns" 
    \newline
    \textbf{GPT-4 Score: \textcolor{incorrectred}{4}}
    \\
    \bottomrule
  \end{tabular}}
\end{table*}

\paragraph{Baselines. } Our primary baselines are the original fine-tuned models without compression. We also compare with 8-bit RTN, 4-bit GPTQ \citep{frantar2022gptq}, and 2-bit QuIP\# \citep{tseng2024quip} on evaluations where we run \oursmethod on quantized base models.

\paragraph{Models and datasets. } We benchmark fine-tuned models based on the Llama-2 \citep{touvron2023llama}, Mistral \citep{jiang2023mistral}, and MPT \citep{mosaicmpt} model families: Vicuna, Xwin-LM, Solar-70B, Zephyr, OpenChat 3.5, Dolphin 2.2.1, and OpenOrca \cite{vicuna2023,xwin-lm,Solar70B,tunstall2023zephyr,wang2023openchat,Hartford2023,mukherjee2023orca}. We evaluate on eight tasks: MT-Bench, 25-shot ARC Challenge, 5-shot BBH, 10-shot HellaSwag, zero-shot TruthfulQA, zero-shot LAMBADA, zero-shot Winogrande, and 5-shot GSM8K \citep{zheng2023judging,clark2018think,suzgun2022challenging,zellers2019hellaswag,lin2022truthfulqa,paperno2016lambada,sakaguchi2019winogrande,cobbe2021training}. We use \texttt{FastChat} \citep{zheng2023judging} to evaluate on MT-Bench, and use \texttt{lm-evaluation-harness} \citep{eval-harness} to evaluate on the other tasks. We denote our methodology before scale distillation is applied as \oursmethod -Initial.

We primarily focus on high-margin metrics where fine-tuning is significantly impactful and aggregate the other metrics. See Tables \ref{peft-results-app} to \ref{main-results-app} in the Appendix for full results. \oursmethod performs quite well on the aggregated metrics, even outperforming the baseline in many cases. However, it's important to contextualize these results with regard to the base model itself, which is also performant on these metrics. It's difficult to attribute performance to our methodology or to the underlying base model in such cases. Because of this, we highlight TruthfulQA, GSM8K, and MT-Bench, which base models tend to struggle on, to show that \oursmethod accurately preserves fine-tune information.



\subsection{Accurate Quantization}
\label{sec:accuracy}

\begin{wraptable}{r}{0.5\linewidth}
    \centering
    \caption{\oursmethod \ achieves over 10$\times$ compression. We can further compress the embedding and LM head layers, but leave this to future work due to inconsistencies in tokenizer vocabularies.}
    \label{xfactor-results}
    \resizebox{0.45\textwidth}{!}{
    \begin{tabular}{@{}lccc@{}}
        \toprule
        Base Model & Size & $\Delta$ Size & Comp. Factor \\
        \midrule

        \textit{Llama 2-7B} & 13.48 GB & 1.24 GB & 10.87 \\
        \textit{Llama 2-13B} & 26.03 GB & 2.09 GB & 12.45 \\
        \textit{Llama 2-70B} & 137.95 GB & 8.95 GB & 15.41 \\
        \textit{Mistral-7B v0.1} & 14.48 GB & 1.30 GB & 11.14 \\
        
        \bottomrule
    \end{tabular}
    }
    
\end{wraptable}

\paragraph{SVD comparison. } 
We compare \oursmethod to a low rank approx. of the weight delta on \textit{Vicuna-7B v1.5}. For the low rank approx., we decompose $\Delta=U\Sigma V$ and approximate $\hat{\Delta}=AB$ where $A=U\sqrt{\hat{\Sigma}}$, $B=\sqrt{\hat{\Sigma}}V$. During distillation, we treat all entries of the low rank matrices as trainable parameters. We compare against two settings: $r=16$ (most commonly used) and $r=128$ (memory equivalence with \oursmethod). We find that the low rank approx. fails to fully capture the fine tune information, and underperforms across the board (Table \ref{lora-results}). In particular, the low rank approx. heavily underperforms on MT-Bench \cite{vicuna2023}, a difficult multi-turn instruction following dataset fairly indicative of real world performance. Interestingly, distillation is not as effective for the low rank approx. compared to \oursmethod. %



\paragraph{Main Results. } \oursmethod is performant across various model families, across a wide range of model sizes, and across many fine-tuning techniques. We benchmark on Llama-2, Mistral, and MPT, families, and on models ranging from 7B to 70B parameters. Shown in Table \ref{main-results}, we find that \oursmethod is very general and can recover all types of finetune information, including SFT-based methods \cite{radford2018improving} on \textit{Mistral-7B v0.1 Instruct}, RLHF-based methods \cite{ christiano2023deep} on \textit{Llama 2 Chat}, and context extension methods (RoPE scaling) \cite{chen2023extending,press2022train} on \textit{Vicuna-7B v1.5 16k}.  



We note that GSM8K for \oursmethod -Initial on \textit{Mistral-7B v0.1 Instruct} and \textit{Zephyr-7B}-$\beta$ is abnormally high; we attribute this to how performant the base model \textit{Mistral-7B v0.1} is on this task in comparison. Scale distillation is effective, raising TruthfulQA and GSM8K scores to within 1-2 points of the baseline fine-tune, and generally raising MT-Bench scores to within 0.1-0.2 points.


\begin{table*}[tbp]
    \centering
    \caption{We apply \oursmethod to \textit{Llama 2-7B Chat} (with corresponding base model \textit{Llama 2-7B}), and find it holds up when the underlying base model is quantized at various levels. %
    }
    \label{quant-results}
    \resizebox{0.85\textwidth}{!}{
    \begin{tabular}{@{}llcccc@{}}
        \toprule
        Base Model & Method & TruthfulQA & GSM8K & MT-Bench & Adjusted Average\ref{footnote1} $\uparrow$ \\
        
        \midrule
        \multirow{3}{*}{Baseline} & FP16 & 45.32 & 22.74 & 6.56 & 59.81 \\
        & INT8 RTN & 45.02 & 22.29 & 6.28 & 59.63 \\
        & GPTQ & 44.92 & 19.48 & 5.90 & 58.67 \\
        & QuIP\# & 43.69 & 10.77 & 5.37 & 55.82 \\
        
        \midrule
        \multirow{3}{*}{\textit{Llama 2-7B}} & FP16 + $\Delta$ & 44.95 & 20.24 & 6.47 & 59.88 \\
        & INT8 RTN + $\Delta$ & 44.71 & 19.86 & 6.16 & 59.85 \\
        & GPTQ + $\Delta$ & 42.52 & 19.94 & 6.02 & 59.22 \\
        & QuIP\# + $\Delta$ & 42.00 & 9.72 & 4.96 & 57.44 \\

        \bottomrule
    \end{tabular}
    }
    
\end{table*}


\paragraph{Case Study. }
We present a sample response from \textit{Zephyr-7B-}$\beta$ in Table \ref{tab:model_responses}, highlighting the efficacy of scale distillation. \oursmethod -Initial does not have a casual tone, and makes no attempt to adhere to the word limit. With the introduction of scale distillation, \oursmethod exhibits greater instruction following capabilities, producing a catchy response that slightly exceeds the word limit.





\paragraph{Quantized base models. }



Because 8-bit RTN, GPTQ, and QuIP\# work with 16-bit activations, we can keep the fine-tune weights $W_\text{fine}$ and scaling factors $\alpha$ in high precision in the compression process, only quantizing the base weights $W_\text{base}$. As shown in Table \ref{quant-results}, we find that \oursmethod is still performant when applied to quantized base models. 






\begin{wrapfigure}[14]{r}{0.5\textwidth} %
    \hspace{-10pt}
    \centering
    \includegraphics[width=0.8\linewidth]{nbit.png}
    \caption{As the fidelity of $\Delta$ increases, the TruthfulQA scores of \textit{Llama 2-7B} + $\Delta$ approaches that of \textit{Vicuna-7B v1.5}.}
    \label{fig:nbit}
\end{wrapfigure}


\paragraph{Ablation over fidelity of $\Delta$. }
By successively applying \oursmethod, treating the compressed model from the previous iteration as our base model, we can vary the granularity over the delta, associating it with multiple 1-bit masks. One advantage of doing this is the ability to assign arbitrary scale factors to each 1-bit mask. In contrast, when increasing the bit size, scale factors are implicitly fixed with respect to each other. Figure \ref{fig:nbit} shows how the TruthfulQA of \textit{Llama 2-7B} plus an increasingly granular delta approaches that of \textit{Vicuna-7B v1.5}. Full results are in Table \ref{nbit-results-app}.



\subsection{Latency Improvement}
\label{sec:kernel}

For simplicity, we consider the setting where each model receives one distinct request simultaneously. It would be insightful to develop more sophisticated serving systems, which we leave to future work. Following the decomposition in Eq.~\eqref{eqn:kernel_decomp}, the $W_{INT1}A_{FP16}$ kernel is used to compute the batched matrix multiplication between $B$ binary matrices ($N\times M$) and $B$ high-precision activations ($L\times N$) where $N, M$ are intermediate dimensions and $L$ is the sequence length. We focus on decoding latency which dominates runtime, as opposed to prefill latency. Tokens are generated one by one when decoding, meaning $L$ is always 1. For all latency experiments we use a single A100 80GB with power limit set to 500W. 

\begin{figure}
    \centering
    \begin{subfigure}
        \centering
        \includegraphics[width=0.45\linewidth]{kernel1.png}
    \end{subfigure}%
    \hspace{10mm}
    \begin{subfigure}
        \centering
        \includegraphics[width=0.45\linewidth]{kernel2.png}
    \end{subfigure}
    
    \caption{Decoding latency of a linear layer, as in Eqn. \ref{eqn:kernel_decomp}. Black: Shared base weight backbone $W_\text{base}X$. Blue: Batched activation-product with $B$ 1-bit deltas, as in \oursmethod. Red: Batched activation-product with $B$ low-rank deltas, as in S-LoRA. Left: Ablation over hidden size, assuming $N=M$ and $B=1$. Right: Ablation over batch size, assuming $N=M=4096$.}
    \label{fig:kernelstuff}
\end{figure}




\paragraph{Kernel latency.}
We benchmark the decoding latency of our kernel, a batched linear operation over multiple 1-bit deltas, corresponding to the delta component of Eq.~\eqref{eqn:kernel_decomp}. We compare this to the S-LoRA kernel, a batched linear operation over multiple low-rank deltas, and also compare this to the base weight backbone shared over all deltas. We set $r=128$ for S-LoRA, to maintain memory equivalence with \oursmethod at $N=M=4096$.

We profile the latency of the backbone ($W_\text{base}X$) and deltas ($\Delta X$) separately. Although $X$'s memory footprint scales with batch size, it is negligible compared to $W_\text{base}$, which remains constant. For typical low to medium batch settings, which is typical for $B \times N \ll N \times M$. In such settings, the overall memory footprint of the backbone is effectively independent of batch size, as shown in Figure \ref{fig:kernelstuff} (left). This is in contrast with that of the deltas, which scales with the batch size, as each additional client in the batch adds an additional delta. At batch size 1 (Figure \ref{fig:kernelstuff}, right), backbone latency dominates over delta latency (\oursmethod and S-LoRA) due to $W_\text{base}$'s 16$\times$ larger memory footprint compared to a single delta. As the batch size increases (Figure \ref{fig:kernelstuff}, left), the combined memory footprint of multiple deltas exceeds $W_\text{base}$ around $B=6$ to $B=8$.

\oursmethod underperforms slightly compared to S-LoRA in large-batch settings as the LoRA kernel is highly optimized for GPU. We emphasize that closing or even surpassing the gap is tractable. For example, \citet{ma2024era} point out that $W_{INT1}A_{FP16}$ requires no multiplication operations and that new hardware can be co-designed with this in mind to drastically reduce energy/latency costs.

\begin{figure}[htbp]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{memusage.png}
        \caption{Memory usage of \textit{Llama 2-7B}, assuming each sequence in the batch has a length of $128$.  Blue: Memory usage of the naive method, separately storing $B$ distinct fine-tuned models. Orange: Projected values for the naive method. Green: Memory usage of \oursmethod. The naive forward pass succumbs to GPU memory issues at higher batch sizes.}
        \label{fig:memusage}
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{e2e.png}
        \caption{End-to-end decoding latency of \textit{Llama 2-7B}. Blue: Naive forward pass with $B$ distinct fine-tuned models. Orange: Projected values for the naive forward pass. Green: Batched forward pass with \oursmethod. Gray: Batched forward pass with S-LoRA. The naive forward pass succumbs to GPU memory issues at higher batch sizes.}
        \label{fig:e2e}
    \end{minipage}
\end{figure}

\paragraph{End-to-end latency.}
We benchmark the end-to-end decoding latency on \textit{Llama 2-7B} variants with an input length of 128 (we find the decoding latency is less sensitive to the input length), ablated across batch size. For \oursmethod and S-LoRA, the forward pass consists of the addition of two components: a single backbone pass (batch independent) and a delta pass (scales with batch size).

We compare \oursmethod and S-LoRA with a naive method that computes each $W_{i}X_{i}$ separately in the forward pass. This naive approach scales poorly with batch size as it effectively maintains a separate backbone ($W_i$) for each client in the batch. Given the substantial memory footprint of the backbone, this leads to significant memory usage as batch size increases. In contrast, \oursmethod and S-LoRA share a single backbone across all clients in the batch, with only the 16$\times$ smaller deltas scaling with batch size. This allows for more efficient memory utilization and better performance at larger batch sizes.

We find that \oursmethod and S-LoRA introduce overhead when the batch size is low. However, \oursmethod and S-LoRA scale better and successfully translate the saved GPU memory to improved decoding latency, starting at $B=2$. This is exacerbated at larger batch sizes, where the naive approach succumbs to out-of-memory issues and \oursmethod and S-LoRA are still performant. In the $B \geq 16$ regime, used in modern serving solutions, \oursmethod has a >$10\times$ lower per-user decoding latency than the naive method.


\section{Conclusion}
\label{sec:conclusion}
We propose \oursmethod, a simple but effective approach to efficiently quantifyings the weight delta arising from the fine-tuning of LLMs down to 1 bit. \oursmethod encodes the sign bits of the weight delta and a per-weight matrix scaling factor, which is calibrated further through distillation. This allows for representing multiple full-parameter fine-tuned models with one base model and multiple 1-bit deltas, enhancing applications in multi-tenancy serving by reducing GPU memory requirements and improving generation latency. \oursmethod is fast and accurate, showcasing minimal performance degradation, and opens new avenues for efficient model deployment and resource utilization in machine learning.















\begin{ack}
We thank Together AI, MyShell AI, National Science Foundation (NSF), MIT-IBM Watson AI Lab, and MIT Amazon Science Hub for supporting this research.
\end{ack}

\bibliography{neurips}
\bibliographystyle{plainnat}



\clearpage

\appendix

\section{Appendix}

\subsection{Societal Impact}
\label{sec:impact}
\paragraph{Democratization of Fine-tuned Models.}
By dramatically reducing the hardware requirements for serving fine-tuned models, \oursmethod enables smaller entities to deploy state-of-the-art models more feasibly. This can accelerate innovation and application development across various industries and academic fields, making fine-tuned models accessible to a wider audience.

\paragraph{Dealignment Mitigation.}
\oursmethod is a lossy compression method on the fine-tune information in LLMs. As such, crucial alignment information may be lost in the process of compression. We believe this is an important consequence to highlight, as \oursmethod democratizes multi-tenant applications which may exacerbate this dealignment concern. We encourage further work on evaluation techniques to detect alignment loss in \oursmethod, which can lead to the creation of robust methods for its mitigation.

\subsection{Additional Experiments}

\begin{table}[htbp]
    \centering
    \caption{We train a $r=16$ LoRA finetune of \textit{Llama 2-7B} on 1 epoch of UltraChat \cite{ding2023enhancing} and apply \oursmethod with minimal performance degradation. This further shows the generality of \oursmethod, which works on parameter-efficient fine-tunes in addition to full-parameter fine-tunes.}
    \label{peft-results-app}
    \scriptsize
    \resizebox{0.98\textwidth}{!}{
    \begin{tabular}{@{}lccccccccccc@{}}
        \toprule
        Model/Method & ARC & BBH & HellaSwag & TruthfulQA & LAMBADA & WinoGrande & GSM8K & \textbf{Average $\uparrow$} & MT-Bench \\

        \midrule
        \textit{Llama 2-7B} & 52.56 & 33.76 & 78.96 & 38.96 & 68.39 & 68.98 & 13.57 & 50.74 & -- \\


        \textit{Llama 2-7B UltraChat} & 54.52 & 34.14 & 78.99 & 46.84 & 70.83 & 69.53 & 14.71 & 52.79 & 4.93 \\

        BitDelta & 54.61 & 34.28 & 79.10 & 46.60 & 70.58 & 69.30 & 15.16 & 52.80 & 4.87 \\

        \bottomrule

    \end{tabular}
    }
\end{table}





        





\begin{table*}[htbp]
    \centering
    \caption{Full results of the application of \oursmethod to quantized base models, corresponding to Table \ref{quant-results}.}
    \label{quant-results-app}
    \scriptsize

    \resizebox{0.98\textwidth}{!}{
    \begin{tabular}{@{}llcccccccccc@{}}
        \toprule
        Base Model & Method & ARC & BBH & HellaSwag & TruthfulQA & LAMBADA & WinoGrande & GSM8K & \textbf{Average $\uparrow$} & MT-Bench \\
        \midrule
        \multirow{3}{*}{Baseline} & FP16 & 53.58 & 33.84 & 78.58 & 45.32 & 66.58 & 66.46 & 22.74 & 52.44 & 6.56 \\
        & \texttt{LLM.int8()} & 53.24 & 33.71 & 78.62 & 45.02 & 66.5 & 66.06 & 22.29 & 52.21 & 6.28 \\
        & GPTQ & 51.88 & 33.54 & 77.17 & 44.92 & 65.32 & 65.43 & 19.48 & 51.11 & 5.90 \\
        
        \midrule
        \multirow{3}{*}{\textit{Llama 2-7B}} & FP16 + $\Delta$ & 54.44 & 33.85 & 78.31 & 44.95 & 66.66 & 66.14 & 20.24 & 52.08 & 6.47 \\
        & \texttt{LLM.int8()} + $\Delta$ & 53.67 & 33.48 & 78.57 & 44.71 & 66.7 & 66.85 & 19.86 & 51.98 & 6.16 \\
        & GPTQ + $\Delta$ & 51.45 & 33.90 & 78.06 & 42.52 & 66.85 & 65.82 & 19.94 & 51.22 & 6.02 \\

        \midrule
        \textit{Llama 2-7B Chat} & GPTQ + $\Delta$ & 52.56 & 33.65 & 77.54 & 44.63 & 65.81 & 66.30 & 22.14 & 51.80 & 6.11 \\

        \bottomrule

    \end{tabular}
    }
\end{table*}

\begin{table*}[htbp]
    \centering
    \caption{Full results of the ablation over the fidelity of $\Delta$, corresponding to Figure \ref{fig:nbit}.}
    \label{nbit-results-app}
    \resizebox{0.98\textwidth}{!}{
    \begin{tabular}{@{}lcccccccc@{}}
        \toprule
        \# bits in $\Delta$ & ARC & BBH & HellaSwag & TruthfulQA & LAMBADA & WinoGrande & GSM8K & \textbf{Average $\uparrow$} \\
        
        \midrule
        \textit{Llama 2-7b} & 52.56 & 33.76 & 78.96 & 38.96 & 68.39 & 68.98 & 13.57 & 50.74 \\
        \midrule
        1 bit & 54.27 & 36.57 & 77.90 & 49.97 & 65.20 & 69.46 & 20.17 & 53.36 \\
        2 bits & 54.44 & 36.78 & 77.71 & 49.69 & 65.26 & 69.22 & 20.62 & 53.39 \\
        3 bits & 54.27 & 36.94 & 77.58 & 49.90 & 65.11 & 70.09 & 19.48 & 53.34 \\
        4 bits & 54.18 & 36.94 & 77.54 & 49.80 & 64.95 & 69.53 & 19.18 & 53.16  \\
        5 bits & 53.67 & 36.78 & 77.63 & 50.15 & 65.22 & 69.69 & 18.57 & 53.10 \\
        6 bits & 53.67 & 36.85 & 77.64 & 50.20 & 65.07 & 69.69 & 18.80 & 53.13 \\
        7 bits & 53.74 & 37.01 & 77.56 & 50.29 & 65.15 & 69.38 & 18.50 & 53.09 \\
        8 bits & 53.84 & 36.94 & 77.51 & 50.15 & 64.95 & 70.17 & 18.80 & 53.19 \\
        \midrule
        \textit{Vicuna-7b v1.5} & 53.92 & 37.14 & 77.45 & 50.36 & 64.41 & 69.61 & 19.03 & 53.13 \\
        \bottomrule
    \end{tabular}
    }
\end{table*}



\begin{table}[htbp]
    \centering
    \caption{Full results of \oursmethod applied to fine-tuned models in the Llama-2 and Mistral families, corresponding to Table \ref{main-results}.}
    \label{main-results-app}
    \scriptsize
    \resizebox{0.98\textwidth}{!}{
    \begin{tabular}{@{}llccccccccc@{}}
        \toprule
         Model & Method & ARC & BBH & HellaSwag & TruthfulQA & LAMBADA & WinoGrande & GSM8K & \textbf{Average $\uparrow$} & MT-Bench $\uparrow$ \\

        \midrule
        \textit{Llama 2-7B} & -- & 52.56 & 33.76 & 78.96 & 38.96 & 68.39 & 68.98 & 13.57 & 50.74 & -- \\

        \midrule
        \multirow{3}{*}{\textit{Llama 2-7B Chat}} & Baseline & 53.58 & 33.84 & 78.58 & 45.32 & 66.58 & 66.46 & 22.74 & 52.44 & 6.56 \\
        & BitDelta-Initial & 55.46 & 35.56 & 76.32 & 41.10 & 68.14 & 68.03 & 18.27 & 51.84 & 6.31\\
        & BitDelta & 54.44 & 33.85 & 78.31 & 44.95 & 66.66 & 66.14 & 20.24 & 52.08 & 6.47\\

        \midrule
        \multirow{3}{*}{\textit{Vicuna-7B v1.5}} & Baseline & 53.92 & 37.14 & 77.45 & 50.36 & 64.41 & 69.61 & 19.03 & 53.13 & 6.04 \\
        & BitDelta-Initial & 54.69 & 36.74 & 78.47 & 47.63 & 66.31 & 68.75 & 19.56 & 53.16 & 5.67 \\
        & BitDelta & 54.27 & 36.57 & 77.9 & 49.97 & 65.2 & 69.46 & 20.17 & 53.36 & 5.99 \\

        \midrule
        \multirow{3}{*}{\textit{Vicuna-7B v1.5 16k}} & Baseline & 54.86 & 35.63 & 77.06 & 50.38 & 52.32 & 67.64 & 14.18 & 50.30 & 6.06\\
        & BitDelta-Initial & 55.55 & 33.24 & 77.99 & 45.58 & 56.8 & 68.98 & 13.95 & 50.30 & 5.69\\
        & BitDelta & 54.61 & 34.68 & 77.14 & 48.75 & 53.89 & 67.88 & 14.48 & 50.20 & 6.24\\

        \midrule
        \multirow{3}{*}{\textit{Xwin LM-7B v0.1}} & Baseline & 57.59 & 34.05 & 79.15 & 48.06 & 68.02 & 69.22 & 10.77 & 52.41 & 6.24 \\
        & BitDelta-Initial & 56.40 & 33.90 & 80.26 & 44.56 & 69.86 & 69.14 & 16.68 & 52.97 & 5.79 \\
        & BitDelta & 57.94 & 34.19 & 79.36 & 47.62 & 68.29 & 69.53 & 9.02 & 52.28 & 6.50 \\

        \midrule
        \textit{Llama 2-13B} & -- & 59.47 & 39.03 & 82.23 &  36.90  & 70.44 &  72.22 & 22.74 & 54.72 & -- \\
        
        \midrule
        \multirow{3}{*}{\textit{Llama 2-13B Chat}} & Baseline & 60.32 & 37.89 & 82.15 & 43.95 & 68.62 & 70.96 & 33.13 & 56.72 & 6.98 \\
        & BitDelta-Initial & 59.90 & 38.04 & 82.13 & 41.70 & 69.82 & 71.35 & 33.36 & 56.61 & 7.06 \\
        & BitDelta & 59.98 & 38.03 & 81.92 & 43.47 & 68.46   & 71.43 & 31.92 & 56.46 & 6.95 \\

        \midrule
        \multirow{3}{*}{\textit{Vicuna-13B v1.5}} & Baseline & 57.34 & 39.47 & 81.14 & 50.86 & 68.48 & 71.67 & 29.72 & 56.95 & 6.48 \\
        & BitDelta-Initial & 54.69 & 36.74 & 78.47 & 47.63 & 66.31 & 68.75 & 31.84 & 54.92 & 6.51 \\
        & BitDelta & 57.42 & 39.20 & 81.33 & 50.39 & 68.81 & 71.51 & 30.48 & 57.02 & 6.81 \\

        \midrule
        \multirow{3}{*}{\textit{Vicuna-13B v1.5 16k}} & Baseline & 54.86 & 35.63 & 77.06 & 50.38 & 52.32 & 67.64 & 29.72 & 52.52 & 6.90 \\
        & BitDelta-Initial & 59.90 & 38.04 & 82.13 & 41.70 & 69.82 & 71.35 & 26.76 & 55.67 & 6.60 \\
        & BitDelta & 54.61 & 34.68 & 77.14 & 48.75 & 53.89 & 67.88 & 28.73 & 52.24 & 6.88 \\

        \midrule
        \multirow{3}{*}{\textit{WizardLM-13B v1.2}} & Baseline & 60.15 & 40.82 & 82.58 & 47.17 & 69.26 & 71.90 &  42.38 & 59.18 & 6.95 \\
        & BitDelta-Initial & 60.41 & 40.27 & 83.26 & 44.89 & 70.23 & 71.74 & 42.08 & 58.98 & 6.73 \\
        & BitDelta & 60.92  & 41.30 & 82.55 & 46.67 & 68.97 & 71.51 & 41.62 & 59.08 & 6.93 \\

        \midrule
        \multirow{3}{*}{\textit{Xwin LM-13B v0.1}} & Baseline & 63.14 & 40.12 & 82.92 & 45.54 & 70.62 & 73.09 & 21.15 & 56.65 & 6.78 \\
        & BitDelta-Initial & 63.4 & 40.33 & 83.71 & 43.6 & 71.26 & 73.09 & 26.76 & 57.45 & 6.70 \\
        & BitDelta & 62.80 & 39.81 & 83.01 & 48.19 & 70.74 & 72.30 & 21.76 & 56.94 & 6.83 \\

        \midrule
        \textit{Llama 2-70B} & -- & 67.58 & 51.67 & 87.00 & 44.82 & 74.81 & 77.98 & 52.69 & 65.22 & -- \\
        
        \midrule
        \multirow{3}{*}{\textit{Llama 2-70B Chat}} & Baseline & 65.44 & 43.93 & 85.91 & 52.77 & 73.90 & 74.90 & 47.61 & 63.49 & 7.12 \\
        & BitDelta-Initial & 63.4 & 38.67 & 81.36 & 41.63 & 72.66 & 73.95 & 42.38 & 59.15 & 6.85 \\
        & BitDelta & 65.87 & 44.97   & 85.65 & 51.37  & 74.29 & 74.90 & 48.82 & 63.70 & 7.06 \\

        \midrule
        \multirow{3}{*}{\textit{Solar-0-70B}} & Baseline & 71.16 & 55.54 & 87.78 & 62.03 & 75.04 & 79.32 & 56.18 & 69.58 & 7.07 \\
        & BitDelta-Initial & 69.54 & 54.52 & 87.57 & 59.08 & 75.37 & 78.69 & 56.79 & 68.79 & 6.79 \\
        & BitDelta & 70.82 & 55.06 & 87.35 & 62.03 & 75.86 & 78.77 & 56.63 & 69.50 & 6.82 \\

        \midrule
        \multirow{3}{*}{\textit{Xwin LM-70B v0.1}} & Baseline & 70.65 & 52.40 & 87.15 & 60.06 & 75.04 & 78.06 & 40.33 & 66.24 & 7.45 \\
        & BitDelta-Initial & 69.97 & 52.93 & 87.36 & 60.77 & 75.51 & 78.14 & 50.64 & 67.90 & 7.70 \\
        & BitDelta & 70.22 & 52.22 & 86.97 & 58.57 & 75.49 & 77.58 & 40.18 & 65.89 & 7.34 \\

        \midrule
        \textit{Mistral-7B v0.1} & -- & 61.35 & 41.18 & 83.46 & 42.60 & 70.10 & 73.80 & 37.76 & 58.61 & -- \\
        
        \midrule
        \multirow{3}{*}{\textit{Mistral-7B v0.1 Instruct}} & Baseline & 55.03 & 38.66 & 75.52 & 55.93 & 63.28 & 69.30 & 32.75 & 55.78 & 6.86 \\
        & BitDelta-Initial & 59.22 & 40.25 & 79.91 & 51.27 & 67.63 & 72.14 & 38.82 & 58.46 & 6.54 \\
        & BitDelta & 55.38 & 37.95 & 75.62 & 55.23 & 66.06 & 70.48 & 31.54 & 56.04 & 6.43 \\

        \midrule
        \multirow{3}{*}{\textit{Zephyr-7B}-$\beta$} & Baseline & 63.82 & 39.04 & 84.33 & 55.12 & 66.23 & 72.69 & 34.34 & 59.37 & 7.18 \\
        & BitDelta-Initial & 63.57 & 41.87 & 83.85 & 54.53 & 67.73 & 73.56 & 40.26 & 60.77 & 6.70 \\
        & BitDelta & 65.02 & 41.64 & 84.05 & 58.39 & 66.33 & 73.95 & 31.92 & 60.19 & 7.00 \\

        \midrule
        \multirow{3}{*}{\textit{OpenChat 3.5}} & Baseline & 64.51 & 45.28 & 84.39 & 47.34 & 65.19 & 72.61 & 68.84 & 64.02 & 7.74 \\
        & BitDelta-Initial & 64.16 & 45.23 & 84.13 & 43.34 & 68.62 & 77.43 & 57.77 & 62.95 & 5.71 \\
        & BitDelta & 64.93 & 44.57 & 84.44 & 46.24 & 65.88 & 76.40 & 57.70 & 62.88 & 7.38 \\

        \midrule
        \multirow{3}{*}{\textit{Dolphin 2.2.1}} & Baseline & 64.16 & 44.49 & 83.30 & 54.02 & 69.36 & 75.22 & 54.28 & 63.55 & 7.36 \\
        & BitDelta-Initial & 64.16 & 44.43 & 84.01 & 48.14 & 69.98 & 75.30 & 50.27 & 62.33 & 7.10 \\
        & BitDelta & 64.59 & 43.08 & 83.44 & 54.91 & 68.39 & 75.37 & 52.84 & 63.23 & 7.20 \\

        \midrule
        \multirow{3}{*}{\textit{OpenOrca-7B}} & Baseline & 62.80 & 44.45 & 83.58 & 52.30 & 66.10 & 73.24 & 50.11 & 61.80 & 6.70 \\
        & BitDelta-Initial & 63.74 & 44.46 & 84.15 & 49.66 & 69.05 & 74.03 & 49.96 & 62.15 & 7.12 \\
        & BitDelta & 63.65 & 43.46 & 83.49 & 51.67 & 66.12 & 74.27 & 49.58 & 61.75 & 7.05 \\
        
        \bottomrule
        
    \end{tabular}
    }
\end{table}


\end{document}
