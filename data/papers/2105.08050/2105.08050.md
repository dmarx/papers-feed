---
abstract: |
  Transformers  have become one of the most important architectural innovations in deep learning and have enabled many breakthroughs over the past few years. Here we propose a simple network architecture, gMLP, based on MLPs with gating, and show that it can perform as well as Transformers in key language and vision applications. Our comparisons show that self-attention is not critical for Vision Transformers, as gMLP can achieve the same accuracy. For BERT, our model achieves parity with Transformers on pretraining perplexity and is better on some downstream NLP tasks. On finetuning tasks where gMLP performs worse, making the gMLP model substantially larger can close the gap with Transformers. In general, our experiments show that gMLP can scale as well as Transformers over increased data and compute.
author:
- |
  Hanxiao Liu, Zihang Dai, David R. So, Quoc V. Le  
  Google Research, Brain Team  
  `{hanxiaol,zihangd,davidso,qvl}@google.com`
bibliography:
- main.bib
citation-style: ieee
header-includes:
- 
- 
link-citations: true
reference-section-title: References
title: Pay Attention to MLPs
---





# Introduction

Transformers  have enabled many breakthroughs in natural language processing (e.g., ) and have been shown to work well for computer vision (e.g., ). Thanks to this success, Transformers have largely replaced LSTM-RNN  as the default architecture in NLP, and have become an appealing alternative to ConvNets  in computer vision.

The Transformer architecture combines two important concepts: (1) a recurrent-free architecture which computes the representations for each individual token in parallel, and (2) multi-head self-attention blocks which aggregate spatial information across tokens. On one hand, the attention mechanism  introduces the inductive bias that the spatial interactions should be dynamically parameterized based on the input representations. On the other hand, it is known that MLPs with static parameterization can represent arbitrary functions . It therefore remains an open question whether the inductive bias in self-attention is essential to the remarkable effectiveness of Transformers.

Here we study the necessity of self-attention modules in key language and vision applications of Transformers. Specifically, we propose an MLP-based alternative to Transformers without self-attention, which simply consists of channel projections and spatial projections with static parameterization. We experiment with several design choices for this architecture and find spatial projections work well when they are linear and paired with multiplicative gating (Figure ). We name the model **gMLP** because it is built out of basic MLP layers with gating.

We apply gMLP to image classification and obtain strong results on ImageNet. gMLP achieves comparable performance with DeiT , namely Vision Transformer (ViT)  with improved regularization, in a similar training setup. With 66% less parameters, a gMLP model is 3% more accurate than MLP-Mixer . Together with Tolstikhin et al. , Melas-Kyriazi , Touvron et al.  and Ding et. al. , our results question the necessity of self-attention layers in Vision Transformers.

We apply gMLP to masked language modeling (MLM) in the BERT  setup, one of the most well-established applications of Transformers, and find that it is as good as Transformers at minimizing perplexity during pretraining. Our experiments indicate that perplexity is only correlated with model capacity and is insensitive to the presence of self-attention. As capacity increases, we observe that both pretraining and finetuning metrics for gMLPs improve as quickly as for Transformers. This is remarkable because it indicates gMLPs scale just as well as Transformers despite the absence of self-attention, and any performance gap can always be offset by training a larger model with increased data and compute. With a standard 256-batch size $\times$ 1M-step training setup as in original BERT, a large gMLP model achieves 87.7% accuracy on MNLI and 82.1% F1 on SQuAD v2.0. Note, these are better than the BERT<sub>large</sub> results reported in Devlin et al.  obtained using Transformers.

For BERT’s finetuning, Transformers can be more practically advantageous over gMLPs on tasks that require cross-sentence alignment (e.g., by 0.8% on MNLI-m in the 300M-param regime), even with similar pretraining perplexity. This problem can be addressed by making gMLPs substantially larger—3$\times$ as large as Transformers. A more practical solution is to blend in only a tiny bit of self-attention—a single-head self-attention with size up to 128 is sufficient to make gMLPs outperform Transformers on all NLP tasks we evaluated with even better parameter efficiency. The improvement is sometimes very significant (e.g., +4.4% on SQuAD v2.0 over BERT<sub>large</sub>).

Overall, the surprising effectiveness of gMLPs in both vision and NLP domains suggest that self-attention is not a necessary ingredient for scaling up machine learning models, although it can be a useful addition depending on the task. With increased data and compute, models with simpler spatial interaction mechanisms such as gMLP can be as powerful as Transformers and the capacity allocated to self-attention can be either removed or substantially reduced.

<figure id="fig:architecture">
<span class="image placeholder" data-original-image-src="figures/gmlp-overview.pdf" data-original-image-title="" width="0.95\linewidth"></span>
<pre><code>[
  language=python,
  title={Pseudo-code for the \gffn block}, captionpos=t]
def gmlp_block(x, d_model, d_ffn):
  shortcut = x
  x = norm(x, axis=&quot;channel&quot;)
  x = proj(x, d_ffn, axis=&quot;channel&quot;)
  x = gelu(x)
  x = spatial_gating_unit(x)
  x = proj(x, d_model, axis=&quot;channel&quot;)
  return x + shortcut
  
 def spatial_gating_unit(x):
   u, v = split(x, axis=&quot;channel&quot;)
   v = norm(v, axis=&quot;channel&quot;)
   n = get_dim(v, axis=&quot;spatial&quot;)
   v = proj(v, n, axis=&quot;spatial&quot;, init_bias=1)
   return u * v</code></pre>
<figcaption>Overview of the gMLP architecture with Spatial Gating Unit (SGU). The model consists of a stack of <span class="math inline">\(L\)</span> blocks with identical structure and size. All projection operations are linear and “<span class="math inline">\(\odot\)</span>” refers to element-wise multiplication (linear gating). The input and output protocols follow BERT for NLP and ViT for vision. Unlike Transformers, gMLP<span>s</span> do not require positional encodings, nor is it necessary to mask out the paddings during NLP finetuning.</figcaption>
</figure>

# Model

Our model, gMLP, consists of a stack of $L$ blocks with identical size and structure. Let $X \in \mathbb{R}^{n \times d}$ be the token representations with sequence length $n$ and dimension $d$. Each block is defined as: $$\begin{aligned}
Z = \sigma(XU), \qquad
\tilde{Z} &= s(Z), \qquad
Y = \tilde{Z}V
\end{aligned}$$ where $\sigma$ is an activation function such as GeLU . $U$ and $V$ define linear projections along the channel dimension—the same as those in the FFNs of Transformers (e.g., their shapes are 768$\times$ 3072 and 3072$\times$ 768 for BERT<sub>base</sub>). Shortcuts, normalizations and biases are omitted for brevity.

A key ingredient in the aforementioned formulation is $s(\cdot)$, a layer which captures spatial interactions (see below). When $s$ is an identity mapping, the above transformation degenerates to a regular FFN, where individual tokens are processed independently without any cross-token communication. One of our major focuses is therefore to design a good $s$ capable of capturing complex spatial interactions across tokens. The overall block layout is inspired by inverted bottlenecks  which define $s(\cdot)$ as a spatial depthwise convolution. Note, unlike Transformers, our model *does not require position embeddings* because such information will be captured in $s(\cdot)$.

Our model uses exactly the same input and output protocols as BERT (for NLP) and ViT (for vision). For example, when finetuning on language tasks, we concatenate together multiple text segments followed by paddings, and the predictions are deduced from the last-layer representation of a reserved `<cls>` symbol. Although many of these protocols were introduced for Transformers and hence can be suboptimal for gMLPs, strictly following them helps avoid confounding factors in our experiments and makes our layers more compatible with existing Transformer implementations.

## Spatial Gating Unit

To enable cross-token interactions, it is necessary for the layer $s(\cdot)$ to contain a contraction operation over the spatial dimension. The simplistic option would be a linear projection: $$f_{W, b}(Z) = WZ + b \label{eq:spatial-proj}$$ where $W \in \mathbb{R}^{n \times n}$ is a matrix for which the size is the same as the sequence length, $n$, and $b$ refers token-specific biases. For example, if the padded input sequence has 128 tokens, the shape for $W$ will be 128$\times$<!-- -->128. Unlike self-attention where $W(Z)$ is dynamically generated from $Z$, the spatial projection matrix $W$ here in Equation  is independent from the input representations.

In this work, we formulate layer $s(\cdot)$ as the output of linear gating: $$\begin{aligned}
    s(Z) = Z \odot f_{W, b}(Z) \label{eq:spatial-gating}
\end{aligned}$$ where $\odot$ denotes element-wise multiplication. For training stability, we find it critical to initialize $W$ as near-zero values and $b$ as ones, meaning that $f_{W, b}(Z) \approx \mathbf{1}$ and therefore $s(Z) \approx Z$ at the beginning of training. This initialization ensures each gMLP block behaves like a regular FFN at the early stage of training, where each token is processed independently, and only gradually injects spatial information across tokens during the course of learning.

We further find it effective to split $Z$ into two independent parts ($Z_1$, $Z_2$) along the channel dimension for the gating function and for the multiplicative bypass: $$\begin{aligned}
    s(Z) = Z_1 \odot f_{W, b}(Z_2)  \label{eq:spatial-gating-independent}
\end{aligned}$$ We also normalize the input to $f_{W, b}$ which empirically improves stability of large NLP models. This gives us the unit illustrated in Figure , which we refer to as the *Spatial Gating Unit* (SGU) in the rest of the paper. In Table , we provide ablation studies to compare SGU with several other variants of $s(\cdot)$, showing that it works better and narrows the performance gap with self-attention.

#### Connections to Existing Layers.

The overall formulation of SGU resembles Gated Linear Units (GLUs)  as well as earlier works including Highway Networks  and LSTM-RNNs . A key distinction is that our gating is computed based on a projection over the spatial (cross-token) dimension rather than the channel (hidden) dimension. SGU is also related to Squeeze-and-Excite (SE) blocks  in terms of element-wise multiplication. However, different from SE blocks, SGU does not contain cross-channel projections at all, nor does it enforce permutation invariance (a key feature for content-based attentive modules) due to its static parameterization for the spatial transformation. The spatial projection in SGU could in theory learn to express superficial depthwise convolutions—unlike typical depthwise convolutions with channel-specific filters, SGU learns only a single transformation shared across channels. Finally, we note SGUs offer an alternative mechanism to capture high-order relationships other than self-attention. Specifically, the output for Equation  contains up to 2nd-order interactions (e.g., $z_iz_j$) whereas output for self-attention (assuming no nonlinearity) contains up to 3rd-order interactions (e.g., $q_ik_jv_k$). In terms of computation cost, SGU has $n^2 e / 2$ multiply-adds which is comparable to the $2n^2 d$ of dot-product self-attention.[^1] Both are linear over the input channel size and quadratic over the sequence length $n$.

# Image Classification

Here we examine gMLP in the vision domain by applying it to the image classification task on ImageNet  without using extra data. We compare our MLP-like models with recent attentive models based on vanilla Transformers, including Vision Transformer (ViT) , DeiT  (ViT with improved regularization), and several other representative convolutional networks.

Table  summarizes the configurations of our gMLP image classification models. The input and output protocols follow ViT/B16 where the raw image is converted into 16$\times$<!-- -->16 patches at the stem. The depth and width are chosen so that the models are comparable with ViT/DeiT in capacity. Like Transformers, we find gMLPs tend to drastically overfit the training data. We therefore apply a similar regularization recipe as the one used in DeiT.[^2] To avoid extensive tuning, we adjust only the strengths of stochastic depth  as we move from smaller to larger models in Table . All the other hyperparameters remain shared across our three models. See Appendix  for details.

|         | \#L | $d_\mathrm{model}$ | $d_\mathrm{ffn}$ | Params (M) | FLOPs (B) | Survival Prob |
|:--------|:---:|:------------------:|:----------------:|:----------:|:---------:|:-------------:|
| gMLP-Ti | 30  |        128         |       768        |    5.9     |    2.7    |     1.00      |
| gMLP-S  | 30  |        256         |       1536       |    19.5    |    8.9    |     0.95      |
| gMLP-B  | 30  |        512         |       3072       |    73.4    |   31.6    |     0.80      |

Architecture specifications of gMLP models for vision. The survival probability of stochastic depth is the only hyperparameter change as we move from smaller to larger models.

Our ImageNet results are summarized in Table  and Figure . It is interesting to see that gMLPs are comparable with DeiT , namely ViT  trained using improved regularization. The results suggest that models without self-attention can be as data-efficient as Transformers for image classification. In fact, when the models are properly regularized, their accuracies seem better correlated with capacity instead of the presence of self-attention. Moreover, the accuracy-parameter/FLOPs tradeoff of gMLPs surpasses all concurrently proposed MLP-like architectures , which we attribute to the effectiveness of our Spatial Gating Unit (see Table  in the next section for an ablation). We also note while gMLPs are competitive with vanilla Transformers, their performance is behind the best existing ConvNet models (e.g., ) or hybrid models (e.g., ).

<figure id="fig:vision-filters">
<span class="image placeholder" data-original-image-src="figures/gffn-imagenet.pdf" data-original-image-title="" width="0.94\linewidth"></span>
<span class="image placeholder" data-original-image-src="figures/vision-learned-filters.png" data-original-image-title="" width="1.0\linewidth"></span>
<figcaption> Spatial projection weights in gMLP-B. Each row shows the filters (reshaped into 2D) for a selected set of tokens in the same layer.</figcaption>
</figure>

Figure  visualizes the spatial projection matrices in gMLP-B. Remarkably, the spatial weights after learning exhibit both locality and spatial invariance. In other words, each spatial projection matrix effectively learns to perform convolution with a data-driven, irregular (non-square) kernel shape.

# Masked Language Modeling with BERT

Here we conduct empirical studies over the masked language modeling (MLM) task. The input/output protocol for both pretraining and finetuning follows BERT . Different from Transformer-based models, we do not use positional encodings. We also find it unnecessary to mask out `<pad>` tokens in gMLP blocks during finetuning as the model can quickly learn to ignore them. For ablations and case studies, all models are trained with batch size 2048, max length 128 for 125K steps over the RealNews-like subset of C4 . For main results, models are trained with batch size 256, max length 512 for 1M steps over the full English C4 dataset. See Appendix  for details.

Our preliminary MLM experiments show that gMLPs always learn Toeplitz-like matrices as the spatial weights (Appendix ). This means gMLPs are able to learn the notion of shift invariance from data, a property naturally implied by the MLM task where any offset of the input sequence does not affect the slot filling outcome. In this case, the learned $f_{W,b}(\cdot)$ acts like a 1-d convolution whose kernel size equals the entire sequence length (unlike depthwise convolution with channel-specific filters, here the same $W$ is shared across channels). In the following MLM experiments, we restrict $W$ to be a Toeplitz matrix to avoid redundant model parameterization (since $W$ will be Toeplitz-like regardless after learning). Note this constraint is empirically quality-neutral.

## Ablation: The Importance of Gating in gMLP for BERT’s Pretraining

In Table  below, we establish baselines for our ablation studies. These include:

1.  BERT with a Transformer architecture and learnable absolute position embeddings.

2.  BERT with a Transformer architecture and T5-style learnable relative position biases . The biases are both layer- and head-specific as we find this yields the best results.

3.  Same as above, but we remove all content-dependent terms inside the softmax and only retain the relative positional biases. This baseline is a straightforward variant of Transformers without self-attention, which can also be viewed as a Random Synthesizer .

4.  MLP-Mixer  which replaces the multi-head self-attention module in Transformers with a two-layer spatial MLP. This model was developed for image classification and here we investigate it on MLM tasks using the same training setup with BERT and gMLP.

We compare these baselines against several versions of gMLPs with similar sizes in Table . Note that Multiplicative, Split (last row) is the Spatial Gating Unit we describe in the method section and use in the rest of the paper. First, SGU outperforms other variants in perplexity. Secondly and remarkably, gMLP with SGU also achieves perplexity comparable to Transformer. Note the difference between the strongest baseline (perplexity=4.26) and ours (perplexity=4.35) is insignificant relative to the perplexity change when the models are scaled (see Table  in the next section). Spatial projection weights learned by gMLPs are visualized in Figure .

<figure id="fig:mlm-filters">
<span class="image placeholder" data-original-image-src="figures/mlm-filters.png" data-original-image-title="" width="0.7\linewidth"></span>
<figcaption>Visualization of the spatial filters in gMLP learned on the MLM task. For each layer in the model we plot the row in <span class="math inline">\(W\)</span> associated with the token in the middle of the sequence. The x-axis of each subplot has a length of 128 which equal the number of tokens in the sequence. The learned filters appear to be smooth and have several types: forward-looking (e.g., 1st in 2nd row), backward-looking (e.g., 5th in 2nd row) and bi-directional (e.g., 2nd last in the last row).</figcaption>
</figure>

## Case Study: The Behavior of gMLP as Model Size Increases

In Table , we investigate the scaling properties of Transformers and gMLPs in BERT as their model capacity grows. Specifically, we scale the depth of these models by a factor of $\{0.5, 1, 2, 4\}\times$ and report the their pretraining MLM perplexities on the validation set as well as finetuning results on the dev sets of two tasks in GLUE . Note each individual Transformer layer is effectively two consecutive blocks: one for self-attention and one for FFN. In the table below we use the notation of 12 + 12 to refer to 12 of self-attention blocks plus 12 of FFN blocks in the Transformer baselines.

| Model       |  \#L  | Params (M) | Perplexity | SST-2 | MNLI-m |
|:------------|:-----:|:----------:|:----------:|:-----:|:------:|
| Transformer |  6+6  |     67     |  **4.91**  | 90.4  |  81.5  |
| gMLP        |  18   |     59     |    5.25    | 91.2  |  77.7  |
| Transformer | 12+12 |    110     |  **4.26**  | 91.3  |  83.3  |
| gMLP        |  36   |    102     |    4.35    | 92.3  |  80.9  |
| Transformer | 24+24 |    195     |    3.83    | 92.1  |  85.2  |
| gMLP        |  72   |    187     |  **3.79**  | 93.5  |  82.8  |
| Transformer | 48+48 |    365     |    3.47    | 92.8  |  86.3  |
| gMLP        |  144  |    357     |  **3.43**  | 95.1  |  84.6  |

Pretraining and dev-set finetuning results over increased model capacity. We use the relative positional encoding scheme for Transformers which performs the best in Table .

The results above show that a deep enough gMLP is able to match and even outperform the perplexity of Transformers with comparable capacity.[^3] In addition, the perplexity-parameter relationships for both architecture families approximately follow a power law (left of Figure ). This implies the empirical scaling laws originally observed for Transformer-based language models  might be broadly applicable across different model families.

<figure id="fig:scaling">
<span class="image placeholder" data-original-image-src="figures/scaling.pdf" data-original-image-title="" width="0.9\linewidth"></span>
<figcaption>Scaling properties with respect to perplexity and finetuning accuracies. The figures show that for pretraining, gMLP<span>s</span> are equally good at optimizing perplexity as Transformers. For finetuning, the two model families exhibit comparable scalability despite task-specific offsets.</figcaption>
</figure>

Table  also leads to an interesting observation that the pretraining perplexities across different model families are not equal in terms of finetuning. While gMLPs outperform Transformers on SST-2, they are worse on MNLI. The results imply that the finetuning performance for NLP tasks is a function of not only the perplexity but also the inductive bias in the architecture. Figure  shows that despite the architecture-specific discrepancies between pretraining and finetuning, gMLPs and Transformers exhibit comparable scalability (slope) on both finetuning tasks. This means one can always offset the gap by enlarging the model capacity. In other words, the results indicate that model scalability with respect to downstream metrics can be independent from the presence of self-attention.

## Ablation: The Usefulness of Tiny Attention in BERT’s Finetuning

So far we have found that self-attention is not a required component to achieve strong MLM perplexity or scalability. At the meantime, we also identified NLP finetuning tasks where gMLPs transfer less well than Transformers (Table ). The fact that our MLP-like model is advantageous on SST-2 but worse on MNLI is particularly informative—the former is a single-sentence task whereas the latter involves sentence pairs (premise and hypothesis) . We suspect the role of self-attention during finetuning is related to cross-sentence alignment.

To isolate the effect of self-attention, we experiment with a hybrid model where a tiny self-attention block is attached to the gating function of gMLP(Figure ). Since gMLP itself is already capable in capturing spatial relationships, we hypothesize that this extra self-attention module does not have to be heavy, and that its presence is more relevant than its capacity. A typical tiny attention module in our experiments has only a single head with size 64, significantly smaller than a typical multi-head self-attention in Transformers with 12 heads and a total size of 768. In the following, we refer to the hybrid model, namely gMLP with a tiny self-attention, as *aMLP* (“a” for attention).

<figure id="fig:tiny-attn">
<span class="image placeholder" data-original-image-src="figures/tiny-attention.pdf" data-original-image-title="" width="0.7\linewidth"></span>
<pre><code>[
  language=python,
  title={Pseudo-code for the tiny attention module}, captionpos=t]
def tiny_attn(x, d_out, d_attn=64):
  qkv = proj(x, 3 * d_attn, axis=&quot;channel&quot;)
  q, k, v = split(qkv, 3, axis=&quot;channel&quot;)
  w = einsum(&quot;bnd,bmd-&gt;bnm&quot;, q, k)
  a = softmax(w * rsqrt(d_attn))
  x = einsum(&quot;bnm,bmd-&gt;bnd&quot;, a, v)
  return proj(x, d_out, axis=&quot;channel&quot;)
</code></pre>
<figcaption>Hybrid spatial gating unit with a tiny self-attention module. We use the normalized input of the gMLP block (endpoint after the input normalization and right before the channel expansion) as the input to the tiny self-attention. For SGU we have <span class="math inline">\(d_\mathrm{out} = d_\mathrm{ffn} / 2\)</span> due to the channel split.</figcaption>
</figure>

In Figure , we investigate the transferability of MLM models via the calibration plots between their pretraining perplexities and finetuning metrics. Models evaluated include BERT<sub>base</sub>, gMLP and its hybrid version aMLP with a 64-d single-head self-attention (Figure ). The data points were collected by varying the model depth by {0.5, 1, 2}$\times$ or data by {1, 2, 4, 8}$\times$. It can be seen that gMLPs transfer better to SST-2 than Transformers regardless of the presence of self-attention, While gMLP performs worse on MNLI, attaching a tiny bit of self-attention is sufficient to close the gap. In Appendix  we visualize the tiny self-attention modules in aMLP over MNLI examples, showing that they are primarily responsible for the alignment between sentence pairs.

<figure id="fig:transferability">
<span class="image placeholder" data-original-image-src="figures/pplx-vs-sst.pdf" data-original-image-title="" width="0.9\linewidth"></span>
<span class="image placeholder" data-original-image-src="figures/pplx-vs-mnli.pdf" data-original-image-title="" width="0.9\linewidth"></span>
<figcaption>Transferability from MLM pretraining perpexity to finetuning accuracies on GLUE. aMLP refers to gMLP enhanced with a 64-d single-head self-attention, as illustrated in Figure <span class="math inline">\(\ref{fig:tiny-attn}\)</span>. In contrast, each self-attention module in the BERT baseline contains 12 heads with a total size of 768.</figcaption>
</figure>

In Figure  we put together the scaling properties of the three models, showing that aMLP (gMLP + tiny attention) consistently outperforms Transformer on both finetuning tasks.

<figure id="fig:scaling-with-tinyattn">
<span class="image placeholder" data-original-image-src="figures/scaling-with-tinyattn.pdf" data-original-image-title="" width="0.9\linewidth"></span>
<figcaption>Comparing the scaling properties of Transformers, gMLP<span>s</span> and aMLPs (with 64-d, single-head attention). Results were obtained using the same setup in Section <span class="math inline">\(\ref{sec:scaling}\)</span>.</figcaption>
</figure>

## Main Results for MLM in the BERT Setup

Below we present pretraining and finetuning results in the full BERT setup. Different from ablation and case studies, here we use the full English C4 dataset and adopt a common MLM setup with batch size 256, max length 512 and 1M training steps. For fair comparison, we adjust the depth and width of gMLPs to ensure comparable model capacity with the Transformer baselines. The model specifications are given in Table  and hyperparameters are detailed in Appendix . For finetuning, we report the dev-set performance for SST-2 and MNLI in GLUE  and each result entry was obtained by taking the median of five independent runs. In addition, we report finetuning results on SQuAD  to test the models’ ability in reasoning over a longer context.

<div id="tab:perplexity-full-bert">

|                       | Params (M) | FLOPs (B) |  \#L  | $d_\mathrm{model}$ | $d_\mathrm{ffn}$ |     |
|:----------------------|:----------:|:---------:|:-----:|:------------------:|:----------------:|:---:|
| BERT<sub>base</sub>   |    110     |   100.8   | 12+12 |        768         |       3072       |     |
| gMLP<sub>base</sub>   |    130     |   158.0   |  48   |        512         |       3072       |     |
| aMLP<sub>base</sub>   |    109     |   128.9   |  36   |        512         |       3072       |     |
| BERT<sub>large</sub>  |    336     |   341.2   | 24+24 |        1024        |       4096       |     |
| gMLP<sub>large</sub>  |    365     |   430.1   |  96   |        768         |       3072       |     |
| aMLP<sub>large</sub>  |    316     |   370.3   |  72   |        768         |       3072       |     |
| gMLP<sub>xlarge</sub> |    941     |  1091.3   |  144  |        1024        |       4096       |     |

Model specifications in the full BERT setup.

</div>

|                             | Perplexity | SST-2 |   MNLI    | SQuAD |      |       Attn Size       | Params |
|:----------------------------|:----------:|:-----:|:---------:|:-----:|:----:|:---------------------:|:------:|
| 5-6                         |            |       |  (m/mm)   | v1.1  | v2.0 |                       | \(M\)  |
| BERT<sub>base</sub>         |     –      | 92.7  |  84.4/-   | 88.5  | 76.3 | 768 (64 $\times$ 12)  |  110   |
| BERT<sub>base</sub> (ours)  |    4.17    | 93.8  | 85.6/85.7 | 90.2  | 78.6 | 768 (64 $\times$ 12)  |  110   |
| gMLP<sub>base</sub>         |    4.28    | 94.2  | 83.7/84.1 | 86.7  | 70.1 |           –           |  130   |
| aMLP<sub>base</sub>         |    3.95    | 93.4  | 85.9/85.8 | 90.7  | 80.9 |          64           |  109   |
| BERT<sub>large</sub>        |     –      | 93.7  |  86.6/-   | 90.9  | 81.8 | 1024 (64 $\times$ 16) |  336   |
| BERT<sub>large</sub> (ours) |    3.35    | 94.3  | 87.0/87.4 | 92.0  | 81.0 | 1024 (64 $\times$ 16) |  336   |
| gMLP<sub>large</sub>        |    3.32    | 94.8  | 86.2/86.5 | 89.5  | 78.3 |           –           |  365   |
| aMLP<sub>large</sub>        |    3.19    | 94.8  | 88.4/88.4 | 92.2  | 85.4 |          128          |  316   |
| gMLP<sub>xlarge</sub>       |    2.89    | 95.6  | 87.7/87.7 | 90.9  | 82.1 |           –           |  941   |

Pretraining perplexities and dev-set results for finetuning. “ours” indicates models trained using our setup. We report accuracies for SST-2 and MNLI, and F1 scores for SQuAD v1.1/2.0.

Results are presented in Table . Consistent with our findings earlier in Section  and Section , gMLPs are competitive with Transformers in terms of perplexity, especially in the larger scale setup. There are several observations related to the finetuning results:

First, on finetuning tasks where gMLPs underperform Transformers, the performance gap tends to narrow as the model capacity increases. For example, while gMLP performs worse by 8.5% on SQuAD-v2.0 in the base scale, the performance gap relative to the baseline decreases to 2.7% at the larger scale. Notably, our gMLP<sub>large</sub> achieves 89.5% F1 on SQuAD-v1.1 without any self-attention or dynamic spatial parameterization , which is well above the 88.5% reported for BERT<sub>base</sub> in Devlin et al.  and is only 1.4% away from the original result for BERT<sub>large</sub>. We also include one additional data point by scaling up gMLP even further. The resulting model, gMLP<sub>xlarge</sub>, outperforms BERT<sub>large</sub> on SQuAD-v2.0—a difficult task involving question-answer pairs—without any self-attention. While this is not a fair comparison due to different model sizes, it is an existence proof that MLP-like models can be competitive with Transformers on challenging NLP tasks.

Furthermore, we show that blending in a tiny single-head self-attention of size either 64 or 128 is sufficient to make gMLPs outperform Transformers of similar capacity, sometimes by a significant margin. For example, our hybrid model aMLP<sub>large</sub> achieves 4.4% higher F1 than Transformers on SQuAD-v2.0. The results suggest that the capacity in the multi-head self-attention of Transformers can be largely redundant, and that the majority of its functionalities can be captured by the spatial gating unit in gMLPs. The results also imply that the inductive biases in the spatial gating unit of gMLPs and the tiny attention are complementary to each other. While the benefits of architectural inductive bias may vanish over increased compute, tiny attention does improve the practical value of gMLPs in the regime that we investigate in this work.

# Conclusion

Since the seminal work of Vaswani et al. , Transformers have been widely adopted across NLP and computer vision. This adoption has enabled many impressive results especially in NLP. To date, it is still unclear what empowers such success: is it the feedforward nature of Transformers or is it the multi-head self-attention layers in Transformers?

Our work suggests a simpler alternative to the multi-head self-attention layers in Transformers. We show that gMLPs, a simple variant of MLPs with gating, can be competitive with Transformers in terms of BERT’s pretraining perplexity and ViT’s accuracy. gMLPs are also comparable with Transformers in terms of the scalability over increased data and compute. As for BERT finetuning, we find gMLPs can achieve appealing results on challenging tasks such as SQuAD without self-attention, and can significantly outperform Transformers in certain cases. We also find the inductive bias in Transformer’s multi-head self-attention useful on downstream tasks that require cross-sentence alignment. However in those cases, making gMLP substantially larger closes the gap with Transformers. More practically, blending a small single-head self-attention into gMLP allows for an even better architecture without the need for increasing model size.

# Acknowledgements

We thank Gabriel Bender, Neil Houlsby, Thang Luong, Niki Parmar, Hieu Pham, Noam Shazeer, Ilya Sutskever, Jakob Uszkoreit and Ashish Vaswani for their feedback to the paper.

# Hyperparameters

## Image Classification

All ImageNet models are trained using TPUv2 with 128 cores. Each run takes 1-4 hours to complete.

|                                   |   gMLP-Ti    | gMLP-S | gMLP-B | Mixer-B |
|:----------------------------------|:------------:|:------:|:------:|:-------:|
| Stochastic depth survival prob    |     1.00     |  0.95  |  0.80  |  0.95   |
| Data augmentation                 | AutoAugment  |        |        |         |
| Repeated Augmentation             |     off      |        |        |         |
| Input resolution                  |     224      |        |        |         |
| Epochs                            |     300      |        |        |         |
| Batch size                        |     4096     |        |        |         |
| Warmup steps                      |     10K      |        |        |         |
| Hidden dropout                    |      0       |        |        |         |
| GeLU dropout                      |      0       |        |        |         |
| Attention dropout (if applicable) |      0       |        |        |         |
| Classification dropout            |      0       |        |        |         |
| Random erasing prob               |      0       |        |        |         |
| EMA decay                         |      0       |        |        |         |
| Cutmix $\alpha$                   |     1.0      |        |        |         |
| Mixup $\alpha$                    |     0.8      |        |        |         |
| Cutmix-Mixup switch prob          |     0.5      |        |        |         |
| Label smoothing                   |     0.1      |        |        |         |
| Peak learning rate                |     1e-3     |        |        |         |
| Learning rate decay               |    cosine    |        |        |         |
| Optimizer                         |    AdamW     |        |        |         |
| Adam $\epsilon$                   |     1e-6     |        |        |         |
| Adam $(\beta_1, \beta_2)$         | (0.9, 0.999) |        |        |         |
| Weight decay                      |     0.05     |        |        |         |
| Gradient clipping                 |     1.0      |        |        |         |

Hyperparameters for Image classification on ImageNet-1K

## Masked Language Modeling

MLM models for ablation studies are trained using TPUv3 with 32 cores. Each run takes 1-2 days to complete. Models in the full BERT setup are trained using TPUv2 with 128 cores. Each run takes 1-5 days to complete depending on the model size. The vocabulary consists of 32K cased SentencePieces.

|                                   | Ablation Studies | Full Results (Table ) |
|:----------------------------------|:----------------:|:---------------------:|
| Data                              |   C4/RealNews    |      C4/English       |
| Max sequence length               |       128        |          512          |
| Batch size                        |       2048       |          256          |
| Peak learning rate                |       7e-4       |         1e-4          |
| Number of steps                   |       125K       |          1M           |
| Warmup steps                      |       10K        |                       |
| Hidden dropout                    |        0         |                       |
| GeLU dropout                      |        0         |                       |
| Attention dropout (if applicable) |        0         |                       |
| Learning rate decay               |      Linear      |                       |
| Optimizer                         |      AdamW       |                       |
| Adam $\epsilon$                   |       1e-6       |                       |
| Adam $(\beta_1, \beta_2)$         |   (0.9, 0.999)   |                       |
| Weight decay                      |       0.01       |                       |
| Gradient clipping                 |        0         |                       |

Hyperparameters for MLM pretraining on C4.

|                                   |       SST-2        | MNLI | SQuAD v1.1/v2.0 |
|:----------------------------------|:------------------:|:----:|:---------------:|
| Max sequence length               |        128         |      |       512       |
| Batch size                        |      {16, 32}      |      |       32        |
| Peak learning rate                | {1e-5, 2e-5, 3e-5} |      |      5e-5       |
| Number of steps/epochs            |      5 epochs      |      |       8K        |
| Warmup steps/portion              |        10%         |      |       1K        |
| Hidden dropout                    |        0.1         |      |                 |
| GeLU dropout                      |         0          |      |                 |
| Attention dropout (if applicable) |        0.1         |      |                 |
| Learning rate decay               |       Linear       |      |                 |
| Optimizer                         |       AdamW        |      |                 |
| Adam $\epsilon$                   |        1e-6        |      |                 |
| Adam $(\beta_1, \beta_2)$         |    (0.9, 0.999)    |      |                 |
| Weight decay                      |        0.01        |      |                 |
| Gradient clipping                 |         0          |      |                 |

Hyperparameters for MLM finetuning on GLUE and SQuAD.

# Deep-and-Thin Transformers

| Perplexity |   \#L   | $d_\mathrm{model}$ | \#heads | Params (M) |
|:----------:|:-------:|:------------------:|:-------:|:----------:|
|    4.83    | 12 + 12 |        768         |   12    |    110     |
|    5.08    | 24 + 24 |        512         |    8    |     92     |
|    4.99    | 48 + 48 |        384         |   12    |     98     |
|    5.30    | 96 + 96 |        256         |    8    |     84     |

MLM results with increasingly deeper & thinner Transformers. As the depth increases, we adjust the model width accordingly to maintain comparable capacity. We observe that the perplexity is insensitive to the model depth at a fixed capacity, and worsens beyond 48 layers. Note these results were obtained using a similar yet different training setup from the rest of the paper.

# Shift Invariance in MLM

<figure id="fig:mlm-no-tplz">
<span class="image placeholder" data-original-image-src="figures/tplz.png" data-original-image-title="" width="0.9\linewidth"></span>
<figcaption>Spatial projection matrices learned on the MLM pretraining task without the shift invariance prior (that each individual <span class="math inline">\(W\)</span> being a Toeplitz matrix). The plots show that gMLP learns Toeplitz-like matrices (hence the notion of shift invariance) regardless.</figcaption>
</figure>

    [
      language=python,
      title={Creating a Toeplitz Matrix (used in MLM experiments)},
      captionpos=t]
    def create_toeplitz_matrix(n):
      w = tf.get_variable(
        "weight",
        shape=[2 * n - 1],
        initializer=WEIGHT_INITIALIZER)
      r = w.shape[0].value // 2
      t = tf.pad(w, [[0, n]])
      t = tf.tile(t, [n])
      t = t[:-n]
      t = tf.reshape(t, [n, n + w.shape[0] - 1])
      return t[:, r:-r]

# Visualizing Tiny Attention

Here we visualize the attention maps of the tiny attention modules in aMLP, after finetuning on MNLI-m. Each element in the heatmap below denotes the maximum attention weight of the corresponding token pair ever received during the first half of the network.

<figure>
<span class="image placeholder" data-original-image-src="figures/amlp-heatmap-1.pdf" data-original-image-title="" width="0.73\linewidth"></span>
</figure>

<figure>
<span class="image placeholder" data-original-image-src="figures/amlp-heatmap-2.pdf" data-original-image-title="" width="0.73\linewidth"></span>
<figcaption>Attention maps in aMLP over selected examples in MNLI-m.</figcaption>
</figure>

[^1]: The input channel size $e$ for SGU is typically larger than the input channel size $d$ for self-attention, because the former is applied in the middle of the block after a channel expansion.

[^2]: Unlike DeiT, we do not use repeated augmentation or random erasing.

[^3]: We also experimented with deeper-and-thinner Transformers (with capacity fixed) but found increasing depth further does not improve perplexity. See Appendix  for more details.
