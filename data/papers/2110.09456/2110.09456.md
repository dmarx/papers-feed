---
abstract: |
  During pretraining, the Pre-LayerNorm transformer suffers from a gradient magnitude mismatch: gradients at early layers are much larger than at later layers. These issues can be alleviated by our proposed NormFormer architecture, which adds three normalization operations to each layer: a Layer Norm after self attention, head-wise scaling of self-attention outputs, and a Layer Norm after the first fully connected layer. The extra operations incur negligible compute cost (+0.4% parameter increase), but improve pretraining perplexity and downstream task performance for both causal and masked language models ranging from 125 Million to 2.7 Billion parameters. For example, adding NormFormer on top of our strongest 1.3B parameter baseline can reach equal perplexity 24% faster, or converge 0.27 perplexity better in the same compute budget. This model reaches GPT3-Large (1.3B) zero shot performance 60% faster. For masked language modeling, NormFormer improves fine-tuned GLUE performance by 1.9% on average. Code to train NormFormer models is available in [fairseq](https://github.com/pytorch/fairseq/tree/main/examples/normformer).
author:
- |
  Sam ShleiferJason WestonMyle Ott  
  Facebook AI Research[^1]
bibliography:
- legend.bib
citation-style: ieee
header-includes:
- 
- 
link-citations: true
reference-section-title: References
title: "NormFormer: Improved Transformer Pretraining with Extra Normalization"
---





<div class="center">

</div>

# Introduction

The original transformer architecture  applies Layer Normalization  after each sublayer’s residual connection (“Post-LN") in order to reduce the variance of the inputs to the following sublayer, i.e.: $$\mathrm{PostLN}(x) = \mathrm{LayerNorm}(x + \mathrm{Sublayer}(x)),$$ with $$\begin{aligned}
\mathrm{LayerNorm}(x) &= \frac{x - E[x]}{\sqrt{Var[x] + \epsilon}}\cdot \gamma + \beta,
\label{ln_eqn}
\end{aligned}$$ where $\gamma$ and $\beta$ are trainable parameters, and $\epsilon$ is a small constant. Recent work has observed that Post-LN transformers tend to have larger magnitude gradients in later layers compared to earlier layers  and has advocated moving the LayerNorm operation to the beginning of each sublayer (“Pre-LN"; see Figure , left), i.e.: $$\mathrm{PreLN}(x) = x + \mathrm{Sublayer}(\mathrm{LayerNorm}(x)).$$ In practice Pre-LN transformers can be trained with larger learning rates, shorter learning rate warmup and often yield improved performance compared to Post-LN transformers , so most recent, large pretrained language models tend to use Pre-LN transformers .

In this work we show that, while Pre-LN improves stability over Post-LN, it has the opposite side effect: gradients at earlier layers tend to be larger than gradients at later layers. We propose `NormFormer`, which alleviates the gradient magnitude mismatch by adding 3 normalization operations to each layer (see Figure , middle). These operations reduce gradients to early layers and increase gradients to later layers, bringing their magnitudes closer together.

Compared to compute-matched, well-tuned Pre-LN baselines, `NormFormer` models reach target pretraining perplexities faster and achieve better pretraining perplexities and downstream task performance.

The rest of this paper is organized as follows: Section  describes the proposed modifications, Section  shows pretraining and downstream task performance for fully trained `NormFormer` models against well-tuned, compute-matched baselines. Section  shows the gradient mismatch introduced by Pre-LN and how `NormFormer` alleviates it. Section  analyzes residual scaling, a related technique proposed to stabilize Post-LN architectures . Section  shows that removing any of the added operations degrades performance and that `NormFormer` improves over the baseline at a wide range of hyperparameter configurations.

<figure id="fig:arch">
<div class="center">
<span class="image placeholder" data-original-image-src="nf_arch_v4.jpg" data-original-image-title=""></span>
</div>
<figcaption>Left: a baseline Pre-LayerNorm transformer layer. Center: <code>NormFormer</code>, with the three proposed additions in bold. Right: a single attention head with our proposed <code>HeadScale</code> operation applied prior to the output projection with trainable parameters <span class="math inline">\(\gamma_i\)</span>. * When applied, residual scaling impacts the second residual connection in each layer.</figcaption>
</figure>

# Approach

## NormFormer

`NormFormer` includes three modifications to the Pre-LN transformer: First, we apply head-wise scaling inside the attention module and add two additional LayerNorm operations: one after the attention module and a second after the first fully connected layer. The modifications introduce a small number of additional learnable parameters, which provide a cost-effective way for each layer to change the magnitude of its features, and therefore the magnitude of the gradients to subsequent components. The changes are visualized in Figure  and described below.

#### Scaling Attention Heads

The standard multi-head attention operation is defined as: $$\begin{aligned}
&\mathrm{MultiHeadAttention}(Q,K,V) = \mathrm{Concat}(\mathrm{h}_1,\dots,\mathrm{h}_n) W^O \label{eqn:multihead_att}\\ 
&\mathrm{h}_i = \mathrm{Attention}(QW^Q_i, KW^K_i, VW^V_i) \\
&\mathrm{Attention}(Q,K,V) = \mathrm{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V ,
\end{aligned}$$ where $n$ is the number of heads, $i$ is the attention head index, $d_k$ is the dimensionality of the keys and $W^O,W^Q_i,W^K_i,W^V_i$ are learned projection matrices for the output, query, key and value, respectively.

We propose scaling the output of each attention head via learned scalar coefficients $\gamma_i$: $$\begin{aligned}
\mathrm{HeadScaleMHA}(Q,K,V) = \mathrm{Concat}(\gamma_1 \mathrm{h}_1,\dots,\gamma_n \mathrm{h}_n) W^O
\end{aligned}$$ where $\gamma$ are learnable parameters initialized to 1.

#### Additional Layer Normalization and Putting it All Together

In the Pre-LN transformer each layer $l$ modifies an input $x_l$ as follows: $$\begin{aligned}
x_{l+1}^{\texttt{PreLN}} &= \mathrm{FFN}(\mathrm{MHA}(x_l)) \\
\\
\mathrm{where\qquad} \mathrm{MHA}(x) &= x + \mathrm{MultiHeadAttention}(\mathrm{LN}(x),\mathrm{LN}(x),\mathrm{LN}(x)) \\
\mathrm{FFN}(x) &= x + \sigma(\mathrm{LN}(x)W_1 + b_1) W_2 + b_2 \\
\mathrm{LN}(x) &= \mathrm{LayerNorm}(x)
\end{aligned}$$ In this work $\sigma$ is the GELU non-linear activation introduced in .

Our overall method, `NormFormer`, instead modifies each input $x_l$ as: $$\begin{aligned}
x_{l+1}^{\texttt{NormFormer}} &= \mathrm{NormFFN}(\mathrm{NormScaledMHA}(x_l)) \\
\\
\mathrm{where\qquad} \mathrm{NormScaledMHA}(x) &= x + \mathrm{\textbf{LN}}(\mathrm{\bf{HeadScaleMHA}}(\mathrm{LN}(x),\mathrm{LN}(x),\mathrm{LN}(x)))\\
\mathrm{NormFFN}(x) &= ~\bm{x} + \mathrm{\textbf{LN}}(\sigma(\mathrm{LN}(x)W_1 + b_1)) W_2 + b_2
%\mathrm{NormFormerLayer}(x) &= \mathrm{FC}_{2}(\textbf{\mathrm{LN}}(\mathrm{FC}_{1}(\textbf{\mathrm{LN}}(\mathrm{\textbf{Scaled}MHA}(\mathrm{LN}(x)))
\end{aligned}$$ where bolded operations are newly introduced.

## Experiments

#### Causal Language Models

We pretrain causal LMs (CLM) that roughly match the “Small" (125M parameter), “Medium" (355M), “Large" (1.3B) and “XL" (2.7B) sizes from .

Our model architecture differs from in two ways: (1) we use only dense attention, while they alternate between dense and locally banded sparse attention; (2) we train our models with sinusoidal positional embeddings, following Shortformer , since early experiments found this to produce comparable results with fewer learned parameters.

We train the baseline models for 300 billion tokens. We train `NormFormer` models for an equivalent number of GPU hours, which typically results in 2-6% fewer steps and tokens due to the additional overhead of the normalization operations.

<div class="center">

<div id="tab:lr">

| Model Size | GPT-3 Paper | Baseline | NormFormer |
|:----------:|:-----------:|:--------:|:----------:|
|    125M    |    6e-4     |   3e-3   |    3e-3    |
|    355M    |    3e-4     |   1e-3   |    1e-3    |
|    1.3B    |    2e-4     |   6e-4   |    6e-4    |

Searching for learning rates on our dataset results in higher values than reported in , providing stronger baselines to compare to our NormFormer architecture.

</div>

</div>

On our dataset, we find that the learning rates proposed in GPT-3 are suboptimally low.[^2] For both baseline and NormFormer at each size besides 2.7B, we tune the learning rate by training models for 50,000 steps and selecting the best performing learning rate among: $\{\num{1e-4}, \num{6e-4}, \num{3e-4}, \num{6e-4}, \num{1e-3}, \num{3e-3}\}$. The learning rates we obtained from this process, shown in Table , are 3-5 times larger than those used in the GPT-3 paper. Additionally, we have verified that the baseline and NormFormer both perform worse at the full training budget with the GPT-3 learning rates than with the higher learning rates. Other hyperparameters do not differ from GPT-3.[^3]

#### Residual Scaling

Standard Post-LN transformers simply sum the previous output (residual) with the new output. Recent work attempts to stabilize Post-LN architectures by weighting the residual connection for each layer . We thus experiment with scaling the residual in each embedding dimension via learned scalar coefficients $(\lambda_{resid})_i$: $$\mathrm{ResScale(x)} =  \lambda_{resid}  \circ x+ \mathrm{Sublayer}(\mathrm{LayerNorm}(x))$$ where $\circ$ is elementwise multiplication, and $\lambda_{resid}$ are learned parameters initialized to 1.

While this can be applied at any normalization layer, we find it it most effective for normalizing the feedforward network (FFN) submodule for the smaller sized language models. In this setting, $$\begin{aligned}
\mathrm{NormFFN}(x) &= {\bm{\lambda}_{\bm{resid}}~{\bm{\circ}}~\bm{x}} + \mathrm{\textbf{LN}}(\sigma(\mathrm{LN}(x)W_1 + b_1)) W_2 + b_2
\end{aligned}$$ For 1.3B parameter models and larger, scaling residuals hurts performance (see discussion in Section ), so `ResScale` is not used in our 1.3B and 2.7B CLM results.

#### Large scale experiments

We also train three large-scale models with 2.7B parameters. Our first baseline is a replicated version of GPT-3-2.7B with GELU activations, the published learning rate (1.6e-4) and the same number of training steps and tokens (286K steps; 300B tokens). This model slightly exceeds the reference zero shot performance . Next, we train two variants of GPT3-2.7B with $Relu^{2}$ activations , but use slightly fewer training steps (20% less) for compute efficiency. The first of these uses the baseline learning rate (1.6e-4) and the second uses `NormFormer-2.7B` with a higher learning rate of 6e-4. We note that training baseline 2.7B CLMs (i.e., without `NormFormer` modifications) with a higher 6e-4 learning rate diverged and failed to train. However, as opposed to the smaller architectures, we did not exhaustively tune the learning rate, so it is possible that an intermediate value would perform better.

#### Zero Shot Evaluation

In addition to validation perplexity, we evaluate CLMs on a subset of the tasks that GPT3 evaluated on in a zero-shot setting , with the same prompts. We select WinoGrande , StoryCloze , OpenBookQA , HellaSwag  and PIQA  because GPT3 showed strong performance on these tasks at small scale, as well as consistently improving performance with scale.

#### Masked Language Models (MLM)

We adopt the RoBERTa-base, Pre-LN architecture and hyperparameters used in . For the baseline, we pretrain for 2 million batches of 1 million tokens, about $\frac{1}{4}$ of the training budget of the original `roberta-base`. NormFormer runs through 1.92 million batches in the same amount of time.

#### Fine-Tuning

We fine-tune both the baseline MLM and NormFormer with learning rates $\num{1e-5}, \num{1e-4}, \num{3e-4}, \num{1e-3}, \num{3e-3}, \num{6e-3}$ and report the best performance on the validation set for each GLUE task , following . Other fine-tuning hyperparameters match those used for `roberta-base` in .

#### Pretraining data

We pretrain all models on a collection of English language text including the English portion of the CC100 corpus  as well as the data from , consisting of BookCorpus , English Wikipedia and filtered subsets of Common Crawl. We encode our data with the byte-level Byte Pair Encoding (BPE) vocabulary from , originally introduced in . The combined dataset contains around 450GB of uncompressed text and 110B BPE tokens. We hold out 40M BPE tokens from this data as a validation set on which we report pretraining perplexities.

#### Implementation details

We train our causal and masked language models in `fairseq` . Although NormFormer introduces fewer than 0.07% additional parameters, it slows individual training updates and increases memory usage between 2% (2.7B model) to 6% (125M model) due to the FFN LNs. Accordingly, we compare NormFormer to baseline models trained for an equal amount of GPU time, i.e., controlling for compute rather than the number of training updates. Finally, we note that the `HeadScale` operation can be moved outside the self attention module to allow the use of the very efficient pytorch `F.multihead_attention`. This change reduces overhead without noticeable performance degradation.

# Results

<figure id="fig:clm_pt">
<span class="image placeholder" data-original-image-src="curves_v6.jpg" data-original-image-title="" width="85%"></span>
<figcaption>Pretraining perplexity on held-out validation data for Causal and Masked Language Models as a function of training compute (GPU days). The blue stars show the point where a model matches the baseline’s lowest perplexity. </figcaption>
</figure>

We report pretraining perplexities for CLMs and MLMs as a function of training wall-time (GPU days) in Figure . We observe that NormFormer trains significantly faster and achieves better validation perplexities for a given training compute budget. The blue stars mark the first validation step where NormFormer matches the baseline’s lowest perplexity and shows that NormFormer matches Pre-LN models while needing only 60% and 57% as much compute for CLM and MLM models, respectively. This is particularly impressive since NormFormer models take 2-6% longer for each training step and thus see less data than Pre-LN models in this comparison. The left side blue line in Figure  shows the failed attempt to add `ResScale` to `NormFormer-1.3B`.

We observe a similar trend on downstream tasks. In Table  we report zero shot accuracy for causal LMs using the tasks and prompts from . NormFormer outperforms GPT-3 at all sizes. The gains from `Normformer` extra parameters operations outpace the gains from normal scaling laws. Changing the hidden dimension of a 125M parameter model from 768 to 780, for example, results in a 127 million parameter model that is only 0.08 perplexity better than the baseline whereas `NormFormer-125M` adds only 100,000 parameters and is 0.83 perplexity better than the baseline.

For MLM models, we report fine-tuned accuracy on GLUE in Table . We again find that NormFormer MLM models outperform their Pre-LN counterparts on every task (rows 1 vs 2). Adding `ResScale` improves improves pre-training performance marginally (3.29 valid PPL vs 3.31), but the gains to do not translate to finetuned performance.

# Analysis

## Analysis of gradient norms by layer

<figure id="fig:gnorm_fc2">
<span class="image placeholder" data-original-image-src="gnorm_title_fix.jpg" data-original-image-title="" width="\linewidth"></span>
<figcaption>Average L1 norm of gradients to the second fully connected weight for layers 0,1,6,10 and 11, early in training. </figcaption>
</figure>

<figure id="fig:ffn_layernorm">
<span class="image placeholder" data-original-image-src="lnweight.jpg" data-original-image-title=""></span>
<figcaption>Distribution of learned scaling parameters in three of the added operations. For FFN LN, earlier layers receive downscaled inputs, keeping their gradients in the same range as the gradients of later layers. This plot is discussed in detail in Section <span class="math inline">\(\ref{sec:mismatch}\)</span>.</figcaption>
</figure>

<figure id="fig:stability-results">
<span class="image placeholder" data-original-image-src="stab_v5.jpg" data-original-image-title=""></span>
<figcaption>LR Stability Test: learning rate starts from 0 and linearly increases by <code>5e-5</code> at each training step until training destabilizes. NormFormer reaches a higher learning rate before destabilizing. Each data point is the median of 3 runs with a different random seed.</figcaption>
</figure>

We begin by examining the magnitude of the gradients at different layers for Post-LN, Pre-LN and NormFormer models, since large magnitude differences in gradients across layers can destabilize training, particularly when training in mixed precision . Figure  shows the average L1 norm of the gradients to the second fully connected weight in various layers for a 12 layer, 125M parameter CLM model at the beginning of training. As reported in past work , we observe that the gradients to later layers in Post-LN models are much larger than for earlier layers, and that the gradients to early layers quickly vanish in the early stages of training. Pre-LN models have the opposite behavior, with early layers instead receiving significantly larger gradients than later layers. `NormFormer` brings the average gradient norms closer together for different layers in the network.

In Figure  we present the distribution of scaling parameters learned by `NormFormer` models. For the FFN LN, the $\gamma$ parameters are smaller for earlier layers, reducing the magnitude of the inputs to early fully connected parameters, thereby decreasing the magnitude of their gradients. The post attention LN, in the middle of Figure , all layers have $\gamma$ coefficients below 1, indicating downscaling.[^4] The `HeadScale` $\gamma$ parameters, shown in the rightmost plot in Figure  vary more than the others, and have no relationship with depth in the network. We interpret this as evidence that the `HeadScale` parameters dynamically increase the importance of well initialized attention heads, as suggested in .

One result of reducing the gradient mismatch, besides better perplexities and downstream task performance, is the ability to train stably with larger learning rates. To measure the stability of an architecture, we train it on a learning rate schedule with a very large peak learning rate, so that the learning rate increases a little each step until the loss explodes. Figure  shows that NormFormer models can survive for more updates in this environment than the baseline. For the baseline 125M model (the left most blue dot), the loss eventually explodes, with the activations from multiplying the query and key features at layer 0 overflowing the FP16 range. The down scaling of the attention outputs allows NormFormer to avoid this issue and remain stable with larger learning rates. Figure  also shows that $\lambda_{resid}$ reduces the stability improvement at all sizes.

## Residual Scaling

By comparing adjacent NormFormer-125M and NormFormer-355M rows in Table  we can see that adding `ResScale` to `NormFormer` improves perplexity and zero shot performance for small scale CLMs. For 125M parameter MLM, `ResScale` improves pre-training perplexity marginally, but hurts fine-tuned performance. At 1.3 billion parameter scale, however, adding `ResScale` to `NormFormer` does not improve performance (Figure ). Although it’s not included in our tables, we find that `ResScale` without NormFormer is stronger than the baseline at small scale, but not large scale. This suggests that the negative result is caused by scale, rather than interaction with `NormFormer`.

Figure  shows the Avg. $\lambda_{resid}$ weights at each layer of different sized CLMs. We can see that at 125M and 355M parameters, the weights in the later layers are lower, indicating down weighting of the residual connection, whereas at the largest scale, 1.3B, the weights are larger deeper into the network.

Adding the $\lambda_{resid}$ parameters to the other (earlier) residual connection in each layer, or using a scalar instead of a vector for each $\lambda_{resid}$, does not fix the large scale issue, but hurts small scale performance marginally.

<figure id="fig:resid-coeff">
<span class="image placeholder" data-original-image-src="resid_coeff.jpg" data-original-image-title=""></span>
<figcaption><span class="math inline">\(\lambda_{resid}\)</span> weights at each layer of different sized CLMs in the <code>NormFormer+</code><span class="math inline">\(\lambda_{resid}\)</span> setting. Depth is layer number / total layers.</figcaption>
</figure>

# Ablations

This section provides evidence that removing any of our additions to the transformer block degrades performance on language modeling tasks, and that our additions improve language modeling performance across a wide range of hyperparameter settings. Experiments use 125M parameter CLMs, and are run with the default hyperparameters given in Table  in the appendix for 470 V100 Hours (100,000 updates for the baseline) unless otherwise mentioned.

#### Removing any of the added operations hurts performance

Table  shows that none of the four introduced operations can be removed without degrading performance. Rows 2-5 remove each operation one at a time. In all cases perplexity increases, with the removal of `HeadScale` being the most damaging and the removal of the Post-Attn LN being the least damaging. In Row 6 (`+ 3 More LN`) we try to introduce more normalization inside self attention, applying LN to the query, key and value features in addition to our 3 other operations, for a total of 6 new operations. In this setting, every other parameterized operation inside the transformer layer is an LN. We find that this does not change perplexities at a fixed number of updates, but reduces training speed by another 5%. This result suggests that there is not much upside to adding even more normalization on top of `NormFormer`.

<div class="center">

<div id="tab:more_ln">

<table>
<caption>125M parameter Language Modeling Validation perplexities after 470 V100 Hours of pretraining. Removing any of our proposed additions degrades performance (Rows 2-5). Adding more normalization inside the Multi Headed Attention (Row 6) does not impact perplexity at a fixed number of updates, but reduces throughput such that the model can only complete 87,500 updates vs. 92,500 for Rows 1-5 and 100,000 for Row 7. Note that these PPL scores are not directly comparable to other tables – they use a different validation set.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Architecture</th>
<th style="text-align: center;">Valid PPL</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">NormFormer+ResScale</td>
<td style="text-align: center;"><strong>15.88</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>- Post-Attn LN</p></td>
<td style="text-align: center;">15.92</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>- FFN LN</p></td>
<td style="text-align: center;">16.14</td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>- Head Scale</p></td>
<td style="text-align: center;">16.22</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>- Res Scale</p></td>
<td style="text-align: center;">16.20</td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>+ 3 More LN</p></td>
<td style="text-align: center;">15.88</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Baseline</td>
<td style="text-align: center;">16.37</td>
</tr>
</tbody>
</table>

125M parameter Language Modeling Validation perplexities after 470 V100 Hours of pretraining. Removing any of our proposed additions degrades performance (Rows 2-5). Adding more normalization inside the Multi Headed Attention (Row 6) does not impact perplexity at a fixed number of updates, but reduces throughput such that the model can only complete 87,500 updates vs. 92,500 for Rows 1-5 and 100,000 for Row 7. Note that these PPL scores are not directly comparable to other tables – they use a different validation set.

</div>

</div>

#### Other Experiments

Replacing the FFN LN with the FFNGeGlu proposed in , which includes scaling but no normalization, degraded performance in our 125M parameter CLM setting, the only place we tried it. We also find that the LN variant proposed in , which removes the bias and the mean substraction from the normalization, performs equally well to our LN and has fewer trainable parameters, but is about 2x slower than the `FusedLayerNorm` implementation we use. We therefore do not adopt it.

propose related stabilization strategies for text to image generation tasks with larger models including a downscaled embedding gradient, a layer norm after the final fully connected layer, and the same post-attention LN. We find that, besides the post attention LN, these techniques do not help in our setting.

Table  in the appendix shows language modeling perplexities for 7 different hyperparameter configurations, separated by horizontal lines. `NormFormer` outperforms the baseline in all settings.

# Related Work

Layer normalization is an important component of the transformer architecture. shows that for Post-LN: gradients are too big for later layers and solves this problem with Pre-LN. We build on the Pre-LN architecture to make it even more stable and efficient.

proposes an architecture where instead of interleaving attention and feed forward sublayers, the attention all happens first. This increases the number of late FFN parameters, rather than increasing their importance and gradient norm, as our FFN LN does, and does not impact stability.

Our `HeadScale` operation is related to that used in , but used differently. Whereas that work prunes attention heads with low $\gamma$ parameters, we use the $\gamma$ parameters to improve pretraining performance.

These approaches are also related to techniques for initializing neural networks: GradInit introduces a set of scalars and biases for initialization based on a variance heuristic, and Admin applies a similar heuristic in profiling and initialization stages. These works also use variants of our `ResScale` operation, which we find helpful at small scale and harmful at large scale.

Similarly, some other approaches targeted initialization as well, in particular ReZero , FixUp and LookLinear . We note that DALL-E also added a per residual scaling factor (only during backprop). Our approach, in contrast, only has new learnable parameters without variance heuristics, and has no extra stages or changes in initialization.

# Conclusion

We identify a mismatch in the gradients of Pre-LN transformer weights: earlier layers receive much larger gradients than later layers, while the optimal scaling of residuals is larger at earlier layers than at later layers. We propose `NormFormer`, which alleviates these issues by adding 3 extra operations to each transformer layer. These modifications help the gradient mismatch for fully connected parameters and improve validation perplexity and downstream task performance for both causal and masked language models. None can be removed without degrading performance back towards the baseline, and adding more normalization – at least of the types we have tried – does not improve performance. Since NormFormer primarily addresses the gradient mismatch by increasing the gradients to the last FFN layers while decreasing the gradient magnitudes in other parts of the network, future work could examine whether all 3 operations need to be added to every layer. Additionally, the small computational overhead associated with NormFormer could be alleviated by fusing the FFN LN with the preceding fully connected layer, with or without the mean centering and bias, which do not appear to improve pretraining perplexity. In general, we have shown that adding small numbers of learnable parameters in the right places in our architectures can alleviate certain issues in current state of the art networks. Future work should ascertain if there are additional similarly efficient modifications that can bring gains, while helping us understand current deficiencies further.

# Appendix

<div class="center">

<div id="tab:hparam_results">

|            | Learning Rate |    Setting Changes     | Valid PPL |
|:----------:|:-------------:|:----------------------:|:---------:|
|  Baseline  |     0.001     |           \-           |   16.80   |
| NormFormer |     0.001     |           \-           | **16.33** |
|  Baseline  |     0.003     |           \-           |   16.37   |
| NormFormer |     0.003     |           \-           | **15.88** |
|  Baseline  |     0.006     |           \-           |   16.58   |
| NormFormer |     0.006     |           \-           | **16.22** |
|  Baseline  |     0.003     |     Longer Warmup      |   16.50   |
| NormFormer |     0.003     |     Longer Warmup      | **16.06** |
|  Baseline  |     0.003     |          GPT3          |   16.29   |
| NormFormer |     0.003     |          GPT3          | **15.88** |
|  Baseline  |     0.003     | Clip Grad Norms at 0.1 |   16.46   |
| NormFormer |     0.003     | Clip Grad Norms at 0.1 | **16.14** |

Longer Warmup: increase LR Warmup to 6,000 steps (from 500). GPT3: increase sequence length to 2048, increase dropout to 0.1, increase training budget to 1,000 V100 hours. Grad Clip: clip gradient norms at 0.1. NormFormer outperforms the baseline in all settings.

</div>

</div>

#### Wikitext103

Table  shows that NormFormer can also provide gains on top of a well tuned language model in settings with much less data. We simply add our three operations to the architecture and hyperparameters of . Convergence perplexity improves, and we reach the baseline perplexity in 70% as many steps. In this setting, `NormFormer` does not improve in the last 30% of training, which suggests that with more tuning the perplexity gap could be widened.

<div id="tab:wikitext">

|            | Steps to Final PPL |  PPL  |
|:----------:|:------------------:|:-----:|
|  Baseline  |        100%        | 18.70 |
| NormFormer |        70%         | 18.65 |

Wikitext 103 results following . `Steps to Final PPL`: at what percentage of the 280K steps did the model reach 18.70 perplexity. `PPL`: Best Perplexity

</div>

<figure id="fig:gnorm_all">
<span class="image placeholder" data-original-image-src="all_params_scale_smaller.jpg" data-original-image-title=""></span>
<figcaption>Change in grad norm with each operation of NormFormer compared to the baseline. Norms are the average between step 950 and 1000, normalized to control for different losses. 2.0 on the Y axis means the gradient to a parameter is twice as large as the baseline, on average. The NormFormer increases the norm to fully connected parameters in later layers, while reducing the gradient norm to attention parameters at all layers. The results are discussed in detail in Section <span class="math inline">\(\ref{sec:mismatch}\)</span>.</figcaption>
</figure>

<div class="center">

<div id="tab:ablation_hparams">

|                   |                |
|:-----------------:|:--------------:|
|   Learning Rate   |     0.003      |
|    Batch Size     |  524K Tokens   |
|    Parameters     |     124M+      |
|      Layers       |       12       |
|  Layer Dimension  |      768       |
|      Dropout      |       0        |
| LR Warmup Updates |      500       |
|   LR Scheduler    |  Linear Decay  |
|  Sequence Length  |      1024      |
|   Train Budget    | 470 V100 Hours |

Hyperparameters for ablations in Tables  and . This train budget allows the baseline model to run for 100,000 updates.

</div>

</div>

[^1]: Jason implemented residual scaling and helped with writing. Myle helped with writing and hardware issues. Thanks to Tim Dettmers for giving us early access to the Adam8Bit Optimizer, and to Naman Goyal, Xian Li, Susan Zhang, Zoe Shleifer and Ofir Press for valuable comments. Correspondence to <a href="sshleifer@fb.com" class="uri">sshleifer@fb.com</a>.

[^2]: The difference in optimal learning rates may be due partly to architectural differences between our baseline and GPT-3 (e.g., not using locally banded sparse attention).

[^3]: See Table 2.1 in .

[^4]: The downscaling is also apparent in Figure  in the Appendix, which plots the change in grad norm for each operation at each layer. It shows that adding extra normalization reduces the gradient norm for all attention parameters at every layer. Only FFN parameters at later layers, have increased gradient norms.
