---
author:
- Shibo Hao
- Sainbayar Sukhbaatar
- DiJia Su
- Xian Li
- Zhiting Hu
- Jason Weston
- Yuandong Tian
bibliography:
- paper.bib
citation-style: ieee
date: 2025-01-04
header-includes:
- 
- 
link-citations: true
reference-section-title: References
title: Training Large Language Models to Reason in a Continuous Latent Space
---





# Introduction

Large language models (LLMs) have demonstrated remarkable reasoning abilities, emerging from extensive pretraining on human languages . While next token prediction is an effective training objective, it imposes a fundamental constraint on the LLM as a reasoning machine: the explicit reasoning process of LLMs must be generated in word tokens. For example, a prevalent approach, known as chain-of-thought (CoT) reasoning , involves prompting or training LLMs to generate solutions step-by-step using natural language. However, this is in stark contrast to certain human cognition results. Neuroimaging studies have consistently shown that the language network – a set of brain regions responsible for language comprehension and production – remains largely inactive during various reasoning tasks  . Further evidence indicates that human language is optimized for communication rather than reasoning .

A significant issue arises when LLMs use language for reasoning: the amount of reasoning required for each particular reasoning token varies greatly, yet current LLM architectures allocate nearly the same computing budget for predicting every token. Most tokens in a reasoning chain are generated solely for fluency, contributing little to the actual reasoning process. On the contrary, some critical tokens require complex planning and pose huge challenges to LLMs. While previous work has attempted to fix these problems by prompting LLMs to generate succinct reasoning chains , or performing additional reasoning before generating some critical tokens , these solutions remain constrained within the language space and do not solve the fundamental problems. On the contrary, it would be ideal for LLMs to have the freedom to reason without any language constraints, and then translate their findings into language only when necessary.

<figure id="fig:motivation">
<span class="image placeholder" data-original-image-src="figures/figure_1_meta_3.png" data-original-image-title="" width="\linewidth"></span>
<figcaption>A comparison of Chain of Continuous Thought (<span class="smallcaps">Coconut</span>) with Chain-of-Thought (CoT). In CoT, the model generates the reasoning process as a word token sequence (e.g., <span class="math inline">\([x_{i}, x_{i+1}, ..., x_{i+j}]\)</span> in the figure). <span class="smallcaps">Coconut</span> regards the last hidden state as a representation of the reasoning state (termed “continuous thought”), and directly uses it as the next input embedding. This allows the LLM to reason in an unrestricted latent space instead of a language space.</figcaption>
</figure>

In this work we instead explore LLM reasoning in a latent space by introducing a novel paradigm, <span class="smallcaps">Coconut</span>(Chain of Continuous Thought). It involves a simple modification to the traditional CoT process: instead of mapping between hidden states and language tokens using the language model head and embedding layer, <span class="smallcaps">Coconut</span> directly feeds the last hidden state (a continuous thought) as the input embedding for the next token (Figure ). This modification frees the reasoning from being within the language space, and the system can be optimized end-to-end by gradient descent, as continuous thoughts are fully differentiable. To enhance the training of latent reasoning, we employ a multi-stage training strategy inspired by , which effectively utilizes language reasoning chains to guide the training process.

Interestingly, our proposed paradigm leads to an efficient reasoning pattern. Unlike language-based reasoning, continuous thoughts in <span class="smallcaps">Coconut</span> can encode multiple potential next steps simultaneously, allowing for a reasoning process akin to breadth-first search (BFS). While the model may not initially make the correct decision, it can maintain many possible options within the continuous thoughts and progressively eliminate incorrect paths through reasoning, guided by some implicit value functions. This advanced reasoning mechanism surpasses traditional CoT, even though the model is not explicitly trained or instructed to operate in this manner, as seen in previous works .

Experimentally, <span class="smallcaps">Coconut</span> successfully enhances the reasoning capabilities of LLMs. For math reasoning (GSM8k, ), using continuous thoughts is shown to be beneficial to reasoning accuracy, mirroring the effects of language reasoning chains. This indicates the potential to scale and solve increasingly challenging problems by chaining more continuous thoughts. On logical reasoning including ProntoQA , and our newly proposed ProsQA (Section ) which requires stronger planning ability, <span class="smallcaps">Coconut</span> and some of its variants even surpasses language-based CoT methods, while generating significantly fewer tokens during inference. We believe that these findings underscore the potential of latent reasoning and could provide valuable insights for future research.

# Related Work

**Chain-of-thought (CoT) reasoning.** We use the term chain-of-thought broadly to refer to methods that generate an intermediate reasoning process in language before outputting the final answer. This includes prompting LLMs , or training LLMs to generate reasoning chains, either with supervised finetuning  or reinforcement learning . classified the tokens in CoT into symbols, patterns, and text, and proposed to guide the LLM to generate concise CoT based on analysis of their roles. Recent theoretical analyses have demonstrated the usefulness of CoT from the perspective of model expressivity . By employing CoT, the effective depth of the transformer increases because the generated outputs are looped back to the input . These analyses, combined with the established effectiveness of CoT, motivated our design that feeds the continuous thoughts back to the LLM as the next input embedding. While CoT has proven effective for certain tasks, its autoregressive generation nature makes it challenging to mimic human reasoning on more complex problems , which typically require planning and search. There are works that equip LLMs with explicit tree search algorithms , or train the LLM on search dynamics and trajectories . In our analysis, we find that after removing the constraint of a language space, a new reasoning pattern similar to BFS emerges, even though the model is not explicitly trained in this way.

**Latent reasoning in LLMs.** Previous works mostly define latent reasoning in LLMs as the hidden computation in transformers . constructed a dataset of two-hop reasoning problems and discovered that it is possible to recover the intermediate variable from the hidden representations. further proposed to intervene the latent reasoning by “back-patching” the hidden representation. discovered parallel latent reasoning paths in LLMs. Another line of work has discovered that, even if the model generates a CoT to reason, the model may actually utilize a different latent reasoning process. This phenomenon is known as the unfaithfulness of CoT reasoning . To enhance the latent reasoning of LLM, previous research proposed to augment it with additional tokens. pretrained the model by randomly inserting a learnable `<pause>` tokens to the training corpus. This improves LLM’s performance on a variety of tasks, especially when followed by supervised finetuning with `<pause>` tokens. On the other hand, further explored the usage of filler tokens, e.g., “`...`”, and concluded that they work well for highly parallelizable problems. However, mentioned these methods do not extend the expressivity of the LLM like CoT; hence, they may not scale to more general and complex reasoning problems. proposed to predict a planning token as a discrete latent variable before generating the next reasoning step. Recently, it has also been found that one can “internalize” the CoT reasoning into latent reasoning in the transformer with knowledge distillation  or a special training curriculum which gradually shortens CoT . also proposed to distill a model that can reason latently from data generated with complex reasoning algorithms. These training methods can be combined to our framework, and specifically, we find that breaking down the learning of continuous thoughts into multiple stages, inspired by iCoT , is very beneficial for the training. Recently, looped transformers  have been proposed to solve algorithmic tasks, which have some similarities to the computing process of continuous thoughts, but we focus on common reasoning tasks and aim at investigating latent reasoning in comparison to language space.

# <span class="smallcaps">Coconut</span>: Chain of Continuous Thought

In this section, we introduce our new paradigm <span class="smallcaps">Coconut</span>(Chain of Continuous Thought) for reasoning in an unconstrained latent space. We begin by introducing the background and notation we use for language models. For an input sequence $x = (x_1, ..., x_T)$, the standard large language model $\mathcal{M}$ can be described as:

$$H_t = \text{Transformer}(E_t)$$ $$\mathcal{M}(x_{t+1}\mid x_{\leq t}) = \text{softmax}(Wh_t)$$

where $E_t = [e(x_1), e(x_2), ..., e(x_t)]$ is the sequence of token embeddings up to position $t$; $H_t \in \mathbb{R}^{t \times d}$ is the matrix of the last hidden states for all tokens up to position $t$; $h_t$ is the last hidden state of position $t$, i.e., $h_t=H_t[t, :]$; $e(\cdot)$ is the token embedding function; $W$ is the parameter of the language model head.

**Method Overview.** In the proposed <span class="smallcaps">Coconut</span> method, the LLM switches between the “language mode” and “latent mode” (Figure ). In language mode, the model operates as a standard language model, autoregressively generating the next token. In latent mode, it directly utilizes the last hidden state as the next input embedding. This last hidden state represents the current reasoning state, termed as a “continuous thought”.

Special tokens `<bot>` and `<eot>` are employed to mark the beginning and end of the latent thought mode, respectively. As an example, we assume latent reasoning occurs between positions $i$ and $j$, i.e., $x_i=$ `<bot>` and $x_j=$ `<eot>`. When the model is in the latent mode ($i < t < j$), we use the last hidden state from the previous token to replace the input embedding, i.e., $E_t=[e(x_1), e(x_2), ..., e(x_i), h_i, h_{i+1}, ..., h_{t-1}]$. After the latent mode finishes ($t \ge j$), the input reverts to using the token embedding, i.e., $E_t=[e(x_1), e(x_2), ..., e(x_i), h_i, h_{i+1}, ..., h_{j-1}, e(x_j), ..., e(x_t)]$. It is worth noting that the last hidden states have been processed by the final normalization layer, so they are not too large in magnitude. $\mathcal{M}(x_{t+1}\mid x_{\leq t})$ is not defined when $i<t<j$, since the latent thought is not intended to be mapped back to language space. However, $\softmax(Wh_t)$ can still be calculated for probing purposes (see Section ).

**Training Procedure.** In this work, we focus on a problem-solving setting where the model receives a question as input and is expected to generate an answer through a reasoning process. We leverage language CoT data to supervise continuous thought by implementing a multi-stage training curriculum inspired by . As shown in Figure , in the initial stage, the model is trained on regular CoT instances. In the subsequent stages, at the $k$-th stage, the first $k$ reasoning steps in the CoT are replaced with $k \times c$ continuous thoughts[^1], where $c$ is a hyperparameter controlling the number of latent thoughts replacing a single language reasoning step. Following , we also reset the optimizer state when training stages switch. We insert `<bot>` and `<eot>` tokens (which are not counted towards $c$) to encapsulate the continuous thoughts.

<figure id="fig:training">
<span class="image placeholder" data-original-image-src="figures/figure_2_meta_5.png" data-original-image-title="" width="\linewidth"></span>
<figcaption>Training procedure of Chain of Continuous Thought (<span class="smallcaps">Coconut</span>). Given training data with language reasoning steps, at each training stage we integrate <span class="math inline">\(c\)</span> additional continuous thoughts (<span class="math inline">\(c=1\)</span> in this example), and remove one language reasoning step. The cross-entropy loss is then used on the remaining tokens after continuous thoughts.</figcaption>
</figure>

During the training process, we optimize the normal negative log-likelihood loss, but mask the loss on questions and latent thoughts. It is important to note that the objective does **not** encourage the continuous thought to *compress the removed language thought*, but rather to *facilitate the prediction of future reasoning*. Therefore, it’s possible for the LLM to learn more effective representations of reasoning steps compared to human language.

**Training Details.** Our proposed continuous thoughts are fully differentiable and allow for back-propagation. We perform $n+1$ forward passes when $n$ latent thoughts are scheduled in the current training stage, computing a new latent thought with each pass and finally conducting an additional forward pass to obtain a loss on the remaining text sequence. While we can save any repetitive computing by using a KV cache, the sequential nature of the multiple forward passes poses challenges for parallelism. Further optimizing the training efficiency of <span class="smallcaps">Coconut</span> remains an important direction for future research.

**Inference Process.** The inference process for <span class="smallcaps">Coconut</span> is analogous to standard language model decoding, except that in latent mode, we directly feed the last hidden state as the next input embedding. A challenge lies in determining when to switch between latent and language modes. As we focus on the problem-solving setting, we insert a `<bot>` token immediately following the question tokens. For `<eot>`, we consider two potential strategies: a) train a binary classifier on latent thoughts to enable the model to autonomously decide when to terminate the latent reasoning, or b) always pad the latent thoughts to a constant length. We found that both approaches work comparably well. Therefore, we use the second option in our experiment for simplicity, unless specified otherwise.

# Experiments

We validate the feasibility of LLM reasoning in a continuous latent space through experiments on three datasets. We mainly evaluate the accuracy by comparing the model-generated answers with the ground truth. The number of newly generated tokens per question is also analyzed, as a measure of reasoning efficiency. We report the clock-time comparison in Appendix .

## Reasoning Tasks

**Math Reasoning.** We use GSM8k  as the dataset for math reasoning. It consists of grade school-level math problems. Compared to the other datasets in our experiments, the problems are more diverse and open-domain, closely resembling real-world use cases. Through this task, we explore the potential of latent reasoning in practical applications. To train the model, we use a synthetic dataset generated by .

**Logical Reasoning.** Logical reasoning involves the proper application of known conditions to prove or disprove a conclusion using logical rules. This requires the model to choose from multiple possible reasoning paths, where the correct decision often relies on exploration and planning ahead. We use 5-hop ProntoQA  questions, with fictional concept names. For each problem, a tree-structured ontology is randomly generated and described in natural language as a set of known conditions. The model is asked to judge whether a given statement is correct based on these conditions. This serves as a simplified simulation of more advanced reasoning tasks, such as automated theorem proving .

We found that the generation process of ProntoQA could be more challenging, especially since the size of distracting branches in the ontology is always small, reducing the need for complex planning. To fix that, we apply a new dataset construction pipeline using randomly generated DAGs to structure the known conditions. The resulting dataset requires the model to perform substantial planning and searching over the graph to find the correct reasoning chain. We refer to this new dataset as ProsQA (<u>Pro</u>of with <u>S</u>earch <u>Q</u>uestion-<u>A</u>nswering). A visualized example is shown in Figure . More details of datasets can be found in Appendix .

## Experimental Setup

We use a pre-trained GPT-2  as the base model for all experiments. The learning rate is set to $1\times 10^{-4}$ while the effective batch size is 128. Following , we also reset the optimizer when the training stages switch.

**Math Reasoning.** By default, we use 2 latent thoughts (i.e., $c=2$) for each reasoning step. We analyze the correlation between performance and $c$ in Section . The model goes through 3 stages besides the initial stage. Then, we have an additional stage, where we still use $3\times c$ continuous thoughts as in the penultimate stage, but remove all the remaining language reasoning chain. This handles the long-tail distribution of reasoning chains longer than 3 steps. We train the model for 6 epochs in the initial stage, and 3 epochs in each remaining stage.

**Logical Reasoning.** We use one continuous thought for every reasoning step (i.e., $c=1$). The model goes through 6 training stages in addition to the initial stage, because the maximum number of reasoning steps is 6 in these two datasets. The model then fully reasons with continuous thoughts to solve the problems in the last stage. We train the model for 5 epochs per stage.

For all datasets, after the standard schedule, the model stays in the final training stage, until the 50th epoch. We select the checkpoint based on the accuracy on the validation set. For inference, we manually set the number of continuous thoughts to be consistent with their final training stage. We use greedy decoding for all experiments.

## Baselines and Variants of <span class="smallcaps">Coconut</span>

We consider the following baselines: (1) *CoT*: We use the complete reasoning chains to train the language model with supervised finetuning, and during inference, the model generates a reasoning chain before outputting an answer. (2) *No-CoT*: The LLM is trained to directly generate the answer without using a reasoning chain. (3) *iCoT* : The model is trained with language reasoning chains and follows a carefully designed schedule that “internalizes” CoT. As the training goes on, tokens at the beginning of the reasoning chain are gradually removed until only the answer remains. During inference, the model directly predicts the answer. (4) *Pause token* : The model is trained using only the question and answer, without a reasoning chain. However, different from *No-CoT*, special `<pause>` tokens are inserted between the question and answer, which are believed to provide the model with additional computational capacity to derive the answer. For a fair comparison, the number of `<pause>` tokens is set the same as continuous thoughts in <span class="smallcaps">Coconut</span>.

We also evaluate some variants of our method: (1) *w/o curriculum*: Instead of the multi-stage training, we directly use the data from the last stage which only includes questions and answers to train <span class="smallcaps">Coconut</span>. The model uses continuous thoughts to solve the whole problem. (2) *w/o thought*: We keep the multi-stage training which removes language reasoning steps gradually, but don’t use any continuous latent thoughts. While this is similar to *iCoT* in the high-level idea, the exact training schedule is set to be consistent with <span class="smallcaps">Coconut</span>, instead of *iCoT*. This ensures a more strict comparison. (3) *Pause as thought*: We use special `<pause>` tokens to replace the continuous thoughts, and apply the same multi-stage training curriculum as <span class="smallcaps">Coconut</span>.

## Results and Discussion

We show the overall results on all datasets in Table . Continuous thoughts effectively enhance LLM reasoning, as shown by the consistent improvement over *no-CoT*. It even shows better performance than *CoT* on ProntoQA and ProsQA. We describe several key conclusions from the experiments as follows.

**“Chaining” continuous thoughts enhances reasoning.** In conventional CoT, the output token serves as the next input, which proves to increase the effective depth of LLMs and enhance their expressiveness . We explore whether latent space reasoning retains this property, as it would suggest that this method could scale to solve increasingly complex problems by chaining multiple latent thoughts.

In our experiments with GSM8k, we found that <span class="smallcaps">Coconut</span> outperformed other architectures trained with similar strategies, particularly surpassing the latest baseline, *iCoT* . The performance is significantly better than <span class="smallcaps">Coconut</span>(*pause as thought*) which also enables more computation in the LLMs. While empirically shows that filler tokens, such as the special `<pause>` tokens, can benefit highly parallelizable problems, our results show that <span class="smallcaps">Coconut</span> architecture is more effective for general problems, e.g., math word problems, where a reasoning step often heavily depends on previous steps. Additionally, we experimented with adjusting the hyperparameter $c$, which controls the number of latent thoughts corresponding to one language reasoning step (Figure ). As we increased $c$ from 0 to 1 to 2, the model’s performance steadily improved.[^2] These results suggest that a chaining effect similar to CoT can be observed in the latent space.

In two other synthetic tasks, we found that the variants of <span class="smallcaps">Coconut</span>(*w/o thoughts* or *pause as thought*), and the *iCoT* baseline also achieve impressive accuracy. This indicates that the model’s computational capacity may not be the bottleneck in these tasks. In contrast, GSM8k, being an open-domain question-answering task, likely involves more complex contextual understanding and modeling, placing higher demands on computational capability.

**Latent reasoning outperforms language reasoning in planning-intensive tasks.** Complex reasoning often requires the model to “look ahead” and evaluate the appropriateness of each step. Among our datasets, GSM8k and ProntoQA are relatively straightforward for next-step prediction, due to intuitive problem structures and limited branching. In contrast, ProsQA’s randomly generated DAG structure significantly challenges the model’s planning capabilities. As shown in Table , *CoT* does not offer notable improvement over *No-CoT*. However, <span class="smallcaps">Coconut</span>, its variants, and *iCoT* substantially enhance reasoning on ProsQA, indicating that latent space reasoning provides a clear advantage in tasks demanding extensive planning. An in-depth analysis of this process is provided in Section .

**The LLM still needs guidance to learn latent reasoning.** In the ideal case, the model should learn the most effective continuous thoughts automatically through gradient descent on questions and answers (i.e., <span class="smallcaps">Coconut</span>*w/o curriculum*). However, from the experimental results, we found the models trained this way do not perform any better than no-CoT.

With the multi-stage curriculum which decomposes the training into easier objectives, <span class="smallcaps">Coconut</span> is able to achieve top performance across various tasks. The multi-stage training also integrates well with pause tokens (<span class="smallcaps">Coconut</span>- *pause as thought*). Despite using the same architecture and similar multi-stage training objectives, we observed a small gap between the performance of *iCoT* and <span class="smallcaps">Coconut</span>(*w/o thoughts*). The finer-grained removal schedule (token by token) and a few other tricks in *iCoT* may ease the training process. We leave combining *iCoT* and <span class="smallcaps">Coconut</span> as future work. While the multi-stage training used for <span class="smallcaps">Coconut</span> has proven effective, further research is definitely needed to develop better and more general strategies for learning reasoning in latent space, especially without the supervision from language reasoning chains.

**Continuous thoughts are efficient representations of reasoning.** Though the continuous thoughts are not intended to be decoded to language tokens, we can still use it as an intuitive interpretation of the continuous thought. We show a case study in Figure  of a math word problem solved by <span class="smallcaps">Coconut</span>($c=1$). The first continuous thought can be decoded into tokens like “180”, “ 180” (with a space), and “9”. Note that, the reasoning trace for this problem should be $3\times 3 \times 60 = 9 \times 60 = 540$, or $3\times 3 \times 60 = 3 \times 180 = 540$. The interpretations of the first thought happen to be the first intermediate variables in the calculation. Moreover, it encodes a distribution of different traces into the continuous thoughts. As shown in Section , this feature enables a more advanced reasoning pattern for planning-intense reasoning tasks.

# Understanding the Latent Reasoning in <span class="smallcaps">Coconut</span>

In this section, we present an analysis of the latent reasoning process with a variant of <span class="smallcaps">Coconut</span>. By leveraging its ability to switch between language and latent space reasoning, we are able to control the model to interpolate between fully latent reasoning and fully language reasoning and test their performance (Section ). This also enables us to interpret the the latent reasoning process as tree search (Section ). Based on this perspective, we explain why latent reasoning can make the decision easier for LLMs (Section ).

## Experimental Setup

**Methods.** The design of <span class="smallcaps">Coconut</span> allows us to control the number of latent thoughts by manually setting the position of the `<eot>` token during inference. When we enforce <span class="smallcaps">Coconut</span> to use $k$ continuous thoughts, the model is expected to output the remaining reasoning chain in language, starting from the $k+1$ step. In our experiments, we test variants of <span class="smallcaps">Coconut</span> on ProsQA with $k \in \{0, 1, 2, 3, 4, 5, 6\}$. Note that all these variants only differ in inference time while sharing the same model weights. Besides, we report the performance of *CoT* and *no-CoT* as references.

To address the issue of forgetting earlier training stages, we modify the original multi-stage training curriculum by always mixing data from other stages with a certain probability ($p=0.3$). This updated training curriculum yields similar performance and enables effective control over the switch between latent and language reasoning.

**Metrics.** We apply two sets of evaluation metrics. One of them is based on the correctness of the *final answer*, regardless of the reasoning process. It is the metric used in the main experimental results above (Section ). To enable fine-grained analysis, we define another metric on the *reasoning process*. Assuming we have a complete language reasoning chain which specifies a path in the graph, we can classify it into (1) **Correct Path**: The output is one of the shortest paths to the correct answer. (2) **Longer Path**: A valid path that correctly answers the question but is longer than the shortest path. (3) **Hallucination**: The path includes nonexistent edges or is disconnected. (4) **Wrong Target**: A valid path in the graph, but the destination node is not the one being asked. These four categories naturally apply to the output from <span class="smallcaps">Coconut</span>($k=0$) and *CoT*, which generate the full path. For <span class="smallcaps">Coconut</span> with $k>0$ that outputs only partial paths in language (with the initial steps in continuous reasoning), we classify the reasoning as a Correct Path *if a valid explanation can complete it*. Also, we define Longer Path and Wrong Target for partial paths similarly. If no valid explanation completes the path, it’s classified as hallucination. In *no-CoT* and <span class="smallcaps">Coconut</span> with larger $k$, the model may only output the final answer without any partial path, and it falls into (5) **Correct Label** or (6) **Incorrect Label**. These six categories cover all cases without overlap.

<figure id="fig:analysis">
<span class="image placeholder" data-original-image-src="figures/figure_5_revised_1111.png" data-original-image-title="" width="\linewidth"></span>
<figcaption>The accuracy of final answer (left) and reasoning process (right) of multiple variants of <span class="smallcaps">Coconut</span> and baselines on ProsQA.</figcaption>
</figure>

<figure id="fig:height">
<span class="image placeholder" data-original-image-src="figures/figure_6_meta_3.png" data-original-image-title="" width="1\linewidth"></span>
<span class="image placeholder" data-original-image-src="figures/figure_7_meta_4.png" data-original-image-title="" width="\linewidth"></span>
<figcaption>An illustration of the latent search trees. The example is the same test case as in Figure <span class="math inline">\(\ref{fig:interpret}\)</span>. The height of a node (denoted as <span class="math inline">\(h\)</span> in the figure) is defined as the longest distance to any leaf nodes in the graph. We show the probability of the first concept predicted by the model following latent thoughts (e.g., “lempus” in the left figure). It is calculated as the multiplication of the probability of all tokens within the concept conditioned on previous context (omitted in the figure for brevity). This metric can be interpreted as an implicit value function estimated by the model, assessing the potential of each node leading to the correct answer.</figcaption>
</figure>

## Interpolating between Latent and Language Reasoning

Figure  shows a comparative analysis of different reasoning methods on ProsQA. As more reasoning is done with continuous thoughts (increasing $k$), both final answer accuracy (Figure , left) and the rate of correct reasoning processes (“Correct Label” and “Correct Path” in Figure , right) improve. Additionally, the rate of “Hallucination” and “Wrong Target” decrease, which typically occur when the model makes a wrong move earlier. This also indicates the better planning ability when more reasoning happens in the latent space.

A case study is shown in Figure , where *CoT* hallucinates an nonexistent edge, <span class="smallcaps">Coconut</span>($k=1$) leads to a wrong target, but <span class="smallcaps">Coconut</span>($k=2$) successfully solves the problem. In this example, the model cannot accurately determine which edge to choose at the earlier step. However, as latent reasoning can avoid making a hard choice upfront, the model can progressively eliminate incorrect options in subsequent steps and achieves higher accuracy at the end of reasoning. We show more evidence and details of this reasoning process in Section .

The comparison between *CoT* and <span class="smallcaps">Coconut</span>($k=0$) reveals another interesting observation: even when <span class="smallcaps">Coconut</span> is forced to generate a complete reasoning chain, the accuracy of the answers is still higher than *CoT*. The generated reasoning paths are also more accurate with less hallucination. From this, we can infer that the training method of mixing different stages improves the model’s ability to plan ahead. The training objective of *CoT* always concentrates on the generation of the immediate next step, making the model “shortsighted”. In later stages of <span class="smallcaps">Coconut</span> training, the first few steps are hidden, allowing the model to focus more on future steps. This is related to the findings of , where they propose multi-token prediction as a new pretraining objective to improve the LLM’s ability to plan ahead.

## Interpreting the Latent Search Tree

Given the intuition that continuous thoughts can encode multiple potential next steps, the latent reasoning can be interpreted as a search tree, rather than merely a reasoning “chain”. Taking the case of Figure  as a concrete example, the first step could be selecting one of the children of *Alex*, i.e., *{lempus, sterpus, zhorpus, grimpus}*. We depict all possible branches in the left part of Figure . Similarly, in the second step, the frontier nodes will be the grandchildren of *Alex* (Figure , right).

Unlike a standard breadth-first search (BFS), which explores all frontier nodes uniformly, the model demonstrates the ability to prioritize promising nodes while pruning less relevant ones. To uncover the model’s preferences, we analyze its subsequent outputs in language space. For instance, if the model is forced to switch back to language space after a single latent thought ($k=1$), it predicts the next step in a structured format, such as “every \[Concept A\] is a \[Concept B\].” By examining the probability distribution over potential fillers for \[Concept A\], we can derive numeric values for the children of the root node *Alex* (Figure , left). Similarly, when $k=2$, the prediction probabilities for all frontier nodes—the grandchildren of *Alex*—are obtained (Figure , right).

<figure id="fig:percentile">
<span class="image placeholder" data-original-image-src="figures/percentile.png" data-original-image-title="" width="\linewidth"></span>
<figcaption>Analysis of parallelism in latent tree search. The left plot depicts the cumulative value of the top-1, top-2, and top-3 candidate nodes for the first thoughts, calculated across test cases and ranked by percentile. The significant gaps between the lines reflect the model’s ability to explore alternative latent thoughts in parallel. The right plot shows the corresponding analysis for the second thoughts, where the gaps between lines are narrower, indicating reduced parallelism and increased certainty in reasoning as the search tree develops. This shift highlights the model’s transition toward more focused exploration in later stages.</figcaption>
</figure>

The probability distribution can be viewed as the model’s implicit *value function*, estimating each node’s potential to reach the target. As shown in the figure, “lempus”, “zhorpus”, “grimpus”, and “sterpus” have a value of 0.33, 0.16, 0.32, and 0.01, respectively. This indicates that in the first continuous thought, the model has mostly ruled out “sterpus” as an option but remains uncertain about the correct choice among the other three. In the second thought, however, the model has mostly ruled out other options but focused on “rorpus”.

Figure  presents an analysis of the parallelism in the model’s latent reasoning across the first and second thoughts. For the first thoughts (left panel), the cumulative values of the top-1, top-2, and top-3 candidate nodes are computed and plotted against their respective percentiles across the test set. The noticeable gaps between the three lines indicate that the model maintains significant diversity in its reasoning paths at this stage, suggesting a broad exploration of alternative possibilities. In contrast, the second thoughts (right panel) show a narrowing of these gaps. This trend suggests that the model transitions from parallel exploration to more focused reasoning in the second latent reasoning step, likely as it gains more certainty about the most promising paths.

## Why is a Latent Space Better for Planning?

In this section, we explore why latent reasoning is advantageous for planning, drawing on the search tree perspective and the value function defined earlier. Referring to our illustrative example, a key distinction between *“sterpus”* and the other three options lies in the structure of the search tree: *“sterpus”* is a leaf node (Figure ). This makes it immediately identifiable as an incorrect choice, as it cannot lead to the target node *“bompus”*. In contrast, the other nodes have more descendants to explore, making their evaluation more challenging.

To quantify a node’s exploratory potential, we measure its height in the tree, defined as the shortest distance to any leaf node. Based on this notion, we hypothesize that *nodes with lower heights are easier to evaluate accurately*, as their exploratory potential is limited. Consistent with this hypothesis, in our example, the model exhibits greater uncertainty between *“grimpus”* and *“lempus”*, both of which have a height of 2—higher than the other candidates.

To test this hypothesis more rigorously, we analyze the correlation between the model’s prediction probabilities and node heights during the first and second latent reasoning steps across the test set. Figure  reveals a clear pattern: the model successfully assigns lower values to incorrect nodes and higher values to correct nodes when their heights are low. However, as node heights increase, this distinction becomes less pronounced, indicating greater difficulty in accurate evaluation.

In conclusion, these findings highlight the benefits of leveraging latent space for planning. By delaying definite decisions and expanding the latent reasoning process, the model pushes its exploration closer to the search tree’s terminal states, making it easier to distinguish correct nodes from incorrect ones.

# Conclusion

In this paper, we presented <span class="smallcaps">Coconut</span>, a novel paradigm for reasoning in continuous latent space. Through extensive experiments, we demonstrated that <span class="smallcaps">Coconut</span> significantly enhances LLM reasoning capabilities. Notably, our detailed analysis highlighted how an unconstrained latent space allows the model to develop an effective reasoning pattern similar to BFS. Future work is needed to further refine and scale latent reasoning methods. One promising direction is pretraining LLMs with continuous thoughts, which may enable models to generalize more effectively across a wider range of reasoning scenarios. We anticipate that our findings will inspire further research into latent reasoning methods, ultimately contributing to the development of more advanced machine reasoning systems.

Acknowledgement

The authors express their sincere gratitude to Jihoon Tack for his valuable discussions throughout the course of this work.

# Datasets

## Examples

We provide some examples of the questions and CoT solutions for the datasets used in our experiments.

## Construction of ProsQA

To construct the dataset, we first compile a set of typical entity names, such as “Alex” and “Jack,” along with fictional concept names like “lorpus” and “rorpus,” following the setting of ProntoQA . Each problem is structured as a binary question: “Is \[Entity\] a \[Concept A\] or \[Concept B\]?” Assuming \[Concept A\] is the correct answer, we build a directed acyclic graph (DAG) where each node represents an entity or a concept. The graph is constructed such that a path exists from \[Entity\] to \[Concept A\] but not to \[Concept B\].

Algorithm  describes the graph construction process. The DAG is incrementally built by adding nodes and randomly connecting them with edges. To preserve the validity of the binary choice, with some probability, we enforce that the new node cannot simultaneously serve as a descendant to both node $0$ and $1$. This separation maintains distinct families of nodes and balances their sizes to prevent model shortcuts.

After the graph is constructed, nodes without parents are assigned entity names, while other nodes receive concept names. To formulate a question of the form “Is \[Entity\] a \[Concept A\] or \[Concept B\]?”, we designate node $0$ in the graph as \[Entity\], a leaf node labeled $1$ as \[Concept A\], and a leaf node labeled $2$ as \[Concept B\]. This setup ensures a path from \[Entity\] to \[Concept A\] without any connection to \[Concept B\], introducing a moderately complex reasoning path. Finally, to avoid positional biases, \[Concept A\] and \[Concept B\] are randomly permuted in each question.

<div id="tab:prosqa">

| \# Nodes | \# Edges | Len. of Shortest Path | \# Shortest Paths |
|:--------:|:--------:|:---------------------:|:-----------------:|
|   23.0   |   36.0   |          3.8          |        1.6        |

Statistics of the graph structure in ProsQA.

</div>

## Statistics

We show the size of all datasets in Table .

<div id="tab:stats">

|  Dataset | Training | Validation | Test |
|---------:|:--------:|:----------:|:----:|
|    GSM8k | 385,620  |    500     | 1319 |
| ProntoQA |  9,000   |    200     | 800  |
|   ProsQA |  17,886  |    300     | 500  |

Statistics of the datasets.

</div>

# Clock-Time Reasoning Efficiency Metric

We present a clock-time comparison to evaluate reasoning efficiency. The reported values represent the average inference time per test case (in seconds), with a batch size of 1, measured on an Nvidia A100 GPU. For the no-CoT and CoT baselines, we employ the standard generate method from the `transformers`[^3] library. Our results show that clock time is generally proportional to the number of newly generated tokens, as detailed in Table .

| Method                                 | GSM8k | ProntoQA | ProsQA |
|:---------------------------------------|:-----:|:--------:|:------:|
| No-CoT                                 | 0.03  |   0.03   |  0.08  |
| CoT                                    | 0.26  |   0.85   |  0.47  |
| <span class="smallcaps">Coconut</span> | 0.09  |   0.11   |  0.15  |

Inference time (in seconds) comparison across tasks and methods.

# Using More Continuous Thoughts

In Figure , we present the performance of <span class="smallcaps">Coconut</span> on GSM8k using $c \in \{0, 1, 2\}$. When experimenting with $c=3$, we observe a slight performance drop accompanied by increased variance. Analysis of the training logs indicates that adding three continuous thoughts at once – particularly during the final stage transition – leads to a sharp spike in training loss, causing instability. Future work will explore finer-grained schedules, such as incrementally adding continuous thoughts one at a time while removing fewer language tokens, as in iCoT . Additionally, combining language and latent reasoning—e.g., generating the reasoning skeleton in language and completing the reasoning process in latent space—could provide a promising direction for improving performance and stability.

[^1]: If a language reasoning chain is shorter than $k$ steps, then all the language thoughts will be removed.

[^2]: We discuss the case of larger $c$ in Appendix .

[^3]: <https://github.com/huggingface/transformers>
