---
abstract: |
  A central problem in machine learning involves modeling complex data-sets using highly flexible families of probability distributions in which learning, sampling, inference, and evaluation are still analytically or computationally tractable. Here, we develop an approach that simultaneously achieves both flexibility and tractability. The essential idea, inspired by non-equilibrium statistical physics, is to systematically and slowly destroy structure in a data distribution through an iterative forward diffusion process. We then learn a reverse diffusion process that restores structure in data, yielding a highly flexible and tractable generative model of the data. This approach allows us to rapidly learn, sample from, and evaluate probabilities in deep generative models with thousands of layers or time steps, as well as to compute conditional and posterior probabilities under the learned model. We additionally release an open source reference implementation of the algorithm.
bibliography:
- icml2015_dpm.bib
citation-style: ieee
header-includes:
- 
- 
link-citations: true
reference-section-title: References
---





### Introduction

Historically, probabilistic models suffer from a tradeoff between two conflicting objectives: *tractability* and *flexibility*. Models that are *tractable* can be analytically evaluated and easily fit to data (e.g. a Gaussian or Laplace). However, these models are unable to aptly describe structure in rich datasets. On the other hand, models that are *flexible* can be molded to fit structure in arbitrary data. For example, we can define models in terms of any (non-negative) function $\phi(\mathbf x)$ yielding the flexible distribution $p\left(\mathbf x\right) = \frac{\phi\left(\mathbf x
\right)}{Z}$, where $Z$ is a normalization constant. However, computing this normalization constant is generally intractable. Evaluating, training, or drawing samples from such flexible models typically requires a very expensive Monte Carlo process.

A variety of analytic approximations exist which ameliorate, but do not remove, this tradeoff–for instance mean field theory and its expansions , variational Bayes , contrastive divergence , minimum probability flow , minimum KL contraction , proper scoring rules , score matching , pseudolikelihood , loopy belief propagation , and many, many more. Non-parametric methods can also be very effective[^1].

#### Diffusion probabilistic models

We present a novel way to define probabilistic models that allows:  

1.  extreme flexibility in model structure,

2.  exact sampling,

3.  easy multiplication with other distributions, e.g. in order to compute a posterior, and

4.  the model log likelihood, and the probability of individual states, to be cheaply evaluated.

   
Our method uses a Markov chain to gradually convert one distribution into another, an idea used in non-equilibrium statistical physics and sequential Monte Carlo . We build a generative Markov chain which converts a simple known distribution (e.g. a Gaussian) into a target (data) distribution using a diffusion process. Rather than use this Markov chain to approximately evaluate a model which has been otherwise defined, we explicitly define the probabilistic model as the endpoint of the Markov chain. Since each step in the diffusion chain has an analytically evaluable probability, the full chain can also be analytically evaluated.

Learning in this framework involves estimating small perturbations to a diffusion process. Estimating small perturbations is more tractable than explicitly describing the full distribution with a single, non-analytically-normalizable, potential function. Furthermore, since a diffusion process exists for any smooth target distribution, this method can capture data distributions of arbitrary form.

We demonstrate the utility of these *diffusion probabilistic models* by training high log likelihood models for a two-dimensional swiss roll, binary sequence, handwritten digit (MNIST), and several natural image (CIFAR-10, bark, and dead leaves) datasets.

#### Relationship to other work

The wake-sleep algorithm introduced the idea of training inference and generative probabilistic models against each other. This approach remained largely unexplored for nearly two decades, though with some exceptions . There has been a recent explosion of work developing this idea. In variational learning and inference algorithms were developed which allow a flexible generative model and posterior distribution over latent variables to be directly trained against each other.

The variational bound in these papers is similar to the one used in our training objective and in the earlier work of . However, our motivation and model form are both quite different, and the present work retains the following differences and advantages relative to these techniques:  

1.  We develop our framework using ideas from physics, quasi-static processes, and annealed importance sampling rather than from variational Bayesian methods.

2.  We show how to easily multiply the learned distribution with another probability distribution (eg with a conditional distribution in order to compute a posterior)

3.  We address the difficulty that training the inference model can prove particularly challenging in variational inference methods, due to the asymmetry in the objective between the inference and generative models. We restrict the forward (inference) process to a simple functional form, in such a way that the reverse (generative) process will have the same functional form.

4.  We train models with thousands of layers (or time steps), rather than only a handful of layers.

5.  We provide upper and lower bounds on the entropy production in each layer (or time step)

   
There are a number of related techniques for training probabilistic models (summarized below) that develop highly flexible forms for generative models, train stochastic trajectories, or learn the reversal of a Bayesian network. Reweighted wake-sleep develops extensions and improved learning rules for the original wake-sleep algorithm. Generative stochastic networks train a Markov kernel to match its equilibrium distribution to the data distribution. Neural autoregressive distribution estimators (and their recurrent and deep extensions) decompose a joint distribution into a sequence of tractable conditional distributions over each dimension. Adversarial networks train a generative model against a classifier which attempts to distinguish generated samples from true data. A similar objective in learns a two-way mapping to a representation with marginally independent units. In bijective deterministic maps are learned to a latent representation with a simple factorial density function. In stochastic inverses are learned for Bayesian networks. Mixtures of conditional Gaussian scale mixtures (MCGSMs) describe a dataset using Gaussian scale mixtures, with parameters which depend on a sequence of causal neighborhoods. There is additionally significant work learning flexible generative mappings from simple latent distributions to data distributions – early examples including where neural networks are introduced as generative models, and where a stochastic manifold mapping is learned from a latent space to the data space. We will compare experimentally against adversarial networks and MCGSMs.

Related ideas from physics include the Jarzynski equality , known in machine learning as Annealed Importance Sampling (AIS) , which uses a Markov chain which slowly converts one distribution into another to compute a ratio of normalizing constants. In it is shown that AIS can also be performed using the reverse rather than forward trajectory. Langevin dynamics , which are the stochastic realization of the Fokker-Planck equation, show how to define a Gaussian diffusion process which has any target distribution as its equilibrium. In the Fokker-Planck equation is used to perform stochastic optimization. Finally, the Kolmogorov forward and backward equations show that for many forward diffusion processes, the reverse diffusion processes can be described using the same functional form.

### Algorithm

Our goal is to define a forward (or inference) diffusion process which converts any complex data distribution into a simple, tractable, distribution, and then learn a finite-time reversal of this diffusion process which defines our generative model distribution (See Figure ). We first describe the forward, inference diffusion process. We then show how the reverse, generative diffusion process can be trained and used to evaluate probabilities. We also derive entropy bounds for the reverse process, and show how the learned distributions can be multiplied by any second distribution (e.g. as would be done to compute a posterior when inpainting or denoising an image).

#### Forward Trajectory

We label the data distribution $q \left( \mathbf x^{(0)} \right)$. The data distribution is gradually converted into a well behaved (analytically tractable) distribution $\pi\left( \mathbf y \right)$ by repeated application of a Markov diffusion kernel $T_\pi\left( \mathbf y | \mathbf y'; \beta \right)$ for $\pi\left( \mathbf y \right)$, where $\beta$ is the diffusion rate, $$\begin{aligned}
\pi\left( \mathbf y \right) &= \int d\mathbf y' T_\pi\left( \mathbf y | \mathbf y'; \beta \right) \pi\left( \mathbf y' \right) \\
q\left( \mathbf x^{(t)} | \mathbf x^{(t-1)} \right)&= T_\pi\left( \mathbf x^{(t)} | \mathbf x^{(t-1)}; \beta_t \right)
.
\end{aligned}$$ The forward trajectory, corresponding to starting at the data distribution and performing $T$ steps of diffusion, is thus $$\begin{aligned}
q\left( \mathbf x^{(0\cdots T)} \right)&= q \left( \mathbf x^{(0)} \right)\prod_{t=1}^T q\left( \mathbf x^{(t)} | \mathbf x^{(t-1)} \right)
\end{aligned}$$ For the experiments shown below, $q\left( \mathbf x^{(t)} | \mathbf x^{(t-1)} \right)$ corresponds to either Gaussian diffusion into a Gaussian distribution with identity-covariance, or binomial diffusion into an independent binomial distribution. Table gives the diffusion kernels for both Gaussian and binomial distributions.

#### Reverse Trajectory

The generative distribution will be trained to describe the same trajectory, but in reverse, $$\begin{aligned}
p \left( \mathbf x^{(T)} \right)&= \pi\left( \mathbf x^{(T)} \right)\\
p\left( \mathbf x^{(0\cdots T)} \right)&= p \left( \mathbf x^{(T)} \right)\prod_{t=1}^T p\left( \mathbf x^{(t-1)} | \mathbf x^{(t)} \right)
.
\end{aligned}$$ For both Gaussian and binomial diffusion, for continuous diffusion (limit of small step size $\beta$) the reversal of the diffusion process has the identical functional form as the forward process . Since $q\left( \mathbf x^{(t)} | \mathbf x^{(t-1)} \right)$ is a Gaussian (binomial) distribution, and if $\beta_t$ is small, then $q\left( \mathbf x^{(t-1)} | \mathbf x^{(t)} \right)$ will also be a Gaussian (binomial) distribution. The longer the trajectory the smaller the diffusion rate $\beta$ can be made.

During learning only the mean and covariance for a Gaussian diffusion kernel, or the bit flip probability for a binomial kernel, need be estimated. As shown in Table , $\mathbf f_\mu\left( \mathbf x^{(t)}, t \right)$ and $\mathbf f_\Sigma\left( \mathbf x^{(t)}, t \right)$ are functions defining the mean and covariance of the reverse Markov transitions for a Gaussian, and $\mathbf f_b\left( \mathbf x^{(t)}, t \right)$ is a function providing the bit flip probability for a binomial distribution. The computational cost of running this algorithm is the cost of these functions, times the number of time-steps. For all results in this paper, multi-layer perceptrons are used to define these functions. A wide range of regression or function fitting techniques would be applicable however, including nonparameteric methods.

#### Model Probability

The probability the generative model assigns to the data is $$\begin{aligned}
p\left( \mathbf x^{(0)} \right) &= \int d\mathbf x^{(1\cdots T)} p\left( \mathbf x^{(0\cdots T)} \right)
.
\end{aligned}$$ Naively this integral is intractable – but taking a cue from annealed importance sampling and the Jarzynski equality, we instead evaluate the relative probability of the forward and reverse trajectories, averaged over forward trajectories, $$\begin{aligned}
p\left( \mathbf x^{(0)} \right)&= \int d\mathbf x^{(1\cdots T)} p\left( \mathbf x^{(0\cdots T)} \right)\frac{q\left( \mathbf x^{(1\cdots T)} | \mathbf x^{(0)} \right)}{q\left( \mathbf x^{(1\cdots T)} | \mathbf x^{(0)} \right)} \\
&= \int d\mathbf x^{(1\cdots T)} q\left( \mathbf x^{(1\cdots T)} | \mathbf x^{(0)} \right)\frac{p\left( \mathbf x^{(0\cdots T)} \right)}{q\left( \mathbf x^{(1\cdots T)} | \mathbf x^{(0)} \right)} \\
&= \int d\mathbf x^{(1\cdots T)} q\left( \mathbf x^{(1\cdots T)} | \mathbf x^{(0)} \right)\cdot \nonumber \\ &\qquad \quad p \left( \mathbf x^{(T)} \right)\prod_{t=1}^T \frac{p\left( \mathbf x^{(t-1)} | \mathbf x^{(t)} \right)}{q\left( \mathbf x^{(t)} | \mathbf x^{(t-1)} \right)}
.
\end{aligned}$$ This can be evaluated rapidly by averaging over samples from the forward trajectory $q\left( \mathbf x^{(1\cdots T)} | \mathbf x^{(0)} \right)$. For infinitesimal $\beta$ the forward and reverse distribution over trajectories can be made identical (see Section ). If they are identical then only a *single* sample from $q\left( \mathbf x^{(1\cdots T)} | \mathbf x^{(0)} \right)$ is required to exactly evaluate the above integral, as can be seen by substitution. This corresponds to the case of a quasi-static process in statistical physics .

#### Training

Training amounts to maximizing the model log likelihood,  
$$\begin{aligned}
L &= \int d\mathbf x^{(0)} q \left( \mathbf x^{(0)} \right)\log p\left( \mathbf x^{(0)} \right)\\
&= \int d\mathbf x^{(0)} q \left( \mathbf x^{(0)} \right)\cdot \nonumber \\ & \qquad \log \left[
    \begin{array}{l}
         \int d\mathbf x^{(1\cdots T)} q\left( \mathbf x^{(1\cdots T)} | \mathbf x^{(0)} \right)\cdot \\
        \qquad p \left( \mathbf x^{(T)} \right)\prod_{t=1}^T \frac{p\left( \mathbf x^{(t-1)} | \mathbf x^{(t)} \right)}{q\left( \mathbf x^{(t)} | \mathbf x^{(t-1)} \right)}
    \end{array}
     \right] \label{eq pre jen},
\end{aligned}$$ which has a lower bound provided by Jensen’s inequality, $$\begin{aligned}
L &\geq \int d\mathbf x^{(0 \cdots T)} q\left( \mathbf x^{(0\cdots T)} \right)\cdot \nonumber \\ & \qquad \log \left[ p \left( \mathbf x^{(T)} \right)\prod_{t=1}^T \frac{p\left( \mathbf x^{(t-1)} | \mathbf x^{(t)} \right)}{q\left( \mathbf x^{(t)} | \mathbf x^{(t-1)} \right)} \right] \label{eq post jen}
.
\end{aligned}$$ As described in Appendix , for our diffusion trajectories this reduces to, $$\begin{aligned}
L
&\geq K \label{eq ineq LK}\\
K = & 
-\sum_{t=2}^T \int d\mathbf x^{(0)}d\mathbf x^{(t)} q\left( \mathbf x^{(0)}, \mathbf x^{(t)} \right) \cdot
\nonumber\\  & \qquad \qquad
    D_{KL}\left( 
        q\left( \mathbf x^{(t-1)} | \mathbf x^{(t)}, \mathbf x^{(0)} \right)
            \middle|\middle|
        p\left( \mathbf x^{(t-1)} | \mathbf x^{(t)} \right)
    \right)  \nonumber \\
&   + H_q\left( \mathbf X^{(T)} | \mathbf X^{(0)} \right) - H_q\left( \mathbf X^{(1)} | \mathbf X^{(0)} \right)
    - H_p\left( \mathbf X^{(T)} \right)
.
\end{aligned}$$ where the entropies and KL divergences can be analytically computed. The derivation of this bound parallels the derivation of the log likelihood bound in variational Bayesian methods.

As in Section if the forward and reverse trajectories are identical, corresponding to a quasi-static process, then the inequality in Equation becomes an equality.

Training consists of finding the reverse Markov transitions which maximize this lower bound on the log likelihood, $$\begin{aligned}
\hat{p}\left( \mathbf x^{(t-1)} | \mathbf x^{(t)} \right)&= \operatornamewithlimits{argmax}_{p\left( \mathbf x^{(t-1)} | \mathbf x^{(t)} \right)}
    K 
    %\int d\mb x^{(0 \cdots T)} \ptraj \sum_{t=1}^T \log \qr
.
\end{aligned}$$ The specific targets of estimation for Gaussian and binomial diffusion are given in Table .

Thus, the task of estimating a probability distribution has been reduced to the task of performing regression on the functions which set the mean and covariance of a sequence of Gaussians (or set the state flip probability for a sequence of Bernoulli trials).

##### Setting the Diffusion Rate $\beta_t$

The choice of $\beta_t$ in the forward trajectory is important for the performance of the trained model. In AIS, the right schedule of intermediate distributions can greatly improve the accuracy of the log partition function estimate . In thermodynamics the schedule taken when moving between equilibrium distributions determines how much free energy is lost .

In the case of Gaussian diffusion, we learn[^2] the forward diffusion schedule $\beta_{2\cdots T}$ by gradient ascent on $K$. The variance $\beta_1$ of the first step is fixed to a small constant to prevent overfitting. The dependence of samples from $q\left( \mathbf x^{(1\cdots T)} | \mathbf x^{(0)} \right)$ on $\beta_{1\cdots T}$ is made explicit by using ‘frozen noise’ – as in the noise is treated as an additional auxiliary variable, and held constant while computing partial derivatives of $K$ with respect to the parameters.

For binomial diffusion, the discrete state space makes gradient ascent with frozen noise impossible. We instead choose the forward diffusion schedule $\beta_{1\cdots T}$ to erase a constant fraction $\frac{1}{T}$ of the original signal per diffusion step, yielding a diffusion rate of $\beta_t = \left( T-t +1\right)^{-1}$.

#### Multiplying Distributions, and Computing Posteriors

Tasks such as computing a posterior in order to do signal denoising or inference of missing values requires multiplication of the model distribution $p\left( \mathbf x^{(0)} \right)$ with a second distribution, or bounded positive function, $r\left(\mathbf x^{(0)} \right)$, producing a new distribution $\tilde{p}\left(\mathbf x^{(0)} \right) \propto p\left( \mathbf x^{(0)} \right)r\left(\mathbf x^{(0)} \right)$.

Multiplying distributions is costly and difficult for many techniques, including variational autoencoders, GSNs, NADEs, and most graphical models. However, under a diffusion model it is straightforward, since the second distribution can be treated either as a small perturbation to each step in the diffusion process, or often exactly multiplied into each diffusion step. Figures and demonstrate the use of a diffusion model to perform denoising and inpainting of natural images. The following sections describe how to multiply distributions in the context of diffusion probabilistic models.

##### Modified Marginal Distributions

First, in order to compute $\tilde{p}\left(\mathbf x^{(0)} \right)$, we multiply each of the intermediate distributions by a corresponding function $r
\left( \mathbf x^{(t)} \right)$. We use a tilde above a distribution or Markov transition to denote that it belongs to a trajectory that has been modified in this way. $\tilde{p}\left( \mathbf x^{(0\cdots T)} \right)$ is the modified reverse trajectory, which starts at the distribution $\tilde{p}\left( \mathbf x^{(T)} \right) = \frac{1}{\tilde{Z}_T} p\left( \mathbf x^{(T)} \right) r\left( \mathbf x^{(T)} \right)$ and proceeds through the sequence of intermediate distributions $$\begin{aligned}
\tilde{p} \left( \mathbf x^{(t)} \right) 
    & = 
\frac{1}{\tilde{Z}_t} p\left(\mathbf x^{(t)} \right) r\left( \mathbf x^{(t)} \right)
\label{eq perturb marginals}
,
\end{aligned}$$ where $\tilde{Z}_t$ is the normalizing constant for the $t$th intermediate distribution.

##### Modified Diffusion Steps

The Markov kernel $p\left( \mathbf x^{(t)} \mid \mathbf x^{(t+1)}\right)$ for the reverse diffusion process obeys the equilibrium condition $$\begin{aligned}
p\left( \mathbf x^{(t} \right) &= \int d \mathbf x^{(t+1)} p\left( \mathbf x^{t)} \mid \mathbf x^{(t+1)} \right) p\left( \mathbf x^{t+1)} \right)
.
\end{aligned}$$ We wish the perturbed Markov kernel $\tilde{p}\left( \mathbf x^{(t)} \mid \mathbf x^{(t+1)}\right)$ to instead obey the equilibrium condition for the perturbed distribution, $$\begin{aligned}
\tilde{p}\left( \mathbf x^{(t)} \right) &= \int d \mathbf x^{(t+1)} \tilde{p}\left( \mathbf x^{(t)} \mid \mathbf x^{(t+1)} \right) \tilde{p}\left( \mathbf x^{t+1)} \right), \\
\frac{
    p\left(\mathbf x^{(t)} \right) r\left( \mathbf x^{(t)} \right)
    }{\tilde{Z}_t}
&= \int d \mathbf x^{(t+1)} \tilde{p}\left( \mathbf x^{(t)} \mid \mathbf x^{(t+1)} \right) 
\cdot \nonumber\\  & \qquad \qquad
    \frac{
    p\left(\mathbf x^{(t+1)} \right) r\left( \mathbf x^{(t+1)} \right)
    }{\tilde{Z}_{t+1}}
,\\
p\left(\mathbf x^{(t)} \right)
&= \int d \mathbf x^{(t+1)} \tilde{p}\left( \mathbf x^{(t)} \mid \mathbf x^{(t+1)} \right) 
\cdot \nonumber\\  & \qquad \qquad
    \frac{
        \tilde{Z}_t r\left( \mathbf x^{(t+1)} \right)
    }{
        \tilde{Z}_{t+1} r\left( \mathbf x^{(t)} \right)
    } p\left(\mathbf x^{(t+1)} \right)
    \label{eq tild fixed point}
.
\end{aligned}$$

Equation will be satisfied if $$\begin{aligned}
\tilde{p}\left( \mathbf x^{(t)} | \mathbf x^{(t+1)} \right) &= p\left( \mathbf x^{(t)} | \mathbf x^{(t+1)} \right) 
    \frac{
        \tilde{Z}_{t+1} r\left( \mathbf x^{(t)} \right)
    }{
        \tilde{Z}_t r\left( \mathbf x^{(t+1)} \right)
    }
\label{eq tild unnorm}
.
\end{aligned}$$ Equation may not correspond to a normalized probability distribution, so we choose $\tilde{p}\left( \mathbf x^{(t)} | \mathbf x^{(t+1)} \right)$ to be the corresponding normalized distribution $$\begin{aligned}
\tilde{p}\left( \mathbf x^{(t)} | \mathbf x^{(t+1)} \right) &= \frac{1}{\tilde{Z}_t\left( \mathbf x^{(t+1)} \right)} p\left( \mathbf x^{(t)} | \mathbf x^{(t+1)} \right) r\left( \mathbf x^{(t)} \right)
\label{eq tild norm}
,
\end{aligned}$$ where $\tilde{Z}_t\left( \mathbf x^{(t+1)} \right)$ is the normalization constant.

For a Gaussian, each diffusion step is typically very sharply peaked relative to $r\left( \mathbf x^{(t)} \right)$, due to its small variance. This means that $\frac{
        r\left( \mathbf x^{(t)} \right)
    }{
        r\left( \mathbf x^{(t+1)} \right)
    }$ can be treated as a small perturbation to $p\left( \mathbf x^{(t)} | \mathbf x^{(t+1)} \right)$. A small perturbation to a Gaussian effects the mean, but not the normalization constant, so in this case Equations and are equivalent (see Appendix ).

##### Applying $r\left( \mathbf x^{(t)} \right)$

If $r\left( \mathbf x^{(t)} \right)$ is sufficiently smooth, then it can be treated as a small perturbation to the reverse diffusion kernel $p\left( \mathbf x^{(t)} | \mathbf x^{(t+1)} \right)$. In this case $\tilde{p}\left( \mathbf x^{(t)} | \mathbf x^{(t+1)} \right)$ will have an identical functional form to $p\left( \mathbf x^{(t)} | \mathbf x^{(t+1)} \right)$, but with perturbed mean for the Gaussian kernel, or with perturbed flip rate for the binomial kernel. The perturbed diffusion kernels are given in Table , and are derived for the Gaussian in Appendix .

If $r\left( \mathbf x^{(t)} \right)$ can be multiplied with a Gaussian (or binomial) distribution in closed form, then it can be directly multiplied with the reverse diffusion kernel $p\left( \mathbf x^{(t)} | \mathbf x^{(t+1)} \right)$ in closed form. This applies in the case where $r\left( \mathbf x^{(t)} \right)$ consists of a delta function for some subset of coordinates, as in the inpainting example in Figure .

##### Choosing $r\left( \mathbf x^{(t)} \right)$

Typically, $r\left( \mathbf x^{(t)} \right)$ should be chosen to change slowly over the course of the trajectory. For the experiments in this paper we chose it to be constant, $$\begin{aligned}
r\left( \mathbf x^{(t)} \right) &= r\left( \mathbf x^{(0)} \right).
\end{aligned}$$ Another convenient choice is $r\left( \mathbf x^{(t)} \right) = r\left( \mathbf x^{(0)} \right)^\frac{T-t}{T}$. Under this second choice $r\left( \mathbf x^{(t)} \right)$ makes no contribution to the starting distribution for the reverse trajectory. This guarantees that drawing the initial sample from $\tilde{p}\left( \mathbf x^{(T)} \right)$ for the reverse trajectory remains straightforward.

#### Entropy of Reverse Process

Since the forward process is known, we can derive upper and lower bounds on the conditional entropy of each step in the reverse trajectory, and thus on the log likelihood, $$\begin{aligned}
H_q\left( \mathbf X^{(t)} | \mathbf X^{(t-1)} \right) + H_q\left( \mathbf X^{(t-1)} | \mathbf X^{(0)} \right)  - H_q\left( \mathbf X^{(t)} | \mathbf X^{(0)} \right) 
\nonumber \\ \qquad
 \le
H_q\left( \mathbf X^{(t-1)} | \mathbf X^{(t)} \right)
\le
H_q\left( \mathbf X^{(t)} | \mathbf X^{(t-1)} \right)
,
\end{aligned}$$ where both the upper and lower bounds depend only on $q\left( \mathbf x^{(1\cdots T)} | \mathbf x^{(0)} \right)$, and can be analytically computed. The derivation is provided in Appendix .

<div class="center">

| *Dataset*        | *$K$*                  | *$K - L_{null}$*        |
|:-----------------|:-----------------------|:------------------------|
| Swiss Roll       | 2.35 bits              | 6.45 bits               |
| Binary Heartbeat | -2.414 bits/seq.       | 12.024 bits/seq.        |
| Bark             | -0.55 bits/pixel       | 1.5 bits/pixel          |
| Dead Leaves      | 1.489 bits/pixel       | 3.536 bits/pixel        |
| CIFAR-10         | $5.4\pm0.2$ bits/pixel | $11.5\pm0.2$ bits/pixel |
| MNIST            | See table              |                         |

The lower bound $K$ on the log likelihood, computed on a holdout set, for each of the trained models. See Equation . The right column is the improvement relative to an isotropic Gaussian or independent binomial distribution. $L_{null}$ is the log likelihood of $\pi\left( \mathbf x^{(0)} \right)$. All datasets except for Binary Heartbeat were scaled by a constant to give them variance 1 before computing log likelihood.

</div>

<div class="center">

| *Model*             | *Log Likelihood*                |
|:--------------------|:--------------------------------|
| ***Dead Leaves***   |                                 |
|     MCGSM           | 1.244 bits/pixel                |
|     **Diffusion**   | **$\mathbf{1.489}$ bits/pixel** |
| ***MNIST***         |                                 |
|     Stacked CAE     | $174 \pm 2.3$ bits              |
|     DBN             | $199 \pm 2.9$ bits              |
|     Deep GSN        | $309 \pm 1.6$ bits              |
|     **Diffusion**   | **$\mathbf{317 \pm 2.7}$ bits** |
|     Adversarial net | $325 \pm 2.9$ bits              |
|     Perfect model   | $349 \pm 3.3$ bits              |

Log likelihood comparisons to other algorithms. Dead leaves images were evaluated using identical training and test data as in . MNIST log likelihoods were estimated using the Parzen-window code from , with values given in bits, and show that our performance is comparable to other recent techniques. The perfect model entry was computed by applying the Parzen code to samples from the training data.

</div>

### Experiments

We train diffusion probabilistic models on a variety of continuous datasets, and a binary dataset. We then demonstrate sampling from the trained model and inpainting of missing data, and compare model performance against other techniques. In all cases the objective function and gradient were computed using Theano . Model training was with SFO , except for CIFAR-10. CIFAR-10 results used the open source implementation of the algorithm, and RMSprop for optimization. The lower bound on the log likelihood provided by our model is reported for all datasets in Table . A reference implementation of the algorithm utilizing Blocks is available at <https://github.com/Sohl-Dickstein/Diffusion-Probabilistic-Models>.

#### Toy Problems

##### Swiss Roll

A diffusion probabilistic model was built of a two dimensional swiss roll distribution, using a radial basis function network to generate $\mathbf f_\mu\left( \mathbf x^{(t)}, t \right)$ and $\mathbf f_\Sigma\left( \mathbf x^{(t)}, t \right)$. As illustrated in Figure , the swiss roll distribution was successfully learned. See Appendix Section for more details.

##### Binary Heartbeat Distribution

A diffusion probabilistic model was trained on simple binary sequences of length 20, where a 1 occurs every 5th time bin, and the remainder of the bins are 0, using a multi-layer perceptron to generate the Bernoulli rates $\mathbf f_b\left( \mathbf x^{(t)}, t \right)$ of the reverse trajectory. The log likelihood under the true distribution is $\log_2\left( \frac{1}{5} \right) = -2.322$ bits per sequence. As can be seen in Figure and Table learning was nearly perfect. See Appendix Section for more details.

#### Images

We trained Gaussian diffusion probabilistic models on several image datasets. The multi-scale convolutional architecture shared by these experiments is described in Appendix Section , and illustrated in Figure .

##### Datasets

###### MNIST

In order to allow a direct comparison against previous work on a simple dataset, we trained on MNIST digits . Log likelihoods relative to are given in Table . Samples from the MNIST model are given in Appendix Figure . Our training algorithm provides an asymptotically consistent lower bound on the log likelihood. However most previous reported results on continuous MNIST log likelihood rely on Parzen-window based estimates computed from model samples. For this comparison we therefore estimate MNIST log likelihood using the Parzen-window code released with .

###### CIFAR-10

A probabilistic model was fit to the training images for the CIFAR-10 challenge dataset . Samples from the trained model are provided in Figure .

###### Dead Leaf Images

Dead leaf images consist of layered occluding circles, drawn from a power law distribution over scales. They have an analytically tractable structure, but capture many of the statistical complexities of natural images, and therefore provide a compelling test case for natural image models. As illustrated in Table and Figure , we achieve state of the art performance on the dead leaves dataset.

###### Bark Texture Images

A probabilistic model was trained on bark texture images (T01-T04) from . For this dataset we demonstrate that it is straightforward to evaluate or generate from a posterior distribution, by inpainting a large region of missing data using a sample from the model posterior in Figure .

### Conclusion

We have introduced a novel algorithm for modeling probability distributions that enables exact sampling and evaluation of probabilities and demonstrated its effectiveness on a variety of toy and real datasets, including challenging natural image datasets. For each of these tests we used a similar basic algorithm, showing that our method can accurately model a wide variety of distributions. Most existing density estimation techniques must sacrifice modeling power in order to stay tractable and efficient, and sampling or evaluation are often extremely expensive. The core of our algorithm consists of estimating the reversal of a Markov diffusion chain which maps data to a noise distribution; as the number of steps is made large, the reversal distribution of each diffusion step becomes simple and easy to estimate. The result is an algorithm that can learn a fit to any data distribution, but which remains tractable to train, *exactly* sample from, and evaluate, and under which it is straightforward to manipulate conditional and posterior distributions.

### Acknowledgements

We thank Lucas Theis, Subhaneil Lahiri, Ben Poole, Diederik P. Kingma, Taco Cohen, Philip Bachman, and Aäron van den Oord for extremely helpful discussion, and Ian Goodfellow for Parzen-window code. We thank Khan Academy and the Office of Naval Research for funding Jascha Sohl-Dickstein, and we thank the Office of Naval Research and the Burroughs-Wellcome, Sloan, and James S. McDonnell foundations for funding Surya Ganguli.

# Appendix

### Conditional Entropy Bounds Derivation

The conditional entropy $H_q\left( \mathbf X^{(t-1)} | \mathbf X^{(t)} \right)$ of a step in the reverse trajectory is $$\begin{aligned}
H_q\left( \mathbf X^{(t-1)}, \mathbf X^{(t)} \right) &= H_q\left( \mathbf X^{(t)}, \mathbf X^{(t-1)} \right) \\
H_q\left( \mathbf X^{(t-1)} | \mathbf X^{(t)} \right) + H_q\left( \mathbf X^{(t)} \right) &= H_q\left( \mathbf X^{(t)} | \mathbf X^{(t-1)} \right) + H_q\left( \mathbf X^{(t-1)} \right) \\
H_q\left( \mathbf X^{(t-1)} | \mathbf X^{(t)} \right) &= H_q\left( \mathbf X^{(t)} | \mathbf X^{(t-1)} \right) + H_q\left( \mathbf X^{(t-1)} \right) - H_q\left( \mathbf X^{(t)} \right) \label{eq cond equal}
\end{aligned}$$

An upper bound on the entropy change can be constructed by observing that $\pi\left( \mathbf y \right)$ is the maximum entropy distribution. This holds without qualification for the binomial distribution, and holds for variance 1 training data for the Gaussian case. For the Gaussian case, training data must therefore be scaled to have unit norm for the following equalities to hold. It need not be whitened. The upper bound is derived as follows, $$\begin{aligned}
H_q\left( \mathbf X^{(t)} \right) &\ge H_q\left( \mathbf X^{(t-1)} \right) \\
H_q\left( \mathbf X^{(t-1)} \right) - H_q\left( \mathbf X^{(t)} \right) &\le 0 \label{eq diff lb} \\
H_q\left( \mathbf X^{(t-1)} | \mathbf X^{(t)} \right) &\leq H_q\left( \mathbf X^{(t)} | \mathbf X^{(t-1)} \right)
.
\end{aligned}$$

A lower bound on the entropy difference can be established by observing that additional steps in a Markov chain do not increase the information available about the initial state in the chain, and thus do not decrease the conditional entropy of the initial state, $$\begin{aligned}
\hspace{-2cm}
H_q\left( \mathbf X^{(0)} | \mathbf X^{(t)} \right) &\ge H_q\left( \mathbf X^{(0)} | \mathbf X^{(t-1)} \right) \\
\hspace{-2cm}
H_q\left( \mathbf X^{(t-1)} \right) - H_q\left( \mathbf X^{(t)} \right) &\ge
    H_q\left( \mathbf X^{(0)} | \mathbf X^{(t-1)} \right) + H_q\left( \mathbf X^{(t-1)} \right) - H_q\left( \mathbf X^{(0)} | \mathbf X^{(t)} \right) - H_q\left( \mathbf X^{(t)} \right) \\
\hspace{-2cm}
H_q\left( \mathbf X^{(t-1)} \right) - H_q\left( \mathbf X^{(t)} \right) &\ge
    H_q\left( \mathbf X^{(0)}, \mathbf X^{(t-1)} \right) - H_q\left( \mathbf X^{(0)}, \mathbf X^{(t)} \right)  \\
\hspace{-2cm}
H_q\left( \mathbf X^{(t-1)} \right) - H_q\left( \mathbf X^{(t)} \right) &\ge
    H_q\left( \mathbf X^{(t-1)} | \mathbf X^{(0)} \right)  - H_q\left( \mathbf X^{(t)} | \mathbf X^{(0)} \right) \label{eq diff ub} \\
\hspace{-2cm}
H_q\left( \mathbf X^{(t-1)} | \mathbf X^{(t)} \right) &\ge H_q\left( \mathbf X^{(t)} | \mathbf X^{(t-1)} \right) + H_q\left( \mathbf X^{(t-1)} | \mathbf X^{(0)} \right)  - H_q\left( \mathbf X^{(t)} | \mathbf X^{(0)} \right)
.
\end{aligned}$$

Combining these expressions, we bound the conditional entropy for a single step, $$\begin{aligned}
H_q\left( \mathbf X^{(t)} | \mathbf X^{(t-1)} \right)
&\ge
H_q\left( \mathbf X^{(t-1)} | \mathbf X^{(t)} \right)
\ge
H_q\left( \mathbf X^{(t)} | \mathbf X^{(t-1)} \right) + H_q\left( \mathbf X^{(t-1)} | \mathbf X^{(0)} \right)  - H_q\left( \mathbf X^{(t)} | \mathbf X^{(0)} \right)
,
\end{aligned}$$ where both the upper and lower bounds depend only on the conditional forward trajectory $q\left( \mathbf x^{(1\cdots T)} | \mathbf x^{(0)} \right)$, and can be analytically computed.

### Log Likelihood Lower Bound

The lower bound on the log likelihood is $$\begin{aligned}
L
&\geq K \\
K &= \int d\mathbf x^{(0 \cdots T)} q\left( \mathbf x^{(0\cdots T)} \right)\log \left[ p \left( \mathbf x^{(T)} \right)\prod_{t=1}^T \frac{p\left( \mathbf x^{(t-1)} | \mathbf x^{(t)} \right)}{q\left( \mathbf x^{(t)} | \mathbf x^{(t-1)} \right)} \right] \\
\end{aligned}$$

#### Entropy of $p\left( \mathbf X^{(T)} \right)$

We can peel off the contribution from $p\left( \mathbf X^{(T)} \right)$, and rewrite it as an entropy, $$\begin{aligned}
K&= \int d\mathbf x^{(0 \cdots T)} q\left( \mathbf x^{(0\cdots T)} \right)\sum_{t=1}^T\log \left[ \frac{p\left( \mathbf x^{(t-1)} | \mathbf x^{(t)} \right)}{q\left( \mathbf x^{(t)} | \mathbf x^{(t-1)} \right)} \right] 
    + \int d\mathbf x^{(T)} q\left( \mathbf x^{(T)} \right)\log p \left( \mathbf x^{(T)} \right)\\
&= \int d\mathbf x^{(0 \cdots T)} q\left( \mathbf x^{(0\cdots T)} \right)\sum_{t=1}^T\log \left[ \frac{p\left( \mathbf x^{(t-1)} | \mathbf x^{(t)} \right)}{q\left( \mathbf x^{(t)} | \mathbf x^{(t-1)} \right)} \right] 
    + \int d\mathbf x^{(T)} q\left( \mathbf x^{(T)} \right)\log \pi\left( \mathbf x^T \right) \\
.
\end{aligned}$$ By design, the cross entropy to $\pi\left( \mathbf x^{(t)}\right)$ is constant under our diffusion kernels, and equal to the entropy of $p \left( \mathbf x^{(T)} \right)$. Therefore, $$\begin{aligned}
K &=
  \sum_{t=1}^T \int d\mathbf x^{(0 \cdots T)} q\left( \mathbf x^{(0\cdots T)} \right)\log \left[ \frac{p\left( \mathbf x^{(t-1)} | \mathbf x^{(t)} \right)}{q\left( \mathbf x^{(t)} | \mathbf x^{(t-1)} \right)} \right] 
    - H_p\left( \mathbf X^{(T)} \right).
\end{aligned}$$

#### Remove the edge effect at $t=0$

In order to avoid edge effects, we set the final step of the reverse trajectory to be identical to the corresponding forward diffusion step, $$\begin{aligned}
p\left( \mathbf x^{(0)} | \mathbf x^{(1)} \right) = q\left( \mathbf x^{(1)} | \mathbf x^{(0)} \right) \frac{ \pi\left( \mathbf x^{(0)}\right) }{ \pi\left( \mathbf x^{(1)}\right) } = T_\pi\left( \mathbf x^{(0)} | \mathbf x^{(1)}; \beta_1 \right).
\end{aligned}$$ We then use this equivalence to remove the contribution of the first time-step in the sum, $$\begin{aligned}
K
&=  \sum_{t=2}^T \int d\mathbf x^{(0 \cdots T)} q\left( \mathbf x^{(0\cdots T)} \right)\log \left[ \frac{p\left( \mathbf x^{(t-1)} | \mathbf x^{(t)} \right)}{q\left( \mathbf x^{(t)} | \mathbf x^{(t-1)} \right)} \right] 
    + \int d\mathbf x^{(0)} d\mathbf x^{(1)} q\left( \mathbf x^{(0)}, \mathbf x^{(1)} \right)  \log \left[ \frac{
        q\left( \mathbf x^{(1)} | \mathbf x^{(0)} \right) \pi\left( \mathbf x^{(0)}\right)
        }{
        q\left( \mathbf x^{(1)} | \mathbf x^{(0)} \right) \pi\left( \mathbf x^{(1)}\right)
        } \right]
    - H_p\left( \mathbf X^{(T)} \right)
    \\
&=  \sum_{t=2}^T \int d\mathbf x^{(0 \cdots T)} q\left( \mathbf x^{(0\cdots T)} \right)\log \left[ \frac{p\left( \mathbf x^{(t-1)} | \mathbf x^{(t)} \right)}{q\left( \mathbf x^{(t)} | \mathbf x^{(t-1)} \right)} \right] 
    - H_p\left( \mathbf X^{(T)} \right)
    ,
\end{aligned}$$ where we again used the fact that by design $-\int d\mathbf x^{(t)} q\left( \mathbf x^{(t)} \right) \log \pi\left( \mathbf x^{(t)}\right) = H_p\left( \mathbf X^{(T)} \right)$ is a constant for all $t$.

#### Rewrite in terms of posterior $q\left( \mathbf x^{(t-1)} | \mathbf x^{(0)} \right)$

Because the forward trajectory is a Markov process, $$\begin{aligned}
K &= \sum_{t=2}^T \int d\mathbf x^{(0 \cdots T)} q\left( \mathbf x^{(0\cdots T)} \right)\log \left[ \frac{p\left( \mathbf x^{(t-1)} | \mathbf x^{(t)} \right)}{q\left( \mathbf x^{(t)} | \mathbf x^{(t-1)}, \mathbf x^{(0)} \right)} \right] 
    - H_p\left( \mathbf X^{(T)} \right).
\end{aligned}$$ Using Bayes’ rule we can rewrite this in terms of a posterior and marginals from the forward trajectory, $$\begin{aligned}
K
&= \sum_{t=2}^T \int d\mathbf x^{(0 \cdots T)} q\left( \mathbf x^{(0\cdots T)} \right)\log \left[ 
        \frac{p\left( \mathbf x^{(t-1)} | \mathbf x^{(t)} \right)}{q\left( \mathbf x^{(t-1)} | \mathbf x^{(t)}, \mathbf x^{(0)} \right)} \frac{q\left( \mathbf x^{(t-1)} | \mathbf x^{(0)} \right)}{q\left( \mathbf x^{(t)} | \mathbf x^{(0)} \right)}
    \right] 
    - H_p\left( \mathbf X^{(T)} \right).
\end{aligned}$$

#### Rewrite in terms of KL divergences and entropies

We then recognize that several terms are conditional entropies, $$\begin{aligned}
K
&= \sum_{t=2}^T \int d\mathbf x^{(0 \cdots T)} q\left( \mathbf x^{(0\cdots T)} \right)\log \left[ 
        \frac{p\left( \mathbf x^{(t-1)} | \mathbf x^{(t)} \right)}{q\left( \mathbf x^{(t-1)} | \mathbf x^{(t)}, \mathbf x^{(0)} \right)} 
    \right] 
    + \sum_{t=2}^T \left[ H_q\left( \mathbf X^{(t)} | \mathbf X^{(0)} \right) - H_q\left( \mathbf X^{(t-1)} | \mathbf X^{(0)} \right)\right]
    - H_p\left( \mathbf X^{(T)} \right) \\
&= \sum_{t=2}^T \int d\mathbf x^{(0 \cdots T)} q\left( \mathbf x^{(0\cdots T)} \right)\log \left[ 
        \frac{p\left( \mathbf x^{(t-1)} | \mathbf x^{(t)} \right)}{q\left( \mathbf x^{(t-1)} | \mathbf x^{(t)}, \mathbf x^{(0)} \right)} 
    \right] 
    + H_q\left( \mathbf X^{(T)} | \mathbf X^{(0)} \right) - H_q\left( \mathbf X^{(1)} | \mathbf X^{(0)} \right)
    - H_p\left( \mathbf X^{(T)} \right)
.
\end{aligned}$$ Finally we transform the log ratio of probability distributions into a KL divergence, $$\begin{aligned}
K
&= -\sum_{t=2}^T \int d\mathbf x^{(0)}d\mathbf x^{(t)} q\left( \mathbf x^{(0)}, \mathbf x^{(t)} \right)
D_{KL}\left( 
        q\left( \mathbf x^{(t-1)} | \mathbf x^{(t)}, \mathbf x^{(0)} \right)
            \middle|\middle|
        p\left( \mathbf x^{(t-1)} | \mathbf x^{(t)} \right)
    \right)  \\ \nonumber & \qquad
    + H_q\left( \mathbf X^{(T)} | \mathbf X^{(0)} \right) - H_q\left( \mathbf X^{(1)} | \mathbf X^{(0)} \right)
    - H_p\left( \mathbf X^{(T)} \right)
%, \\
%&= -\sum_{t=2}^T \int d\mb x^{(0)}d\mb x^{(t)} q\left( \mb x^{(0)}, \mb x^{(t)} \right)
%D_{KL}\left( 
%       q\left( \mb x^{(t-1)} | \mb x^{(t)}, \mb x^{(0)} \right)
%           ||
%       \qr
%   \right)  
%   + H_q\left( \mb X^{(T)} | \mb X^{(0)} \right) 
%   + \mathrm{constant}
.
\end{aligned}$$ Note that the entropies can be analytically computed, and the KL divergence can be analytically computed given $\mathbf x^{(0)}$ and $\mathbf x^{(t)}$.

<figure id="fig mnist">
<span class="image placeholder" data-original-image-src="MNIST_samples.pdf" data-original-image-title="" width="0.8\linewidth"></span>
<figcaption> Samples from a diffusion probabilistic model trained on MNIST digits. Note that unlike many MNIST sample figures, these are true samples rather than the mean of the Gaussian or binomial distribution from which samples would be drawn. </figcaption>
</figure>

### Perturbed Gaussian Transition

We wish to compute $\tilde{p}\left( \mathbf x^{(t-1)} \mid \mathbf x^{(t)} \right)$. For notational simplicity, let $\mu = \mathbf f_\mu\left( \mathbf x^{(t)}, t \right)$, $\Sigma = \mathbf f_\Sigma\left( \mathbf x^{(t)}, t \right)$, and $\mathbf y = \mathbf x^{(t-1)}$. Using this notation, $$\begin{aligned}
\tilde{p}\left( \mathbf y \mid \mathbf x^{(t)} \right)
&\propto 
    p\left( \mathbf y \mid \mathbf x^{(t)} \right)
    r\left( \mathbf y \right) \\
&=  \mathcal N \left( \mathbf y ;\mu, \Sigma \right)
    r\left( \mathbf y \right)
.
\end{aligned}$$ We can rewrite this in terms of energy functions, where $E_r\left( \mathbf y \right) = -\log r\left( \mathbf y \right)$, $$\begin{aligned}
\tilde{p}\left( \mathbf y \mid \mathbf x^{(t)} \right)
&\propto
    \exp\left[
        -E\left( \mathbf y \right) 
    \right] \\
E\left( \mathbf y \right) &=\frac{1}{2} \left( \mathbf y - \mu \right)^T \Sigma^{-1} \left( \mathbf y - \mu \right) +  E_r\left( \mathbf y \right)
.
\end{aligned}$$

If $E_r\left( \mathbf y \right)$ is smooth relative to $\frac{1}{2} \left( \mathbf y - \mu \right)^T \Sigma^{-1} \left( \mathbf y - \mu \right)$, then we can approximate it using its Taylor expansion around $\mu$. One sufficient condition is that the eigenvalues of the Hessian of $E_r\left( \mathbf y \right)$ are everywhere much smaller magnitude than the eigenvalues of $\Sigma^{-1}$. We then have $$\begin{aligned}
E_r\left( \mathbf y \right) & \approx E_r\left( \mu \right) + \left( \mathbf y - \mu \right) \mathbf g
\end{aligned}$$ where $\mathbf g = \frac{\partial E_r\left( \mathbf y' \right)}{\partial \mathbf y'} \bigg|_{\mathbf y'=\mu}$. Plugging this in to the full energy, $$\begin{aligned}
E\left( \mathbf y \right) &\approx \frac{1}{2} \left( \mathbf y - \mu \right)^T \Sigma^{-1} \left( \mathbf y - \mu \right) + \left( \mathbf y - \mu \right)^T \mathbf g + \text{constant} \\
&= \frac{1}{2} \mathbf y^T \Sigma^{-1} \mathbf y 
    - \frac{1}{2} \mathbf y^T \Sigma^{-1} \mu
    - \frac{1}{2} \mu^T \Sigma^{-1} \mathbf y
    + \frac{1}{2} \mathbf y^T \Sigma^{-1} \Sigma \mathbf g
    + \frac{1}{2} \mathbf g^T \Sigma  \Sigma^{-1} \mathbf y
    + \text{constant}
    \\
&=  \frac{1}{2}
    \left( \mathbf y - \mu + \Sigma \mathbf g\right)^T 
    \Sigma^{-1} 
    \left( \mathbf y - \mu + \Sigma \mathbf g \right)
    + \text{constant}
.
\end{aligned}$$ This corresponds to a Gaussian, $$\begin{aligned}
\tilde{p}\left( \mathbf y \mid \mathbf x^{(t)} \right)
&\approx 
    \mathcal N \left( \mathbf y ;
        \mu - \Sigma \mathbf g,
        \Sigma 
        \right)
.
\end{aligned}$$ Substituting back in the original formalism, this is, $$\begin{aligned}
\tilde{p}\left( \mathbf x^{(t-1)} \mid \mathbf x^{(t)} \right)
&\approx 
    \mathcal N \left( \mathbf\mathbf x^{(t-1)} ;
        \mathbf f_\mu\left( \mathbf x^{(t)}, t \right) + \mathbf f_\Sigma\left( \mathbf x^{(t)}, t \right)
        \frac{\partial 
            \log r\left( \mathbf x^{(t-1)'} \right)
            }{\partial 
            \mathbf x^{(t-1)'}
            }\Bigg|_{\mathbf x^{(t-1)'}=f_\mu\left( \mathbf x^{(t)}, t \right)}
            ,
        \mathbf f_\Sigma\left( \mathbf x^{(t)}, t \right) 
        \right)
.
\end{aligned}$$

### Experimental Details

#### Toy Problems

##### Swiss Roll

A probabilistic model was built of a two dimensional swiss roll distribution. The generative model $p\left( \mathbf x^{(0\cdots T)} \right)$ consisted of 40 time steps of Gaussian diffusion initialized at an identity-covariance Gaussian distribution. A (normalized) radial basis function network with a single hidden layer and 16 hidden units was trained to generate the mean and covariance functions $\mathbf f_\mu\left( \mathbf x^{(t)}, t \right)$ and a diagonal $\mathbf f_\Sigma\left( \mathbf x^{(t)}, t \right)$ for the reverse trajectory. The top, readout, layer for each function was learned independently for each time step, but for all other layers weights were shared across all time steps and both functions. The top layer output of $\mathbf f_\Sigma\left( \mathbf x^{(t)}, t \right)$ was passed through a sigmoid to restrict it between 0 and 1. As can be seen in Figure , the swiss roll distribution was successfully learned.

##### Binary Heartbeat Distribution

A probabilistic model was trained on simple binary sequences of length 20, where a 1 occurs every 5th time bin, and the remainder of the bins are 0. The generative model consisted of 2000 time steps of binomial diffusion initialized at an independent binomial distribution with the same mean activity as the data ($p\left( x_i^{(T)} = 1 \right) = 0.2$). A multilayer perceptron with sigmoid nonlinearities, 20 input units and three hidden layers with 50 units each was trained to generate the Bernoulli rates $\mathbf f_b\left( \mathbf x^{(t)}, t \right)$ of the reverse trajectory. The top, readout, layer was learned independently for each time step, but for all other layers weights were shared across all time steps. The top layer output was passed through a sigmoid to restrict it between 0 and 1. As can be seen in Figure , the heartbeat distribution was successfully learned. The log likelihood under the true generating process is $\log_2\left( \frac{1}{5} \right) = -2.322$ bits per sequence. As can be seen in Figure and Table learning was nearly perfect.

#### Images

##### Architecture

###### Readout

In all cases, a convolutional network was used to produce a vector of outputs $\mathbf y_i \in \mathcal R^{2J}$ for each image pixel $i$. The entries in $\mathbf y_i$ are divided into two equal sized subsets, $\mathbf y^\mu$ and $\mathbf y^\Sigma$.

###### Temporal Dependence

The convolution output $\mathbf y^\mu$ is used as per-pixel weighting coefficients in a sum over time-dependent “bump” functions, generating an output $\mathbf z^\mu_i \in \mathcal R$ for each pixel $i$, $$\begin{aligned}
\mathbf z^\mu_i &= \sum_{j=1}^J \mathbf y^\mu_{ij} g_j\left(t\right)
.
\end{aligned}$$ The bump functions consist of $$\begin{aligned}
g_j\left(t\right) &= \frac{
    \exp\left( 
        -\frac{1}{2 w^2} \left( t - \tau_j \right)^2
    \right)
}{
    \sum_{k=1}^J
    \exp\left( 
        -\frac{1}{2 w^2} \left( t - \tau_k \right)^2
    \right)
}
,
\end{aligned}$$ where $\tau_j \in (0, T)$ is the bump center, and $w$ is the spacing between bump centers. $\mathbf z^\Sigma$ is generated in an identical way, but using $y^\Sigma$.

For all image experiments a number of timesteps $T=1000$ was used, except for the bark dataset which used $T=500$.

###### Mean and Variance

Finally, these outputs are combined to produce a diffusion mean and variance prediction for each pixel $i$, $$\begin{aligned}
\Sigma_{ii} &= \sigma\left( z^\Sigma_i + \sigma^{-1}\left( \beta_t \right) \right), \\
\mu_i &= \left( x_i - z^\mu_i \right)\left(1 - \Sigma_{ii}\right) + z^\mu_i
.
\end{aligned}$$ where both $\Sigma$ and $\mu$ are parameterized as a perturbation around the forward diffusion kernel $T_\pi\left( \mathbf x^{(t)} | \mathbf x^{(t-1)}; \beta_t \right)$, and $z^\mu_i$ is the mean of the equilibrium distribution that would result from applying $p\left( \mathbf x^{(t-1)} | \mathbf x^{(t)} \right)$ many times. $\Sigma$ is restricted to be a diagonal matrix.

###### Multi-Scale Convolution

We wish to accomplish goals that are often achieved with pooling networks – specifically, we wish to discover and make use of long-range and multi-scale dependencies in the training data. However, since the network output is a vector of coefficients for every pixel it is important to generate a full resolution rather than down-sampled feature map. We therefore define multi-scale-convolution layers that consist of the following steps:

1.  Perform mean pooling to downsample the image to multiple scales. Downsampling is performed in powers of two.

2.  Performing convolution at each scale.

3.  Upsample all scales to full resolution, and sum the resulting images.

4.  Perform a pointwise nonlinear transformation, consisting of a soft relu ($\log\left[ 1 + \exp\left(\cdot \right)\right]$).

The composition of the first three linear operations resembles convolution by a multiscale convolution kernel, up to blocking artifacts introduced by upsampling. This method of achieving multiscale convolution was described in .

###### Dense Layers

Dense (acting on the full image vector) and kernel-width-1 convolutional (acting separately on the feature vector for each pixel) layers share the same form. They consist of a linear transformation, followed by a tanh nonlinearity.

<figure id="fig architecture">

<figcaption> Network architecture for mean function <span class="math inline">\(\mathbf f_\mu\left( \mathbf x^{(t)}, t \right)\)</span> and covariance function <span class="math inline">\(\mathbf f_\Sigma\left( \mathbf x^{(t)}, t \right)\)</span>, for experiments in Section <span class="math inline">\(\ref{sec images}\)</span>. The input image <span class="math inline">\(\mathbf x^{(t)}\)</span> passes through several layers of multi-scale convolution (Section <span class="math inline">\(\ref{sec multiscale}\)</span>). It then passes through several convolutional layers with <span class="math inline">\(1\times 1\)</span> kernels. This is equivalent to a dense transformation performed on each pixel. A linear transformation generates coefficients for readout of both mean <span class="math inline">\(\mu^{(t)}\)</span> and covariance <span class="math inline">\(\Sigma^{(t)}\)</span> for each pixel. Finally, a time dependent readout function converts those coefficients into mean and covariance images, as described in Section <span class="math inline">\(\ref{sec readout}\)</span>. For CIFAR-10 a dense (or fully connected) pathway was used in parallel to the multi-scale convolutional pathway. For MNIST, the dense pathway was used to the exclusion of the multi-scale convolutional pathway. </figcaption>
</figure>

[^1]: Non-parametric methods can be seen as transitioning smoothly between tractable and flexible models. For instance, a non-parametric Gaussian mixture model will represent a small amount of data using a single Gaussian, but may represent infinite data as a mixture of an infinite number of Gaussians.

[^2]: Recent experiments suggest that it is just as effective to instead use the same fixed $\beta_t$ schedule as for binomial diffusion.
