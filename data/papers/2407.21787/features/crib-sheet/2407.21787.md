- **Inference Compute Scaling**: Repeated sampling as a method to scale inference compute, improving reasoning performance across tasks.
  
- **Key Metrics**:
  - **Coverage**: Fraction of problems solved by any generated sample; increases with the number of samples.
  - **Precision**: Ability to identify correct samples from generated candidates.

- **Performance Improvement**: 
  - DeepSeek-Coder-V2-Instruct: Coverage increases from 15.9% (1 sample) to 56% (250 samples) on SWE-bench Lite, surpassing the single-sample SOTA of 43%.

- **Scaling Laws**: Coverage vs. number of samples often follows a log-linear relationship, modeled by an exponentiated power law.

- **Task Categories**:
  - **GSM8K**: Grade-school level math word problems.
  - **MATH**: Harder math word problems.
  - **MiniF2F-MATH**: Formalized math problems for proof checking.
  - **CodeContests**: Competitive programming problems with hidden test cases.
  - **SWE-bench Lite**: Real-world GitHub issues requiring code edits.

- **Sample Generation Process**:
  1. Generate multiple candidate solutions from an LLM.
  2. Use domain-specific verifiers (e.g., unit tests) to select the final answer.

- **Coverage Calculation**: 
  - Formula for pass@k:
  \[
  pass@k = 1 - \frac{N - C_i}{N} \text{ for } k \leq N
  \]
  where \(C_i\) is the number of correct samples.

- **Verification Challenges**: In domains without automatic verifiers, common methods (majority voting, reward models) plateau, failing to scale with sample budget.

- **Cost-Effectiveness**: Repeated sampling can minimize inference costs; e.g., sampling from a cheaper model can outperform single samples from more expensive models.

- **Model Evaluation**: 
  - Models tested include Llama-3 (8B, 70B), Gemma (2B, 7B), and Pythia (70M to 12B).
  - Notable coverage increases observed across various models, especially smaller ones.

- **Key Observations**:
  1. Repeated sampling significantly improves coverage across tasks.
  2. Coverage improvement correlates with sample budget, especially in tasks with automatic verifiers.
  3. Verification methods need to scale with increased samples to maintain performance gains.