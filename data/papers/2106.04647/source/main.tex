\documentclass{article}

% if you need to pass options to natbib, use, e.g.:
%     \PassOptionsToPackage{numbers, compress}{natbib}
% before loading neurips_2021

% ready for submission
%\usepackage[nonatbib]{neurips_2021}

% I added this now.
\usepackage[sort,numbers]{natbib}

%\usepackage[nonatbib]{neurips_2021}
     
% to compile a preprint version, e.g., for submission to arXiv, add add the
% [preprint] option:
%     \usepackage[preprint]{neurips_2021}

% to compile a camera-ready version, add the [final] option, e.g.:
\usepackage[final]{neurips_2021}

% to avoid loading the natbib package, add option nonatbib:
%    \usepackage[nonatbib]{neurips_2021}
\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
%\usepackage[numbers,sort]{natbib} 
\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{xcolor}         % colors

\usepackage{xspace}

\usepackage{longtable}
\usepackage{multirow}

% This is not strictly necessary, and may be commented out,
% but it will improve the layout of the manuscript,
% and will typically save some space.
\usepackage{graphicx}
\usepackage{multirow, multicol}
\usepackage[colorinlistoftodos,prependcaption]{todonotes}
\usepackage{tabulary,booktabs}
\usepackage{todonotes}
\usepackage{subfig}
\usepackage{tabulary,booktabs}
\usepackage{tablefootnote}
\usepackage{amsfonts}
\usepackage{color,soul}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{colortbl}
\usepackage{color, xcolor}
\usepackage{bm}
\usepackage[subtle]{savetrees}
\usepackage{comment}
\usepackage{amsmath}
\usepackage{color,soul}
\usepackage{adjustbox}
\usepackage{pbox}
\usepackage{float}
\usepackage{pifont}
\usepackage{chngpage}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{epigraph}


\usepackage[colorinlistoftodos,prependcaption]{todonotes}
% \newcommand{\todocomment}[1]{#1} % comment on 
\newcommand{\todocomment}[1]{} % comment off 
\newcommand{\sr}[1]{} %\textcolor{magenta}{\todocomment{~sr: #1}}}
\newcommand{\jh}[1]{} %\textcolor{olive}{\todocomment{~jh: #1}}}
\newcommand{\rk}[1]{} %\textcolor{brown}{\todocomment{~rk: #1}}}
\newcommand{\checkthis}[1]{\textcolor{black}{#1}}
\newcommand{\change}[1]{\textcolor{black}{#1}}
\newcommand{\abitcopy}[1]{\textcolor{black}{#1}}
\newcommand{\rewrite}[1]{\textcolor{gray}{#1}}
\newcommand{\remove}[1]{}
\newcommand{\nextdeadline}[1]{} 

\newcommand{\basebase}{T5\textsubscript{\tiny BASE}\xspace}
\newcommand{\basesmall}{T5\textsubscript{\tiny SMALL}\xspace}
\newcommand{\adapter}{\textsc{Adapter}\xspace}
\newcommand{\adapterlowrank}{\textsc{Adapter-LowRank}\xspace}
\newcommand{\adapternoclf}{\textsc{Adapter}\xspace}
\newcommand{\compacter}{\textsc{Compacter}\xspace}
\newcommand{\compacteronlyff}{\textsc{Compacter}\texttt{++}\xspace} % compater with only feedforward adapters
\newcommand{\compacternoclf}{\textsc{Compacter}\xspace}
\newcommand{\compacteronlyffnoclf}{\textsc{Compacter}\texttt{++}\xspace} % compater with only feedforward adapters
\newcommand{\phmadapter}{\textsc{PHM-Adapter}\xspace}
\newcommand{\phmadapternoclf}{\textsc{PHM-Adapter}\xspace}
\newcommand{\intrinsic}{\textsc{Intrinsic-SAID}\xspace}
\newcommand{\prompttuning}{\textsc{Prompt Tuning}\xspace}
\newcommand{\prompttuningrandom}{\textsc{Prompt Tuning-R}\xspace}
\newcommand{\prompttuningtokens}{\textsc{Prompt Tuning-T}\xspace}
\newcommand{\pfeifferadapter}{\textsc{Pfeiffer-Adapter}\xspace}
% for now lets the name be likes this and then I will modify it.
\newcommand{\pfeifferadapternoclf}{\textsc{Pfeiffer-Adapter}\xspace}
\newcommand{\glue}{\textsc{GLUE}\xspace}
\newcommand{\superglue}{\textsc{SuperGLUE}\xspace}
\newcommand{\adapterdrop}{\textsc{AdapterDrop}\xspace}
\newcommand{\adapterdropnoclf}{\textsc{AdapterDrop}\xspace}
\newcommand{\drawline}{\par\noindent\rule{\textwidth}{0.4pt}}
\newcommand{\bitfit}{\textsc{BitFit}\xspace}
\newcommand{\bitfitnoclf}{\textsc{BitFit}\xspace}
\newcommand{\compacterrate}{$0.047\%$\xspace}
\def \hfillx {\hspace*{-\textwidth} \hfill}



\title{\compacter: \\Efficient Low-Rank Hypercomplex Adapter Layers}

% Author information can be set in various styles:
% For several authors from the same institution:
% \author{Author 1 \and ... \and Author n \\
%         Address line \\ ... \\ Address line}
% if the names do not fit well on one line use
%         Author 1 \\ {\bf Author 2} \\ ... \\ {\bf Author n} \\
% For authors from different institutions:
% \author{Author 1 \\ Address line \\  ... \\ Address line
%         \And  ... \And
%         Author n \\ Address line \\ ... \\ Address line}
% To start a seperate ``row'' of authors use \AND, as in
% \author{Author 1 \\ Address line \\  ... \\ Address line
%         \AND
%         Author 2 \\ Address line \\ ... \\ Address line \And
%         Author 3 \\ Address line \\ ... \\ Address line}

  \author{Rabeeh Karimi Mahabadi \\
  EPFL University, Idiap Research Institute\\
  \texttt{rabeeh.karimi@idiap.ch} \\\And
  James Henderson \\
  Idiap Research Institute \\
  \texttt{james.henderson@idiap.ch}\\\And
  Sebastian Ruder \\
  DeepMind \\
  \texttt{ruder@google.com}
  }
  
\begin{document}

\maketitle

\begin{abstract}
Adapting large-scale pretrained language models to downstream tasks via fine-tuning is the standard method for achieving state-of-the-art performance on NLP benchmarks. However, fine-tuning all weights of models with millions or billions of parameters is sample-inefficient, unstable in low-resource settings, and wasteful as it requires storing a separate copy of the model for each task. Recent work has developed \emph{parameter-efficient} fine-tuning methods, 
but these approaches either still require a relatively large number of parameters or underperform standard fine-tuning. In this work, we propose \compacter, a method for fine-tuning large-scale language models with a better trade-off between task performance and the number of trainable parameters than prior work.
\compacter accomplishes this by building on top of ideas from adapters, low-rank optimization, and parameterized hypercomplex multiplication layers.

Specifically, \compacter inserts task-specific weight matrices into a pretrained model's weights, which are computed efficiently as a sum of Kronecker products between shared ``slow'' weights and ``fast'' rank-one matrices defined per \compacter layer. By only training $0.047\%$ of a pretrained model's parameters, \compacter performs on par with standard fine-tuning on GLUE and outperforms standard fine-tuning on SuperGLUE and low-resource settings. Our code is publicly available at~\url{https://github.com/rabeehk/compacter}. 
\end{abstract}

\section{Introduction}

\begin{figure}[tp]
\centering
\begin{minipage}[b]{0.6\linewidth}
\centering %line{
\includegraphics[width=1.0\textwidth, trim={0.2cm 0.48 0.1cm 0.48},clip]{figures/comparison_plot.pdf}
\caption{The average score on GLUE (y axis), percentage of trainable parameters per task (x axis, in log scale), and memory footprint (size of the circles) of different methods.}\vspace{-1.7em} 
\label{fig:comparison} 
\end{minipage}
\hspace{1em}
%\quad
\begin{minipage}[b]{0.36\linewidth} % this was 0.38 with hspace of 0.3
\centering %line{
\includegraphics[width=1.0\textwidth]{figures/our_method_3.pdf}%trim={0 0 0.42cm 0},clip, %\vspace{-0.6em} 
\vspace{-0.5em}
\caption{
Left: Adapter integration in a pretrained transformer model.  Right: Adapter architecture. Following~\citet{houlsby2019parameter}, we include adapters after the attention  and feed-forward modules. During training, we only update layer normalizations and adapters (shown in yellow), while the pretrained model is fixed.}\vspace{-0.7em} 
\label{fig:our_method} 
\end{minipage}
% \vspace{-2em} 
\end{figure}

\parbox[b]{0.5\textwidth}{
State-of-the-art pretrained language models (PLMs) in natural language processing (NLP) have used heavily over-parameterized representations consisting of hundreds of millions or billions of parameters to achieve success on a wide range of 
  \linebreak ~ \vspace{-\baselineskip}
}
\parbox[b]{0.45\textwidth}{
  \epigraph{With four parameters I can fit an elephant, and with five I can make him wiggle his trunk.}{John von Neumann}
}
NLP benchmarks~\citep{devlin2019bert, raffel2019exploring, liu2019roberta}. These models are generally applied to downstream tasks via fine-tuning \citep{howard-2018-ulmfit}, which requires updating \emph{all} parameters and storing one copy of the fine-tuned model per task.
This causes substantial storage and deployment costs and hinders the applicability of large-scale PLMs to real-world applications. Additionally, fine-tuning of over-parameterized models on low-resource datasets has been shown to be subject to instabilities and may lead to poor performance \citep{peters-2019-tune,Dodge2020fine-tuning}.

Inspired by John von Neumann's quotation, we ask, given that we have already learned general-purpose language representations via a PLM (i.e. we have fit our elephant), how many more parameters do we need to reach state-of-the-art performance on standard NLP tasks. Specifically, we aim to develop practical, memory-efficient methods that train a minimum set of parameters while achieving performance on par or better than full fine-tuning for state-of-the-art NLP models.




Recent literature has introduced \emph{parameter-efficient} fine-tuning methods. These approaches generally keep the pretrained model's parameters fixed and introduce a set of trainable parameters per task, trading off the number of trainable parameters with task performance. At one end of the spectrum, \emph{prompts}, i.e. natural language descriptions of a task, together with demonstrations have been used to achieve reasonable performance \emph{without any} parameter updates on some benchmarks \citep{brown2020gpt3} but their performance generally lags behind fine-tuned models. They also require huge models to work well but choosing good prompts becomes harder with larger model sizes \citep{Perez2021true}. \emph{Soft prompt} methods treat prompts as trainable continuous parameters, which are prepended to the inputs at the input layer or intermediate layers \citep{li2021prefix,hambardzumyan2021warp,lester2021power}. Such methods, however, often require large models to achieve good performance and are very sensitive to initialization and unstable during training. 

The theoretically motivated \emph{low-rank} methods train a small number of parameters that lie in a low-dimensional subspace using random projections \citep{li2018measuring,aghajanyan2020intrinsic}. However, storing the random projection matrices causes substantial memory overhead and leads to slow training times.
% methods require storing an arbitrary random projection to project each parameter to a lower dimensional space, and cause substantial memory overhead to save these projection matrices, and are very slow to train.
At the other end of the spectrum, \emph{adapter} methods \citep{rebuffi2018efficient, houlsby2019parameter} that insert trainable transformations at different layers of the pretrained model require more parameters than the aforementioned approaches but are more memory-efficient and obtain performance comparable to full fine-tuning \citep{houlsby2019parameter, linz-etal-2020-exploring}.


In this work, we propose \compacter, a method for fine-tuning large-scale language models with an excellent trade-off between the number of trainable parameters, task performance, and memory footprint, compared to existing methods (see Figure \ref{fig:comparison}). \compacter builds on ideas from adapters \citep{houlsby2019parameter}, low-rank methods \citep{li2018measuring}, as well as recent hypercomplex multiplication layers~\citep{zhang2021beyond}. Similar to adapters, \compacter inserts task-specific weight matrices into a pretrained model's weights. Each \compacter weight matrix is computed as the sum of Kronecker products between shared ``slow'' weights and ``fast'' rank-one matrices defined per \compacter layer (see Figure \ref{fig:compactformer}). As a result, \compacter achieves a parameter complexity of $\mathcal{O}(k+d)$ compared to $\mathcal{O}(kd)$ for regular adapters, where the adapters are of size $k\!{\times}\! d$. In practice, \compacter trains $0.047\%$ of a PLM's parameters. On the standard GLUE~\citep{wang2018glue} and SuperGLUE~\citep{wang2019superglue} benchmarks, \compacter outperforms other parameter-efficient fine-tuning methods and obtains performance on par or better than full fine-tuning. On low-resource settings, \compacter outperforms standard fine-tuning. 

In summary, we make the following contributions:
\textbf{1)} We propose \compacter (\textbf{Compact} Adapt\textbf{er}) layers, a parameter-efficient method to adapt large-scale language models. 
\textbf{2)} We show that \compacter obtains strong empirical performance on GLUE and SuperGLUE. 
\textbf{3)} We demonstrate that \compacter outperforms fine-tuning in low-resource settings.
\textbf{4)} We provide a parameter complexity analysis of \compacter, showing that it requires dramatically fewer parameters than adapters and fine-tuning.
\textbf{5)} We provide a systematic evaluation of recent parameter-efficient fine-tuning methods in terms of training time and memory consumption. We release our code to facilitate future work.


\section{Background}
We start by introducing the required background on the Kronecker product and adapter layers~\citep{houlsby2019parameter, rebuffi2018efficient}. 
\subsection{Kronecker Product} 
The Kronecker product between matrix $\bm{A}\in \mathbb{R}^{m\times f}$ and $\bm{B} \in \mathbb{R}^{p\times q}$, denoted by $\bm{A}\otimes \bm{B} \in \mathbb{R}^{mp\times fq}$, is mathematically defined as:
\begin{equation}
\bm{A}\otimes\bm{B} =   \begin{pmatrix}
a_{11}\bm{B}  & \cdots & a_{1f}\bm{B} \\
\vdots  & \ddots & \vdots  \\
a_{m1}\bm{B}  & \cdots & a_{mf}\bm{B} 
\end{pmatrix},
\end{equation} where $a_{ij}$ shows the element in the $i^\text{th}$ row and $j^\text{th}$ column of $\bm{A}$. 
\subsection{Adapter Layers}\label{sec:adapters}
Recent work has shown that fine-tuning \emph{all} parameters of a language model can lead to a sub-optimal solution, particularly for low-resource datasets~\citep{peters-2019-tune}. As an alternative, \citet{rebuffi2018efficient} and \citet{houlsby2019parameter} propose to transfer a model to new tasks by inserting small task-specific modules called \emph{adapter layers} within the layers of a pretrained model, as depicted in Figure~\ref{fig:our_method}. They then only train adapters and layer normalizations, while the remaining parameters of the pretrained model remain fixed. This approach allows pretrained language models to efficiently adapt to new tasks. 

Each layer of a transformer model is composed of two primary modules: a) an attention block, and b) a feed-forward block. Both modules are followed by a skip connection. 
As shown in Figure~\ref{fig:our_method},~\citet{houlsby2019parameter} suggest to insert an adapter layer after each of these blocks before the skip connection. 

Adapters are bottleneck architectures. By keeping the output dimension similar to their input, they cause no change to the structure or parameters of the original model. The adapter layer $A^l$ for layer $l$ consists of a down-projection, $\bm{D^l}\in\mathbb{R}^{k\times d}$, GeLU non-linearity~\citep{hendrycks2016gaussian}, and up-projection $\bm{U^l} \in\mathbb{R}^{d \times k}$, where $k$ is the input dimension, and $d$ is the bottleneck dimension for the adapter layer. Adapters are defined as:
\begin{align}
A^l(\bm{x}) = \bm{U^l}(\text{GeLU}(\bm{D^l}(\bm{x}))) + \bm{x}, \label{eq:adapters}
\end{align}
where $\bm{x}$ is the input hidden state.

\section{Method}
In this section, we present \compacter, a compact and efficient way to adapt large-scale PLMs. 

\noindent \textbf{Problem formulation} $\:$ We consider the general problem of fine-tuning large-scale language models, where we are given the training data  $\mathcal{D}= \{(\bm{x^i}, y^i)\}_{i=1}^{P}$ with $P$ samples. We assume we are also given a large-scale pretrained language model $f_{\bm{\theta}}(.)$ parameterized by $\bm{\theta}$ that computes the output for input $\bm{x^i}$.
Our goal is to fine-tune  $f_{\bm{\theta}}(.)$ efficiently to  enable the model to adapt to new tasks. 


\begin{figure}[tp]%thp!]
\centering %line{
\includegraphics[width=1\textwidth, trim={0cm 0.1cm 0.5cm 0.2cm}, clip]{figures/compacter_phm_version_2.pdf} 
\caption{Illustration of generating weights of two different \compacter layers:  $\bm{W_1} \in \mathbb{R}^{d \times k}$ (first row) and $\bm{W_2}  \in \mathbb{R}^{d \times k}$ (second row). We generate $\bm{W_1}$ and $\bm{W_2}$ using $\bm{W_j} = \sum_{i=1}^n \bm{A_i} \otimes \bm{{B_i}^j} = \sum_{i=1}^n \bm{A_i} \otimes (\bm{{s_i}^j}{\bm{{t_i}^j}}^\top)$~\eqref{eq:our_method}, by computing the sum of Kronecker products of \emph{shared} matrices $\bm{A_i}$ and \emph{adapter-specific} matrices $\bm{B_i^j}$, with $i\in\{1, \dots, n\}$ and adapter index $j\in\{1, 2\}$. We generate each $\bm{B_i^j}$ by multiplying independent rank one weights. In this example $n=2$, $d=6$, and $k=8$.  } \vspace{-1.2em}
\label{fig:compactformer}
\end{figure} 

\subsection{Compact and Efficient Adapter Layers} \label{sec:compacter}
In this section, we introduce an efficient version of adapter layers, building on top of recent advances in \emph{parameterized hypercomplex multiplication layers} (PHM)~\citep{zhang2021beyond}.  To the best of our knowledge, we are the first to exploit PHM layers for efficient fine-tuning of large-scale transformer models. The PHM layer has a similar form as a fully-connected layer, which converts an input $\bm{x}\in\mathbb{R}^k$ to an output $\bm{y}\in\mathbb{R}^d$:  
\begin{align}
    \bm{y} =  \bm{W}\bm{x}+\bm{b}, \label{eq:phm}  %\text{PHM}(\bm{x}) =
\end{align} where $\bm{W}\in\mathbb{R}^{k\times d}$. The key difference is that in a PHM layer, $\bm{W}$ is learned as a sum of Kronecker products. Assume that $k$ and $d$ are both divisible by a user-defined hyperparameter $n \in \mathbb{Z}_{>0}$. Then, the matrix $\bm{W}$ in \eqref{eq:phm} is computed as the sum of $n$ Kronecker products as follows: 
\begin{align}
\bm{W} = \sum_{i=1}^n \bm{A_i} \otimes \bm{B_i}, 
\label{eq:phm-params} 
\end{align}
where $\bm{A_i}\in\mathbb{R}^{n\times n}$ and $\bm{B_i}\in\mathbb{R}^{\frac{k}{n}\times \frac{d}{n}}$. The PHM layer has a parameter complexity of $\mathcal{O}(\frac{kd}{n})$, reducing parameters by at most $\frac{1}{n}$ \citep{zhang2021beyond} (see \textsection \ref{sec:parameter_efficiency}).



\subsection{Beyond Hypercomplex Adapters}

Prior work indicates that some of the information captured in pretrained models can be ignored for transfer \citep{Zhang2021revisiting,Chung2021rembert}. Similarly, redundancies have been observed in the information captured by adapters, with adapters in lower layers being less important \citep{houlsby2019parameter}. In addition, sharing adapters across layers leads to a comparatively small drop of performance for some tasks \citep{Ruckle2020adapterdrop}. 
Motivated by these insights, we propose the following two extensions to make hypercomplex adapters more efficient. 

\noindent \textbf{Sharing information across adapters} $\:$ Sharing all adapter parameters across layers is overall too restrictive and is not able to perform on par with fine-tuning or using regular adapters \citep{Ruckle2020adapterdrop}; however, our decomposition of adapters into $\bm{A_i}$ and $\bm{B_i}$ matrices as in Eq.~\eqref{eq:phm-params} allows us to be more flexible. Consequently, we divide our adaptation weights into \emph{shared} parameters that capture general information useful for adapting to the target task and \emph{adapter-specific} parameters that focus on capturing information relevant for adapting each individual layer. Specifically, we define $\bm{A_i}$ as shared parameters that are common across all adapter layers while $\bm{B_i}$ are adapter-specific parameters.

\noindent \textbf{Low-rank parameterization} $\:$ Low-rank methods \citep{li2018measuring,aghajanyan2020intrinsic} have demonstrated that strong performance can be achieved by optimizing a task in a low-rank subspace. Similarly, we hypothesize that a model can also be effectively adapted by learning transformations in a low-rank subspace.
% Based on recent evidence that models can reach strong performance by optimizing a task in a low-rank subspace ,
To this end, we propose to parameterize $\bm{B_i}\in\mathbb{R}^{\frac{k}{n}\times \frac{d}{n}}$ as a low-rank matrix, which is the product of two low-rank weights $\bm{s_i} \in \mathbb{R}^{\frac{k}{n}\times r}$ and $\bm{t_i}\in \mathbb{R}^{r \times {\frac{d}{n}}}$, where $r$ is the rank of the matrix.\footnote{We do not factorize $\bm{A_i}$ as they are small, shared between all layers, and factorization hurts performance.} Putting both extensions together, we propose the \emph{low-rank} parameterized hypercomplex multiplication layer (LPHM):
\begin{align}
\bm{W} = \sum_{i=1}^n \bm{A_i} \otimes \bm{B_i} = \sum_{i=1}^n \bm{A_i} \otimes (\bm{s_i}\bm{t_i}^\top).
\label{eq:our_method}
\end{align} 
In general, we set $r=1$ so that $\bm{B_i}$ is a rank-one matrix. Depending on the complexity of the target task, $r$ can be set to a higher value.\footnote{If factors are over-parameterized, \compacter can be used for \emph{overcomplete} knowledge distillation \citep{arora2018optimization}.} Figure~\ref{fig:compactformer} illustrates our method. Overall, the LPHM layer reduces complexity further to $\mathcal{O}(k+d)$ (see \textsection \ref{sec:parameter_efficiency}).
The LPHM layer can also be seen as leveraging ``slow'' weights $\bm{A_i}$ that are shared across adapters and capture general information and ``fast'' weights $\bm{B_i}$ that learn adapter-specific information for adaptation of each individual layer \citep{Wen2020batchensemble}.


\noindent \textbf{\compacter} $\:$ \label{sec:phm-adapters}
Based on the above formulation, we introduce \compacter layers, which replace the down-projection and up-projection layers in adapters as follows:
\begin{align}
A^l(\bm{x}) =\text{LPHM}^{U^l}(\text{GeLU}(\text{LPHM}^{D^l}(\bm{x}))) + \bm{x}, \nonumber
% {LN}^{l}\left(\right)
\end{align} where the up-projection weights $\text{LPHM}^{U^l}$ are computed as in \eqref{eq:our_method}, replacing the layer $U^l$ in \eqref{eq:adapters}. Similarly, down-projection weights $\text{LPHM}^{D^l}$ replace the layer $D^l$. While the two adapters in each layer of a transformer have their own $\bm{s_i}$ and $\bm{t_i}$ rank-one weights, we share the $\bm{A_i}$ across all layers and positions of the adapter layers.
\vspace{-0.4em}
\section{Parameter Efficiency} \label{sec:parameter_efficiency}
In this section, we compare the number of parameters of \compacter with adapters.

\noindent \textbf{Adapters parameters} $\:$ In the standard setting, two adapters are added per layer of a transformer model~\citep{houlsby2019parameter}. Each adapter layer consists of $2kd$ parameters for the down and up-projection matrices ($\bm{U^l}$, $\bm{D^l}$) respectively where $k$ is the size of the input dimension and $d$ is the adapter's bottleneck dimension. The total number of parameters for adapters for a transformer model with $L$ layers of both an encoder and a decoder is, therefore, $2L(2kd)$, which scales linearly with all three variables.


\noindent \textbf{\phmadapter parameters} $\:$ In the conventional PHM layer~\citep{zhang2021beyond}, as depicted in Eq. \eqref{eq:phm-params}, parameters of $\bm{A_i}\in\mathbb{R}^{n\times n}$ and $\bm{B_i}\in\mathbb{R}^{\frac{k}{n}\times \frac{d}{n}}$ define the degree of freedom for $\bm{W}$ as $n(\frac{kd}{n^2}+n^2)=\frac{kd}{n}+n^3$.  With the mild condition that $kd > n^4$, then $\frac{kd}{n}$ dominates and the overall parameter size of the PHM layer in \eqref{eq:phm-params} is $\mathcal{O}(\frac{kd}{n})$. This condition is satisfied for typical values for adapters, PHM layers, and large-scale PLMs such as T5-large, with hidden size $k = 1024$, adapter hidden size $d\in\{24, 32, 48, 96\}$, and $n = 2,4,8,12$.
Hence, the PHM layer offers a parameter reduction of almost $\frac{1}{n}$ compared to standard fully-connected layers, which are $\mathcal{O}(kd)$.\footnote{Even for smaller models where the $n^4$ term dominates, we observe a substantial reduction of parameters compared to adapters.} 

Similarly, employing PHM layers for modeling down and up-projection matrices offers a parameter reduction of almost $\frac{1}{n}$. Each adapter with a PHM layer has in total $2(\frac{kd}{n}+n^3)$ parameters. For a Transformer model with $L$ layers, the total number of parameters of \phmadapter is $4L(\frac{kd}{n}+n^3)$. 

\noindent \textbf{\compacter parameters} $\:$ \compacter shares the trained weight matrices $\{\bm{A_i}\}_{i=1}^n$ in~\eqref{eq:our_method} consisting of $n^3$ parameters across all layers. \compacter also has two rank-one weights for each adapter, $\bm{s_i},\bm{t_i}$ in~\eqref{eq:our_method} consisting of $\frac{k}{n}+\frac{d}{n}$ parameters, resulting in a total of $2n(\frac{k}{n}+\frac{d}{n})$ parameters for down and up-projection weights. Therefore, the total number of parameters of \compacter is $4L(k+d) + n^3$ for a transformer with $L$ layers in the encoder and decoder.

In settings with a large number of layers, the dominant term is $4L(k+d)$. Therefore, with a mild condition that $4L(k+d)>n^3$, \compacter has a complexity of $\mathcal{O}(k+d)$, which is far more efficient compared to adapters' $\mathcal{O}(kd)$ and \phmadapter's $\mathcal{O}(\frac{kd}{n})$ complexity respectively. In settings where $n$ is large, the number of parameters for shared weight matrices $\{\bm{A_i}\}_{i=1}^n$ for all layers remain constant in \compacter with a total of $n^3$ parameters while this scales linearly with the number of layers $L$ for PHM and adapter layers.
% , $Ln^3$.
 As an example, in the \basebase model with 222M parameters~\citep{raffel2019exploring}, \compacter only learns \compacterrate of the parameters, and maintains comparable performance to \emph{full fine-tuning}.


\vspace{-0.5em}
\section{Experiments} \label{sec:experiments}
\noindent \textbf{Datasets} $\:$ Following~\citet{raffel2019exploring}, we evaluate the performance of the methods on the GLUE~\citep{wang2018glue} and SUPERGLUE~\citep{wang2019superglue} benchmarks. These benchmarks cover multiple tasks of paraphrase detection (MRPC, QQP), sentiment classification (SST-2), natural language
inference (MNLI, RTE, QNLI, CB), linguistic acceptability (CoLA), question-answering (MultiRC, ReCoRD, BoolQ), word sense disambiguation (WiC), and sentence completion (COPA).\footnote{
Following~\citet{raffel2019exploring, devlin2019bert}, as a common practice, we do not experiment with WNLI~\citep{levesque2012winograd} due to its adversarial nature with respect to the training set.} As the original test sets are not publicly available, we follow~\citet{zhang2020revisiting} and split off 1k samples from the training set that we use for validation, while we use the original validation data as the test set. For datasets with fewer than 10k samples (RTE, MRPC, STS-B, CoLA, COPA, WiC, CB, BoolQ, MultiRC),  we divide the original validation set in half, using one half for validation and the other for testing.

\noindent \textbf{Experimental details} $\:$  
%We use the encoder-decoder T5 model (Raffel et al.,2020) as the underlying model for our experiments
We use the state-of-the-art encoder-decoder T5 model~\citep{raffel2019exploring} as the underlying model for all methods in our experiments. For computational efficiency, we report all results on \basebase~models (12 encoder and decoder layers and 222M parameters). We use its HuggingFace PyTorch implementation~\citep{wolf-etal2020transformers}. We fine-tune all methods for 3 epochs on large datasets and 20 epochs for low-resource datasets of \glue (MRPC, CoLA, STS-B, RTE, BoolQ, CB, COPA, WiC) to allow the models to converge~\citep{zhang2020revisiting}. For all adapter-based methods, we experiment with adapters of bottleneck size of $\{96, 48, 24\}$. We save a checkpoint every epoch for all models and report the results for the hyper-parameters performing the best on the validation set for each task. For the PHM layers, we use the PyTorch implementation of~\citet{le2021parameterized}. We include low-level details in Appendix~\ref{app:experimental_detials}. For our methods, we experiment with $n=\{4, 8, 12\}$ and report the model performing the best. We include the results for all values of $n$ in Appendix~\ref{app:ablations}.

Following~\citet{karimi2021parameter-efficient}, we freeze the output layer of the pretrained model for all tasks across all methods.\footnote{This is much more efficient as the output layer includes 11.1\% of the parameters of \basebase. Tasks are formulated in a text-to-text format so the model can be applied to them without learning a new output layer~\citep{raffel2019exploring}. We note that this is in contrast to the original adapter setting, which used an encoder-only masked PLM \citep{houlsby2019parameter}.} We show the results with fine-tuning the output layer in Appendix~\ref{app:with_lm_head}. Following~\citet{houlsby2019parameter}, we update the layer normalization parameters for all methods where applicable.\footnote{For \bitfit, we only update the biases. For \prompttuning, the entire model is frozen.} 


\vspace{-0.5em}
\subsection{Baselines}

We compare against several recently proposed \emph{parameter-efficient} fine-tuning methods: 

\textbf{\basebase} $\:$ We compare our method to the standard practice of fine-tuning T5, where we fine-tune all parameters of the model on each individual task. 

\textbf{\adapter} $\:$ We compare to a strong adapter baseline~\citep{houlsby2019parameter}, which adds adapters for each task after the feed-forward and attention modules in each transformer block of T5. 

\textbf{\pfeifferadapter} $\:$ \citet{Pfeiffer2021adapterfusion} propose a more efficient adapter variant, which keeps only one of the adapters in each layer for better training efficiency. We experimented with keeping either adapter and found keeping the adapter after the self-attention module in each layer to perform the best.

\textbf{\adapterlowrank} $\:$ We parameterize each adapter's weight as a product of two rank-one weights. 

\textbf{\prompttuning} $\:$ Prompt tuning~\citep{lester2021power} is the successor variant of~\citet{li2021prefix}, which prepends a randomly initialized continuous prompt to the input (\prompttuningrandom). We also compare to a variant, which initializes prompts using token embeddings of the pretrained language model's vocabulary (\prompttuningtokens) \citep{lester2021power}.


\textbf{\intrinsic} $\:$ The Structure Aware Intrinsic Dimension \citep{aghajanyan2020intrinsic} fine-tunes the model by reparameterizing the parameters in a lower-dimensional subspace $\bm{\theta^{d^{\prime}}}$ ($d^{\prime} \ll D$): 
%\begin{align}
$\bm{\theta_i^D} = \bm{\theta^D_{i,0}} + \lambda_i \bm{P} \bm{\theta^{d^{\prime}-m}_i}$
%\end{align}
where parameter $\bm{\theta^D_{i,0}}$ are the pretrained model's parameters and $\bm{P} \in \mathbb{R}^{d^\prime-m}\to \mathbb{R}^D$ is a random linear projection via the Fastfood transform~\citep{le2013fastfood}. They then consider the total number of weight matrices in the PLM, $m$, and attribute a weight to each of them, resulting in $\bm{\lambda} \in\mathbb{R}^m$ in total by trading $m$ parameters from the low dimensional space $\bm{\theta^{d^{\prime}}} \in \mathbb{R}^{d^{\prime}}$. Then, the total trainable parameters are $\bm{\theta^{d^{\prime}-m}} \in \mathbb{R}^{d^{\prime} - m} $ and $\bm{\lambda}$.


\textbf{\adapterdrop} $\:$ We apply the method of~\citet{Ruckle2020adapterdrop}, which drops the adapters from lower transformer layers for a better training efficiency to T5 with \adapter. Consequently, we drop adapters from the first five layers of both the encoder and the decoder in \basebase.

\textbf{\bitfit} $\:$ ~\citet{cai2020tinytl} propose to freeze the weights and only train the biases. By not storing intermediate activations, this method enables substantial memory savings. \citet{ravfogel2021bitfit} study a similar method for PLMs that fine-tunes only the biases and the final output layer.\footnote{Note that in the HuggingFace T5 implementation, the biases in layer normalizations, linear layers, the output layer and self-attention layers are removed. We re-introduce these biases for \bitfit.} 

\subsection{Our Methods}

\textbf{\phmadapter} $\:$ We learn the weights of adapters using PHM layers as in \eqref{eq:phm-params}. To our knowledge, we are the first who exploit the idea of PHM~\citep{zhang2021beyond} for efficient \emph{fine-tuning} of large-scale language models. 

\textbf{\compacter} $\:$ We learn adapter weights using LPHM layers as described in~\eqref{eq:our_method}. We also explore a variant where we only keep the \compacter layer after the feed-forward layer in each transformer block (\compacteronlyff).\footnote{We found this to slightly outperform keeping the \compacter layer after the self-attention layer instead.}


\subsection{Results on the GLUE Benchmark}

Table~\ref{tab:glue_results} shows the results on \glue with \basebase\xspace (see Appendix \ref{app:model size} for results on \basesmall). \compacter and \compacteronlyff outperform all previous parameter-efficient methods and perform on par with full fine-tuning while only training 0.07\% and 0.047\% of parameters respectively. We now discuss the different methods in detail.



\begin{table}[tp]
\vspace{-1em}
\centering 
\caption{Performance of all models on the GLUE tasks. For each method, we report the total number of parameters across all tasks and the number of parameters that are trained for each task as a multiple and proportion of \basebase model \citep{raffel2019exploring}.
%as a multiple and proportion respectively of the corresponding single-task BERT model.
% Bold denotes the best result in each column; underline denotes the best result per within a section. 
For MNLI, we report accuracy on the matched validation set. For MRPC and QQP, we report accuracy and F1. For STS-B, we report Pearson and Spearman correlation coefficients. For CoLA, we report Matthews correlation. For all other tasks, we report accuracy. Bold fonts indicate the best results. For the results with $\dagger$, due to insatiability during training, we restarted experiments with 6 random seeds and report the best. For \intrinsic, $d^{\prime}$ is set to $20$K.}
\begin{adjustbox}{max width=\textwidth}
\begin{tabular}{l@{\hskip 0.05in}|l@{\hskip 0.05in}l@{\hskip 0.01in}|l@{\hskip 0.1in}l@{\hskip 0.1in}l@{\hskip 0.1in}l@{\hskip 0.1in}l@{\hskip 0.1in}l@{\hskip 0.1in}l@{\hskip 0.1in}l|l}
\toprule % / \textbf{task}
\textbf{Method} & \pbox{3cm}{\textbf{\#Total}\\ \textbf{params}} & \pbox{3cm}{\textbf{Trained} \\ \textbf{params /}\\ \textbf{per task\vspace{0.1em}}} & \textbf{CoLA} &    \textbf{SST-2} &   \textbf{MRPC} &   \textbf{QQP} &     \textbf{STS-B} & \textbf{MNLI}  &    \textbf{QNLI} & \textbf{RTE} &   \textbf{Avg} \\
\toprule 
\rowcolor{gray!20}\multicolumn{12}{c}{\it \textbf{Baselines}}\\
\midrule 
\basebase &  $8.0\times1$ &   $100\%$ & 61.76 &  \textbf{94.61} &  \textbf{90.20/93.06} &  \textbf{91.63/88.84} &  89.68/89.97 &  \textbf{86.78} &  93.01 &  71.94 &  \textbf{86.50} \\ % lr=3e-4
\midrule 

% total = 224689536 base=222882048
%\adapter& 1.0649 & 11.89\% & 61.80 &  94.15 &  88.24/91.67 &  90.27/87.05 &  91.51/91.71 &  86.02 &  92.64 &  76.26 &  86.48 \\ % this is with classifier
\adapternoclf  & 1.065 & 0.832\% & \textbf{64.02} &  93.81 &  85.29/89.73 &  90.18/87.20 &  90.73/91.02 &  86.49 &  93.21 &  71.94 &  85.78 \\ %1.065
%rate = 0.832, total_params=1.0649   % lr=0.0003, and for now without adapter layer norms. 
\pfeifferadapternoclf &1.032 &0.427\%& 62.9 &  93.46 &  86.76/90.85 &  90.14/87.15 &  91.13/91.34 &  86.26 &  93.30 &  \textbf{76.26} &  86.32 \\ %rate=0.427, total_params=1.0324  lr=3e-4
%\pfeifferadapter &1.0324 & 11.49\% & 63.91 &  94.15 &  88.73/91.99 &  90.24/87.03 &  90.25/90.51 &  85.66 &  93.06 &  73.38 &  86.26 \\ %lr=0.003 
\adapterdropnoclf &1.038&0.494\% & 62.7 &  93.58 &  86.27/90.60 &  90.2/87.25 &  \textbf{91.37/91.61} &  86.27 &  93.23 &  71.22 &  85.85 \\ % total_params= 1.0378 rate=0.494\%
%\adapterdrop &1.0378&11.56\%&61.67 &  93.69 &  84.80/89.20 &  90.14/87.17 &  90.92/91.34 &  86.24 &  93.23 &  73.38 &  85.62 \\ % 3e-4
%Hyperformer &&& \\
\adapterlowrank &  1.004 & 0.073\% &  59.19 &  93.69 &  88.24/91.49 &  90.23/87.01 &  90.8/91.33 &  85.8 &  92.9 &  73.38 &  85.82\\ 
\midrule 
\prompttuningrandom &1.003 & 0.034\%&  0.47$^\dagger$ &  87.61 &  68.14/81.05 &  88.93/85.55 &  90.25/90.59 &  46.83$^\dagger$ &  92.33 &  54.68 & 71.49  \\ % total_params=1.0028, rate = 0.034\%
\prompttuningtokens &1.003 & 0.034\%& 10.59 &  90.94 &  68.14/81.05 &  89.69/86.14 &  89.84/90.21 &  81.46 &  92.75 &  54.68 &  75.95  \\ % total_params=1.0028 rate= 0.034\%
\midrule 
% all of these were with lr=0.003 and I am running with larger lrs as well and more intrinsic-dimensions as well.
%\intrinsic-400 &1.0 & 0.0002\%&  0.0 &  92.55 &  78.43/85.62 &  90.25/87.19 &  90.43/90.66 &  69.93 &  89.31 &  58.99 &  75.76 \\
%\intrinsic-1400 &1.0 &  0.0006\% &52.4 &  93.35 &  89.22/92.41 &  90.44/87.31 &  89.86/90.23 &  82.01 &  93.12 &  67.63 &  84.36 \\
%\intrinsic-2500 &1.0 & 0.0011\%& 45.78 &  93.92 &   89.22/92.2 &  90.43/87.37 &   90.32/90.9 &  82.86 &  93.17 &  64.03 &  83.65 \\
%\intrinsic-10000 &1.0 & 0.0045\%& 56.13 &  93.58 &  88.73/91.99 &  90.34/87.18 &  90.63/90.99 &  84.84 &  93.36 &  71.22 &  85.36 \\
\intrinsic &1.001& 0.009\%& 58.69 &  94.15 &  88.24/91.78 &  90.28/87.13 &  90.06/90.45 &  85.23 &  \textbf{93.39} &  70.50 &  85.45 \\% rate=0.009\% %\intrinsic-20000
%\midrule
\bitfitnoclf &1.010&0.126\%&  58.16 &  94.15 &  86.76/90.53 &  90.06/86.99 &  90.88/91.26 &  85.31 &  92.99 &  67.63 &  84.97 \\ % total_params=1.0101 rate=0.126\%
%\bitfit & 1.0101 &11.19\%&57.13 &  94.15 &  89.71/92.78 &  90.07/87.02 &  90.91/91.22 &  85.34 &  93.06 &  68.35 &  85.43 \\
\midrule 
\rowcolor{gray!20}\multicolumn{12}{c}{\it \textbf{Our Proposed Methods}}\\
\midrule 
% lr=0.003
%\phmadapter-4 ~\ding{171} &1.0021 &0.24\% & 59.21 &  93.69 &  87.25/90.91 &  90.23/86.99 &  90.55/90.73 &  85.93 &  93.04 &  69.78 &  85.30  \\
%\phmadapter($n=8$) &1.011 &0.16\% & 61.84 &  93.58 &  91.18/93.57 &  90.25/87.08 &  90.74/91.07 &  85.74 &  92.93 &  70.50 &  86.23 \\ % total_params=1.0111, rate = 0.160\% 
\phmadapter ($n=12$) &1.013 & 0.179\% & 57.35 &  \textbf{94.50} &  \textbf{91.67/93.86} &  \textbf{90.25/87.05} &  90.45/90.84 &  \textbf{85.97} &  92.92 &  75.54 &  86.40  \\
\midrule 
% task reduction factor = {8, 16, 32} lr=0.003
\compacter ($n=4$) &1.004& 0.073\%& \textbf{63.75} &  93.00 &  89.22/92.31 &  90.23/87.03 &  90.31/90.74 &  85.61 &  92.88 &  \textbf{77.70} &  \textbf{86.62} \\ % total_params= 1.0041 rate = 0.073\%
%\compacter-8 & 1.0005&0.07\%&61.78 &  93.81 &    90.2/93.1 &  90.23/87.03 &  90.16/90.44 &  85.78 &  93.08 &  74.1 &  86.34 \\ 
%\compacter-12 &1.0005&0.07\%& 61.38 &  93.69 &  91.18/93.71 &  90.11/86.88 &  90.53/90.98 &  85.76 &  93.12 &  70.5 &  86.17 \\ 
\midrule 
%\compacter-4-no-warmup &1.0005& 0.07\% &  61.23 &  93.69 &  88.24/91.89 &  90.13/86.86 &   91.07/91.2 &  85.84 &  92.35 &  74.82 &  86.12 \\
%\compacter-8-no-warmup &1.0005& 0.07\% &   63.77 &  93.46 &  88.73/92.26 &  90.19/87.04 &  90.27/90.66 &  85.98 &  92.93 &  74.82 &  86.37 \\
%\compacter-12-no-warmup &1.0005& 0.07\% &  58.34 &  93.69 &  92.16/94.33 &  90.24/87.04 &   90.4/90.71 &  85.58 &  92.90 &  74.82 &  86.38 \\
%\midrule
\compacteronlyff ($n=4$)& 1.002&  0.047\%&  61.27 &  93.81 &  90.69/93.33 &  90.17/86.93 &  \textbf{90.46/90.93} &  85.71 &  \textbf{93.08} &  74.82 &  86.47 \\ %total_params=1.0020, rate=0.047\%  % \compacter-4-only-FFD 
%\compacter-8-only-FFD  &1.0003&0.05\%&  62.79 &  92.55 &  88.24/91.95 &  90.16/86.94 &  90.43/90.78 &  85.36 &  92.82 &  73.38 &  85.95 \\
%\compacter-12-only-FFD  &1.0003&0.05\%&  63.01 &  93.92 &  91.18/93.75 &  90.23/87.01 &   90.4/90.65 &  85.46 &  92.88 &  71.22 &  86.34 \\
\bottomrule
\end{tabular}
\end{adjustbox}
 %All values are scaled by 100.
\label{tab:glue_results} \vspace{-1em}
\end{table} 


\noindent \textbf{Adapter-based methods} $\:$ For \adapternoclf, not fine-tuning the classifier hurts the performance substantially (85.78 versus 86.48; cf. Appendix \ref{app:with_lm_head}). \pfeifferadapter, which adds adapters only after the self-attention module outperforms the standard \adapter while being more parameter-efficient. \adapterdrop obtains lower performance than fine-tuning, demonstrating that adapting the lower layers of an encoder-decoder T5 model is important for its performance. Additionally, \adapterlowrank is not expressive enough to perform well on this benchmark.

\noindent \textbf{Prompt tuning and BitFit} $\:$ For \prompttuning, we observe high sensitivity to initialization and learning rate, as also confirmed in \cite{li2021prefix}. We experimented with multiple random seeds but performance lags behind fine-tuning substantially, in particular on low-resource datasets. This can be explained by the low flexibility of such methods as all the information needs to be contained in the prefixes. As a result, the method only allows limited interaction with the rest of the model and good performance requires very large models \citep{lester2021power}. In addition, increasing the sequence length leads to memory overhead (see \textsection \ref{sec:performance}) and the number of prompt tokens is limited by the number of tokens that can fit in the model's maximum input length, which makes such methods less flexible and unsuitable for dealing with large contexts.
% becoming less flexible to increase the capacity of such methods. 
Similarly, \bitfit performs worse than fine-tuning, especially on low-resource datasets. 

\noindent \textbf{Intrinsic-SAID} $\:$ Interestingly, the average performance of \intrinsic, which fine-tunes only 0.009\% of a model's parameters is only 1.05 points below the fine-tuning baseline. However, this method has two practical drawbacks: a) storing the random projection matrices results in a substantial memory overhead;  b) it is very slow to train (see \textsection \ref{sec:performance}). Despite this, \intrinsic provides insights regarding the effectiveness of low-rank optimization of pretrained language models \citep{aghajanyan2020intrinsic}, which motivates the development of parameter-efficient methods such as \compacter.


\noindent \textbf{\compacter} $\:$ For our proposed methods, we observe fine-tuning the output layer for both \phmadapter and \compacteronlyff does not provide much performance difference (see Appendix \ref{app:with_lm_head}). \phmadapter reduces the parameters of \adapternoclf from 0.83\% to 0.179\% (with $n=12$), being 4.64$\times$ more parameter-efficient. 
% Compared to \adapter, it trains 74.31$\times$ less parameters, while providing similar or better performance. 
\compacter reduces the number of parameters to the remarkable rate of 0.073\% while obtaining comparable results to full fine-tuning. By removing the \compacter layer after self-attention, \compacteronlyff obtains similar performance, while reducing the parameters to 0.047\%. Adaptation without updating the layer normalization can be a promising direction to reduce the parameters further, for instance by building on recent advances in normalization-free models~\citep{brock2021high}, which we leave to future work. 


\subsection{Results on the \superglue Benchmark} 
Table \ref{tab:superglue_results} shows the performance of the methods on \superglue \citep{wang2019superglue}. We include the results for all values of $n$ in Appendix~\ref{app:superglue}.  We observe a similar pattern as on \glue in Table~\ref{tab:glue_results}. \compacter and \compacteronlyff perform substantially better compared to other parameter-efficient fine-tuning methods and even outperform full fine-tuning while only training 0.073\% and 0.048\% of the parameters.

\begin{table}[tp] % change to [tp]
\centering 
\caption{Performance of all methods on the \superglue tasks. For each method, we report the total number of parameters across all tasks and the percentage of parameters that are trained for each task as a multiple and proportion of \basebase model \citep{raffel2019exploring}. For CB, we report accuracy and F1. For MultiRC, we report  F1 over all answer-options (F1$_a$) and exact match of each question's set of answers (EM) \cite{wang2019superglue}. For ReCoRD, we report F1 and EM scores. For all other tasks, we report accuracy. For \intrinsic, $d^{\prime}$ is set to $20$K.  Bold fonts indicate the best results in each block.} 
\begin{adjustbox}{max width=\textwidth}
\begin{tabular}{l@{\hskip 0.02in}|l@{\hskip 0.06in}l@{\hskip 0.0in}|l@{\hskip 0.08in}l@{\hskip 0.08in}l@{\hskip 0.08in}l@{\hskip 0.08in}l@{\hskip 0.08in}l@{\hskip 0.08in}|l}
\toprule % / \textbf{task}
\textbf{Method} & \pbox{3cm}{\textbf{\#Total}\\ \textbf{params}} & \pbox{3cm}{\textbf{Trained} \\ \textbf{params /}\\ \textbf{per task\vspace{0.1em}}} & \textbf{BoolQ} &    \textbf{CB} &   \textbf{COPA} &   \textbf{MultiRC} &     \textbf{ReCoRD} & \textbf{WiC}  & \textbf{Avg} \\
\toprule 
\rowcolor{gray!20}\multicolumn{10}{c}{\it \textbf{Baselines}}\\
\midrule 
\basebase &  6.0$\times$1 &   100\%  &   81.10 &  \textbf{85.71/78.21} &            52.0 &        68.71/47.0 &      74.26/73.33 &          \textbf{70.22} &  70.06 \\
\adapter& 1.049& 0.832\% & 82.39 &  85.71/73.52 &            52.0 &       72.75/53.41 &      74.55/73.58 &          67.08 &  70.55\\
\pfeifferadapter &1.024&0.427\%& \textbf{82.45} &  85.71/75.63 &            54.0 &       72.53/51.76 &       74.69/73.70 &          68.65 &  \textbf{71.01}\\
\adapterdrop & 1.028&0.494\% &  82.26 &  85.71/75.63 &            42.0 &        \textbf{72.92/53.30} &       74.68/73.70 &          68.34 &  69.84\\ 
\adapterlowrank &  1.003 & 0.073\% & 80.31 &  78.57/55.37 &            54.0 &       72.58/51.98 &      74.77/73.87 &          64.58 &  67.34 \\
\midrule 
\prompttuningrandom &1.002 & 0.034\%& 61.71 &  67.86/46.99 &            48.0 &       59.23/16.33 &      75.27/74.36 &           48.90 &  55.41 \\ 
\prompttuningtokens &1.002 & 0.034\%&  61.71 &  67.86/46.89 &            52.0 &       57.66/19.44 &      \textbf{75.37/74.41} &           48.90 &  56.03 \\
\midrule 
\intrinsic &1.001& 0.009\%&  78.72 &   75.00/51.83 &            54.0 &       69.98/52.78 &      74.86/73.91 &          65.83 &  66.32 \\ % lr=3e-3 
\bitfit &1.008&0.126\%& 79.57 &   78.57/54.40 &            \textbf{56.0} &       70.73/48.57 &      74.64/73.64 &          69.59 &  67.30 \\
\midrule 
\rowcolor{gray!20}\multicolumn{10}{c}{\it \textbf{Our Proposed Methods}}\\
\midrule 
\phmadapter ($n=4$)& 1.013 &0.240\% & \textbf{80.31} &  85.71/73.52 &            44.0 &       \textbf{71.99/51.65} &       \textbf{74.62/73.60} &          67.40 &  69.20\\
%\phmadapter ($n=8$) &1.011 &0.160\% &79.39 &  82.14/69.87 &            44.0 &       71.49/50.77 &      74.46/73.48 &          67.71 &  68.15  \\
%\phmadapter ($n=12$)&1.013 & 0.179\% &79.33 &  78.57/75.43 &            52.0 &       70.48/50.66 &      74.14/73.14 &          68.65 &  69.16\\
\midrule 
%\compacter ($n=4$) &1.004& 0.073\%& 79.88 &  89.29/82.51 &            42.0 &       71.87/51.98 &   74.64/73.59       & 65.83 & 70.18 \\
%\compacter ($n=8$) &1.004& 0.073\%&  79.57 &  85.71/80.06 &            56.0 &       70.75/49.67 &    74.56/73.57     &  70.85 & 71.19 \\
\compacter ($n=12$)&1.003& 0.073\%&  78.59 &  \textbf{96.43/87.44} &            48.0 &        70.80/49.67 &   74.49/73.54       & 65.20 & 71.57\\
\midrule 
%\compacteronlyff ($n=4$)& 1.002&  0.047\%&       79.94 &  85.71/80.06 &            50.0 &       72.16/50.33 &       74.63/73.6 &          68.34 &  70.53 \\
%\compacteronlyff ($n=8$)& 1.002&  0.047\%&           78.23 &  82.14/70.87 &            48.0 &       71.61/51.43 &      74.62/73.64 &          67.71 &  68.69 \\
\compacteronlyff ($n=12$)& 1.002&  0.048\%&            78.84 &  92.86/84.96 &            \textbf{52.0} &       70.68/50.99 &       74.55/73.50 &          \textbf{68.03} &  \textbf{71.82} \\
\bottomrule
\end{tabular}
\end{adjustbox}
\label{tab:superglue_results} \vspace{-1em}
\end{table} 


\subsection{Efficiency Evaluation} \label{sec:performance}
In this section, we compare the efficiency of our proposed methods with various recently proposed parameter-compact fine-tuning methods under the same computation budget. To this end,  we train all methods for 1 epoch on the MNLI dataset. For each method,  we select the largest batch size that fits a fixed budget of the GPU memory (24 GB). For all adapter-based methods, we fix the adapter size to 24. For \prompttuning, we set the number of prefix tokens to 100. For \intrinsic, we set $d^{\prime}=1400$. Finally, we set $n=4$. In Table~\ref{tab:performance}, we report the percentage of trained parameters per task, training time per epoch, and memory usage of each method. %per-sample
Moreover, Figure \ref{fig:comparison} shows the trade-off between quantitative performance, percentage of trained parameters, and memory footprint. 
\begin{table}[tp] 
\centering
\caption{Percentage of trained parameters per task, average peak memory and training time for all methods. $\bm{\Delta \%}$ is the relative difference with respect to \emph{full fine-tuning} (\basebase). Lower is better.}
\begin{tabular}{llllll} %rrrrr}
    \toprule 
    \textbf{Method} &\pbox{3cm}{\textbf{Trained params/}\\ \textbf{per task\vspace{0.1em}}} &\pbox{3cm}{\textbf{Memory}\\ \textbf{(MB)\vspace{0.1em}}} & $\bm{\Delta \%}$ & \pbox{3cm}{\textbf{Time/Epoch}\\ \textbf{ (min)\vspace{0.1em}}} & $\bm{\Delta \%}$\\
    \toprule 
    \basebase &100\% &167.99  &  ---  &  42.13  &  ---\\ 
    %\adapter & 126.18  &  -33.14\%  &  36.70  &  -12.89\% \\ 
    \adapternoclf  &0.832\% &124.02  &  -35.45\%  &  31.81  &  -24.50\% \\ 
    %\pfeifferadapter & 120.60  &  -39.30\%  &  31.98  &  -24.09\% \\ 
    \pfeifferadapternoclf &0.427\%&118.4  &  -41.88\%  &  28.19  &  -33.09\%\\
    %\adapterdrop &121.51  &  -38.25\%  &  30.03  &  -28.72\% \\
    \adapterdropnoclf &0.494\%&119.41  &  -40.68\%  &  28.08  &  -33.35\%\\
    \adapterlowrank & 0.073\% & 123.8  &  -35.69\%  &  32.71  &  -22.36\% \\
    \prompttuning &0.034\%& 222.27  &  24.42\%  &  44.54  &  5.72\% \\ 
    \intrinsic &0.009\%&285.40  &  41.14\%  &  144.01  &  241.82\% \\
    %\bitfit &104.04  &  -61.47\%  &  28.83  &  -31.57\%\\
    \bitfitnoclf &0.126\%& 102.31  &  -64.20\%  &  27.36  &  -35.06\%\\
    \midrule 
    \phmadapter &0.179\%& 123.93  &  -35.55\%  &  35.55  &  -15.62\%  \\ % the version with kp
    \compacter &0.073\%& 123.91  &  -35.57\%  &  36.48  &  -13.41\% \\% the version with kp
    \compacteronlyff &0.047\%&118.35  &  -41.94\%  &  30.96  &  -26.51\%\\% the version with kp
    \bottomrule
    \end{tabular}
    \vspace{-0.5em}
\label{tab:performance}
\end{table}

Our approaches have several attractive properties. Based on our analysis in Table~\ref{tab:glue_results}, \compacter and \compacteronlyff obtain the best combination of high  \glue score averaged across all tasks, plus a substantially lower number of parameters (0.073\% and 0.047\% respectively).  
In addition to \compacteronlyff performing well, its memory requirement is the second best among all methods, reducing  memory usage by -41.94\% compared to \basebase. \compacter and \compacteronlyff also speed up training substantially, by -13.41\% and -26.51\% relative to \basebase. On the other hand, \bitfit, by not storing intermediate activations, has the lowest memory requirement (-64.2\% relative to \basebase) and is the fastest (-35.06\% relative to \basebase) at the cost of lower quantitative performance  (1.53 points lower; see Table~\ref{tab:glue_results}).


Methods relying on pruning adapters, i.e., \pfeifferadapter and \adapterdrop reduce the memory overhead and improve training  time. However, their number of parameters is almost an order of magnitude more compared to \compacteronlyff, with 9.1$\times$ and 10.5$\times$ more parameters respectively. Moreover, although, \pfeifferadapter performs on par with full fine-tuning with a slight degradation (Table \ref{tab:glue_results}), \adapterdrop obtains a lower performance (-0.65 less on average across all tasks.). We note that dropping adapters from transformer layers is a general technique and could be applied to \compacter for improving efficiency even further, which we leave to future work. Similarly, although \adapterlowrank reduces the memory overhead and improves the training time, it obtains a lower performance (Table~\ref{tab:glue_results}) (-0.68 less on average across all tasks.).

At the other end of the spectrum, \intrinsic and \prompttuning methods have the lowest number of parameters. However, they both come with high memory overhead (41.14\% and 24.42\% relative to full fine-tuning (\basebase) respectively), are slowest to train, and their performance substantially lags behind full fine-tuning (see Table \ref{tab:glue_results}). For \prompttuning, high memory costs are due to the fact that the computational complexity of self-attention, which requires storing the full attention matrix for gradient computation, scales quadratically with the sequence length \cite{wang2020linformer}. For  \intrinsic, the high memory requirement is due to storing large random projection matrices, which limits the application of \intrinsic for fine-tuning large-scale PLMs. Moreover, computing projections via FastFood transform, although theoretically possible in $O(D \log d^{\prime})$~\citep{le2013fastfood}, is slow in practice even with a CUDA implementation. For pretrained language models with a large number of parameters, allocating random projections for the full parameter space is intractable.
While using Fastfood transform partially ameliorates this issue by reducing the memory usage from $\mathcal{O}(Dd^{\prime})$ to $\mathcal{O}(D)$, the memory issue with such methods remains unresolved.


% one line summary comes here.
Overall, given the size of large-scale transformer models with millions and billions of parameters, such as T5~\citep{raffel2019exploring}, efficient memory usage is of paramount importance for practical applications. \compacter and \compacteronlyff offer a great trade-off in terms of performance, memory usage, and training time. With regard to our inspiration of von Neumann's quotation, we thus find that only a comparatively small number of additional parameters are necessary for the practical and efficient adaptation of PLMs.

\subsection{Low-resource Fine-tuning} \label{sec:low_resource}
\compacteronlyff has substantially fewer parameters compared to \basebase. In this section, we investigate whether this could help \compacteronlyff to generalize better in resource-limited settings. We subsample each dataset of GLUE for varying sizes in the range $\{100, 500, 1000, 2000, 4000\}$. Figure \ref{fig:lowresource_results} shows the results. \compacteronlyff substantially improves the results in the low-resource setting, \change{indicating more effective fine-tuning in this regime.} 
\begin{figure}[tp]
\centerline{
\includegraphics[width=0.5\textwidth]{figures/lowresource_plot.pdf}}\vspace{-0.6em}
\caption{Results on GLUE for the various number of training samples per task $(100, 500, 1000, 2000, 4000)$. We show mean and standard deviation across 5 seeds.} \vspace{-.5em}
\label{fig:lowresource_results}
\end{figure}

\vspace{-0.5em}
\section{Related Work}
\noindent \textbf{Adapters} $\:$ Adapters have recently emerged as a new paradigm for fine-tuning pretrained language models~\citep{houlsby2019parameter}. In another line of work, \citet{ustun2020udapter} proposed a multilingual dependency parsing method based on adapters and contextual parameter generator networks~\citep{platanios2018contextual}, where they generate adapter parameters conditioned on trained input language embeddings. This, however, leads to a large number of additional parameters compared to the base model. Contemporaneously,~\citet{karimi2021parameter-efficient}  use a single compact hypernetwork allowing to generate adapter weights efficiently conditioned on multiple tasks and layers of a transformer model. \citet{pilault2021conditionally} also proposed a task-conditioned transformer for multi-task learning which is less parameter-efficient. The aforementioned work is complementary to \compacter, and one could potentially combine \compacter with contextual parameter generation to generate adapter modules. Compared to~\citet{karimi2021parameter-efficient}, \compacteronlyff reduces the parameters by 6.2$\times$. 



\noindent \textbf{Hypercomplex representations} $\:$ Deep learning advances in the hypercomplex domain are in a nascent stage, and most work is fairly recent~\citep{gaudet2018deep, parcollet2018quaternion, parcollet2018quaternion_b, zhu2018quaternion, tay2019lightweight}. Replacing matrix multiplications in standard networks with Hamilton products that have fewer degrees of freedom offers up to a 4$\times$ saving of parameter size in a single multiplication operation~\citep{parcollet2018quaternion_b, tay2019lightweight}. Very recently, ~\citet{zhang2021beyond} extend such methods in a way that they could reduce the parameters of a fully connected layer under a mild condition to $1/n$, where $n$ is a user-specified parameter. To the best of our knowledge, there is no previous work that attempts to leverage the hypercomplex space for efficient fine-tuning of large-scale language models.


\noindent \textbf{Other parameter-efficient models} $\:$ \citet{li2018measuring} and \citet{aghajanyan2020intrinsic} study training models in  a low-dimensional randomly oriented subspace instead of their original parameter space. Another recent line of work has shown that pretrained models such as BERT are redundant in their capacity, allowing for significant sparsification without much degradation in end metrics~\citep{chen2020lottery, prasannaetal2020bert, desaietal2019evaluating}. Such methods, however, remain not well supported by current hardware and often perform worse compared to dedicated efficient architectures \citep{blalock2020state}.






\vspace{-0.5em}
\section{Conclusion}
We have proposed \compacter, a light-weight fine-tuning method for large-scale language models. \compacter generates weights by summing Kronecker products between shared ``slow'' weights and ``fast'' rank-one matrices, specific to each \compacter layer. Leveraging this formulation, \compacter reduces the number of parameters in adapters substantially from $\mathcal{O}(kd)$ to $\mathcal{O}(k+d)$. Through extensive experiments, we demonstrate that despite learning 2127.66$\times$ fewer parameters than standard fine-tuning, \compacter obtains comparable or better performance in a full-data setting and outperforms fine-tuning in data-limited scenarios. 

\section*{Acknowledgements}
We are grateful to Dani Yogatama for feedback on a draft of this manuscript. The authors would like to thank Tuan Le for his assistance in reproducing the results of~\citet{zhang2021beyond}. We would like to also thank Armen Aghajanyan for his assistance to reproduce the results of his work~\citep{aghajanyan2020intrinsic}. We thank Jue Wang for his comments on an earlier version of this paper. The authors are grateful to Brian Lester, Rami Al-Rfou, Noah Constant, and Mostafa Dehghani for their assistance. Rabeeh Karimi Mahabadi was supported by the Swiss National Science Foundation under the project Learning Representations of Abstraction for Opinion Summarization (LAOS), grant number FNS-30216. 



% Entries for the entire Anthology, followed by custom entries
{%\bibliographystyle{ieee}
\bibliographystyle{unsrtnat}
\bibliography{ref}} 



\clearpage
\appendix
\section{Experimental Details} \label{app:experimental_detials}
\paragraph{Datasets} We run all experiments on the standard \glue benchmark~\citep{wang2018glue} with Creative Commons license (CC BY 4.0) and the \superglue benchmark~\cite{wang2019superglue}. These benchmark consist of multiple datasets: CoLA~\citep{warstadt-etal-2019-neural}, SST-2~\citep{socher-etal-2013-recursive}, MRPC~\citep{dolan-brockett-2005-automatically}, QQP\footnote{ \url{https://data.quora.com/First-Quora-Dataset-Release-Question-Pairs}}, STS-B~\citep{cer-etal-2017-semeval}, MNLI~\citep{williams-etal-2018-broad}, QNLI~\citep{rajpurkar-etal-2016-squad}, and RTE, which is a combination of data from RTE1~\citep{dagan2005pascal}, RTE2~\citep{rte2}, RTE3~\citep{giampiccolo-etal-2007-third}, RTE5~\citep{Bentivogli09thefifth}, COPA~\citep{roemmele2011choice}, CB~\citep{de2019commitmentbank}, MultiRC~\citep{khashabi2018looking}, ReCoRD~\citep{zhang2018record}, BoolQ~\citep{clark-etal-2019-boolq}, and WiC~\citep{pilehvar2019wic} where sentences are selected from VerbNet~\citep{schuler2005verbnet}, WordNet~\citep{miller1995wordnet}, and Wiktionary. We download all datasets from the HuggingFace Datasets library \citep{2020HuggingFace-datasets}. 

\paragraph{Low-resource fine-tuning} For the experiment conducted in \textsection \ref{sec:low_resource}, we set the number of epochs to 1000, 200, 100, 50, 25, for datasets subsampled to size 100, 500, 1000, 2000, and 4000 respectively. Based on our results, this is sufficient to allow the models to converge. We save a checkpoint every 250 steps for all models and report the results for the hyper-parameters performing the best on the validation set for each task.  %We train all models for 3000 steps

\paragraph{Data pre-processing:} \change{Following~\citet{raffel2019exploring}, we cast all datasets into a sequence-to-sequence format. We recast STS-B as a 21-class classification task by rounding its target scores to their nearest increment of 0.2.}

\paragraph{Computing infrastructure:} \change{We run the experiments in Table~\ref{tab:glue_results},  \ref{tab:superglue_results}, \ref{tab:glue_results_small_model}, and~\ref{tab:performance} on one \textsc{Nvidia GeForce RTX 3090}, and experiments in \textsection\ref{sec:low_resource} on one \textsc{GeForce GTX 1080 Ti}} GPU. 


\paragraph{Training hyper-parameters:} For the experiments on \glue, we set the maximum sequence length to 128 and batch size to 100. Following~\citet{raffel2019exploring}, we use maximum sequence length of 256 for the tasks in \superglue, and for ReCoRD, we set it to 512. We used batch size of 32 for \superglue, and for ReCoRD, we set it to 16 due to the GPU memory limit. For results in  \textsection\ref{sec:low_resource}, we set the batch size to 40 to match the lower GPU memory of \textsc{GeForce GTX 1080 Ti} GPU. For setting the learning rates, we trained all methods with $3\mathrm{e}{-5}$,  $3\mathrm{e}{-4}$,  $3\mathrm{e}{-3}$,  $3\mathrm{e}{-2}$, and  $3\mathrm{e}{-1}$ and use the learning rate performing the best on the validation set for each method. Table~\ref{tab:lrs} shows the final selected learning rate for each method reported in Table~\ref{tab:glue_results}. For the method variants where we also fine-tune the final output layer (Table~\ref{tab:glue_results_with_lm_head}), we report the selected learning rate in Table~\ref{tab:lrs_with_lm_head}. We train all models with the AdamW optimizer from the HuggingFace library \citep{wolf-etal2020transformers} with default hyper-parameters of $\beta_1=0.9$, $\beta_2=0.999$, $\epsilon=1\mathrm{e}{-8}$. We set warm-up steps to 500 for all methods in Table \ref{tab:glue_results} and \ref{tab:glue_results_with_lm_head}. We set the warm-up steps to 0 for all methods in Table \ref{tab:superglue_results} and \ref{tab:glue_results_small_model}, which based on our experiments, improved the results for all methods.


\begin{table}[tp]
    \begin{minipage}{.5\linewidth}
    \caption{Selected learning rates for all methods.}
    \centering
    \begin{tabular}{ll}
    \toprule
    \textbf{Method} & \textbf{Learning rate}   \\
    \midrule  
     \basebase    &  $3\mathrm{e}{-4}$ \\ 
     \adapternoclf & $3\mathrm{e}{-4}$ \\
     \pfeifferadapternoclf & $3\mathrm{e}{-4}$ \\
     \adapterdropnoclf & $3\mathrm{e}{-4}$\\ 
     \adapterlowrank & $3\mathrm{e}{-3}$\\
     \prompttuningrandom &  $3\mathrm{e}{-2}$ \\
     \prompttuningtokens & $3\mathrm{e}{-1}$\\
     \intrinsic & $3\mathrm{e}{-2}$\\ 
     \bitfitnoclf & $3\mathrm{e}{-4}$ \\ 
     \phmadapternoclf &  $3\mathrm{e}{-3}$ \\ 
     \compacternoclf &  $3\mathrm{e}{-3}$\\ 
     \compacteronlyffnoclf &  $3\mathrm{e}{-3}$\\
    \bottomrule
    \end{tabular}
     \label{tab:lrs}
    \end{minipage}\quad
    \begin{minipage}{.5\linewidth}
    \vspace{-3.2em}
      \centering
       \caption{Selected learning rates for all methods, when we also fine-tune the output layer.}
       \begin{tabular}{ll}
    \toprule
    \textbf{Method} & \textbf{Learning rate}   \\
    \midrule  
    \adapter   & $3\mathrm{e}{-3}$ \\ 
    \pfeifferadapter & $3\mathrm{e}{-4}$\\
    \adapterdrop &  $3\mathrm{e}{-4}$\\ 
    \adapterlowrank & $3\mathrm{e}{-3}$\\ 
    \bitfit &$3\mathrm{e}{-4}$ \\ 
    \phmadapter &  $3\mathrm{e}{-3}$ \\ 
    \compacter & $3\mathrm{e}{-3}$ \\ 
    \compacteronlyff & $3\mathrm{e}{-3}$ \\ 
    \bottomrule
    \end{tabular}
     \label{tab:lrs_with_lm_head}
    \end{minipage} 
\end{table}

\iffalse 
\begin{table}[tp]
    \centering
    \caption{Selected learning rates for all methods.}
    \begin{tabular}{ll}
    \toprule
    \textbf{Model} & \textbf{Learning rate}   \\
    \midrule  
     \basebase    &  $3\mathrm{e}{-4}$ \\ 
     \adapternoclf & $3\mathrm{e}{-4}$ \\
     \pfeifferadapternoclf & $3\mathrm{e}{-4}$ \\
     \adapterdropnoclf & $3\mathrm{e}{-4}$\\ 
     \prompttuningrandom &  $3\mathrm{e}{-2}$ \\
     \prompttuningtokens & $3\mathrm{e}{-1}$\\
     \intrinsic & $3\mathrm{e}{-2}$\\ 
     \bitfitnoclf & $3\mathrm{e}{-4}$ \\ 
     \phmadapternoclf &  $3\mathrm{e}{-3}$ \\ 
     \compacternoclf &  $3\mathrm{e}{-3}$\\ 
     \compacteronlyffnoclf &  $3\mathrm{e}{-3}$\\
    \bottomrule
    \end{tabular}
    \label{tab:lrs}
\end{table}
\begin{table}[tp]
    \centering
    \caption{Selected learning rate for each method, when we also fine-tune the output layer.}
    \begin{tabular}{ll}
    \toprule
    \textbf{Model} & \textbf{Learning rate}   \\
    \midrule  
    \adapter   & $3\mathrm{e}{-3}$ \\ 
    \pfeifferadapter & $3\mathrm{e}{-4}$\\
    \adapterdrop &  $3\mathrm{e}{-4}$\\ 
    \bitfit &$3\mathrm{e}{-4}$ \\ 
    \phmadapter &  $3\mathrm{e}{-3}$ \\ 
    \compacter & $3\mathrm{e}{-3}$ \\ 
    \compacteronlyff & $3\mathrm{e}{-3}$ \\ 
    \bottomrule
    \end{tabular}
    \label{tab:lrs_with_lm_head}
\end{table}
\fi 

\section{Impact of Hyper-parameters} \label{app:ablations}
In this section, we study the impact of hyper-parameters for each method reported in Table~\ref{tab:glue_results}. We report the results in Table~\ref{tab:ablations}.

\textbf{Impact of dimension ($d^{\prime}$) on \intrinsic} $\:$ Increasing the dimension $d^{\prime}$ for \intrinsic method often improves results. Though, as discussed in ~\citep{aghajanyan2020intrinsic}, $d^{\prime}$ is task-dependent so needs to be tuned for every new dataset to achieve optimal performance.
% needs to be tuned per dataset, and is quantified by the smallest $d^{\prime}$ which can provide 0.9 performance of the full training metric~\citep{li2018measuring}. 

\paragraph{Impact of $n$ on \phmadapter:}  Table~\ref{tab:ablations} shows the results for varying values of $n=\{4, 8, 12\}$. We experiment with adapters of bottleneck size $d \in \{24, 48, 96\}$.

For the \basebase model with $k=768$, the condition $kd>n^4$ discussed in \textsection\ref{sec:parameter_efficiency} is partially satisfied for $d=24$ and $n=4,8$ and fully satisfied for $d\in\{48, 96\}$ and $n=4,8,12$. Note that this condition is satisfied for larger versions of the T5 model, i.e., T5-large (770 million parameters, $k=1024$), T5-3B (2.8 billion parameters, $k=1024$), and T5-11B (11 billion parameters, $k=1024$) with adapter hidden size $d\in\{24, 32, 48, 96\}$ and $n = 2,4,8,12$. Due to the huge computational costs of training these models, we could not run experiments on such a large scale. Nevertheless, we observe substantial parameter reduction using \phmadapter. 

In Table~\ref{tab:ablations}, we report the number of parameters for $d=24$ for all methods. Compared to \adapter, \phmadapter with $n=8$ reduces the parameters substantially by 5.2$\times$.


\paragraph{Impact of $n$ on \compacter:} For \compacter and \compacteronlyff, we observe that the number of trainable parameters is almost constant across different values of $n$.  This is due to the fact that the number of trainable parameters in layernorms (LN) and biases (B) in each LPHM layer make up a high proportion of parameters for our methods. For instance for $n=4$, for \compacter with 0.073\% of trainable parameters, LN and B make up 28.49\% and 23.51\% respectively of its trainable parameters; for \compacteronlyff with 0.047\% of trainable parameters, LN and B make up 44.01\% and 18.15\% respectively of its parameters; while for \phmadapter with 0.239\% of trainable parameters, LN and B make up only 8.63\% and 7.12\% respectively of its parameters. Consequently, simply removing biases from adapters, and exploring ideas of training language models without layer normalizations~\citep{brock2021high} can be promising directions on reducing parameters further, which we leave to future work.

\compacter has more than an order of magnitude fewer parameters compared to \adapter, with a parameter reduction at a remarkable rate of 11.4$\times$. \compacteronlyff even reduces the parameters further by 17.7$\times$ in total.

\begin{table}[tp]
\centering 
\caption{Performance of all methods on the tasks in GLUE for different values of hyper-parameters. For each method, we report the total number of parameters across all tasks and the number of parameters that are trained for each task as a multiple and proportion of \basebase model \citep{raffel2019exploring}. For MNLI, we report accuracy on the matched validation set. For MRPC and QQP, we report accuracy and F1. For STS-B, we report Pearson and Spearman correlation coefficients. For CoLA, we report Matthews correlation. For all other tasks, we report accuracy. Bold fonts indicate the best results in each block.}
\begin{adjustbox}{max width=\textwidth}
\begin{tabular}{l@{\hskip 0.02in}|l@{\hskip 0.05in}l@{\hskip 0.01in}|l@{\hskip 0.08in}l@{\hskip 0.08in}l@{\hskip 0.08in}l@{\hskip 0.08in}l@{\hskip 0.08in}l@{\hskip 0.08in}l@{\hskip 0.08in}l|l}
\toprule % / \textbf{task}
\textbf{Method} & \pbox{3cm}{\textbf{\#Total}\\ \textbf{params}} & \pbox{3cm}{\textbf{Trained} \\ \textbf{params /}\\ \textbf{per task\vspace{0.1em}}} & \textbf{CoLA} &    \textbf{SST-2} &   \textbf{MRPC} &   \textbf{QQP} &     \textbf{STS-B} & \textbf{MNLI}  &    \textbf{QNLI} & \textbf{RTE} &   \textbf{Avg} \\
\toprule 
\intrinsic ($d^{\prime}=0.4$K) &1.001 & 0.0002\%&  0.0 &  92.55 &  78.43/85.62 &  90.25/87.19 &  90.43/90.66 &  69.93 &  89.31 &  58.99 &  75.76 \\
\intrinsic ($d^{\prime}=1.4$K) &1.001 &  0.0006\% &52.40 &  93.35 &  \textbf{89.22/92.41} &  90.44/87.31 &  89.86/90.23 &  82.01 &  93.12 &  67.63 &  84.36 \\
\intrinsic ($d^{\prime}=2.5$K) &1.001 & 0.0011\%& 45.78 &  93.92 &   89.22/92.20 &  \textbf{90.43/87.37} &   90.32/90.90 &  82.86 &  93.17 &  64.03 &  83.65 \\
\intrinsic ($d^{\prime}=10$K) &1.001 & 0.0045\%& 56.13 &  93.58 &  88.73/91.99 &  90.34/87.18 &  \textbf{90.63/90.99} &  84.84 &  93.36 &  \textbf{71.22} &  85.36 \\
\intrinsic ($d^{\prime}=20$K) &1.001& 0.0090\%& \textbf{58.69} &  \textbf{94.15} &  88.24/91.78 &  90.28/87.13 &  90.06/90.45 &  \textbf{85.23} &  \textbf{93.39} &  70.50 &  \textbf{85.45} \\ 
\midrule 
\phmadapter ($n=4$)  & 1.018 &0.239\% & 59.21 &  93.69 &  87.25/90.91 &  90.23/86.99 &  90.55/90.73 &  85.93 &  \textbf{93.04} &  69.78 &  85.30  \\ % total_params=1.0175
\phmadapter ($n=8$)  &1.011 &0.160\% & \textbf{61.84} &  93.58 &  91.18/93.57 &  \textbf{90.25/87.08} &  \textbf{90.74/91.07} &  85.74 &  92.93 &  70.50 &  86.23 \\%total_params=1.0111
\phmadapter ($n=12$) &1.013 & 0.179\% & 57.35 &  \textbf{94.50} &  \textbf{91.67/93.86} &  90.25/87.05 &  90.45/90.84 &  \textbf{85.97} &  92.92 &  \textbf{75.54} &  \textbf{86.40}  \\ %total_params=1.0126
\midrule 
% task reduction factor = {8, 16, 32} lr=0.003
\compacter ($n=4$) &1.004& 0.073\%& \textbf{63.75} &  93.00 &  89.22/92.31 &  \textbf{90.23/87.03} &  90.31/90.74 &  85.61 &  92.88 &  \textbf{77.70} &  \textbf{86.62} \\ % total_params=1.0041
\compacter ($n=8$) & 1.004&0.073\%&61.78 &  \textbf{93.81} &    90.20/93.10 &  \textbf{90.23/87.03} &  90.16/90.44 &  \textbf{85.78} &  93.08 &  74.10 &  86.34 \\ % total_params=1.0041
\compacter ($n=12$) &1.004&0.073\%& 61.38 &  93.69 &  \textbf{91.18/93.71} &  90.11/86.88 &  \textbf{90.53/90.98} &  85.76 &  \textbf{93.12} &  70.50 &  86.17 \\% total_params=1.0042
\midrule 
%\compacter-4-no-warmup &1.0005& 0.07\% &  61.23 &  93.69 &  88.24/91.89 &  90.13/86.86 &   91.07/91.2 &  85.84 &  92.35 &  74.82 &  86.12 \\
%\compacter-8-no-warmup &1.0005& 0.07\% &   63.77 &  93.46 &  88.73/92.26 &  90.19/87.04 &  90.27/90.66 &  85.98 &  92.93 &  74.82 &  86.37 \\
%\compacter-12-no-warmup &1.0005& 0.07\% &  58.34 &  93.69 &  92.16/94.33 &  90.24/87.04 &   90.4/90.71 &  85.58 &  92.90 &  74.82 &  86.38 \\
%\midrule
\compacteronlyff ($n=4$) & 1.002&  0.047\%&  61.27 &  93.81 &  90.69/93.33 &  90.17/86.93 &  \textbf{90.46/90.93} &  \textbf{85.71} &  \textbf{93.08} &  \textbf{74.82} &  \textbf{86.47} \\%total_params=1.0020
\compacteronlyff ($n=8$)  & 1.002&  0.047\%&  62.79 &  92.55 &  88.24/91.95 &  90.16/86.94 &  90.43/90.78 &  85.36 &  92.82 &  73.38 &  85.95 \\%total_params=1.0021
\compacteronlyff ($n=12$)  &1.002&0.048\%&  \textbf{63.01} &  \textbf{93.92} &  \textbf{91.18/93.75} &  \textbf{90.23/87.01} &   90.40/90.65 &  85.46 &  92.88 &  71.22 &  86.34 \\%total_params=1.0021
\bottomrule
\end{tabular}


\end{adjustbox}
\label{tab:ablations}
\end{table} 



\section{Results with Fine-tuning the Output Layer}\label{app:with_lm_head}
Table~\ref{tab:glue_results_with_lm_head} shows the results for the methods in Table~\ref{tab:glue_results} with fine-tuning the output layer. The parameters of the output layer dominate the parameters of each method and thus reduce the relative parameter savings. The standard adapter obtains the largest improvement in performance when fine-tuning the output layer compared to the results in Table \ref{tab:glue_results}. In contrast, our proposed methods perform well with or without fine-tuning the output layer.


\begin{table}[H]
\centering 
\caption{Performance of all methods on the tasks in GLUE, where the output layer is tuned. For each method, we report the total number of parameters across all tasks and the percentage of parameters that are trained for each task as a multiple and proportion of \basebase model \citep{raffel2019exploring}.
%as a multiple and proportion respectively of the corresponding single-task BERT model.
% Bold denotes the best result in each column; underline denotes the best result per within a section. 
For MNLI, we report accuracy on the matched validation set. For MRPC and QQP, we report accuracy and F1. For STS-B, we report Pearson and Spearman correlation coefficients. For CoLA, we report Matthews correlation. For all other tasks, we report accuracy. Bold fonts indicate the best results in each block.}
\begin{adjustbox}{max width=\textwidth}
\begin{tabular}{l@{\hskip 0.02in}|l@{\hskip 0.06in}l@{\hskip 0.0in}|l@{\hskip 0.08in}l@{\hskip 0.08in}l@{\hskip 0.08in}l@{\hskip 0.08in}l@{\hskip 0.08in}l@{\hskip 0.08in}l@{\hskip 0.08in}l|l}
\toprule % / \textbf{task}
\textbf{Method} & \pbox{3cm}{\textbf{\#Total}\\ \textbf{params}} & \pbox{3cm}{\textbf{Trained} \\ \textbf{params /}\\ \textbf{per task\vspace{0.1em}}} & \textbf{CoLA} &    \textbf{SST-2} &   \textbf{MRPC} &   \textbf{QQP} &     \textbf{STS-B} & \textbf{MNLI}  &    \textbf{QNLI} & \textbf{RTE} &   \textbf{Avg} \\
\toprule 
\rowcolor{gray!20}\multicolumn{12}{c}{\it \textbf{Baselines}}\\
\midrule 
% total = 224689536 base=222882048
\adapter& 1.065 & 11.89\% & 61.80 &  \textbf{94.15} &  88.24/91.67 &  \textbf{90.27/87.05} &  \textbf{91.51/91.71} &  86.02 &  92.64 &  \textbf{76.26} &  \textbf{86.48} \\ % params=1.0649 this is with classifier
\pfeifferadapter &1.032 & 11.49\% & \textbf{64.76} &  93.58 &  87.75/91.58 &  90.16/87.17 &   91.21/91.50 &  86.16 &  \textbf{93.30} &  73.38 &  86.41 \\ %params=1.0324 lr=0.0003 
\adapterdrop &1.038&11.56\%&61.67 &  93.69 &  84.80/89.20 &  90.14/87.17 &  90.92/91.34 &  \textbf{86.24} &  93.23 &  73.38 &  85.62 \\ % params=1.0378 lr=3e-4 
%Hyperformer &&& \\
%\midrule
\adapterlowrank & 1.004 & 11.13\% & 62.82 &  93.81 &  88.73/91.99 &  90.34/87.19 &  90.51/90.58 &  85.81 &  92.93 &  74.82 &  86.32  \\ 
\bitfit & 1.010 &11.19\%&57.13 &  \textbf{94.15} &  \textbf{89.71/92.78} &  90.07/87.02 &  90.91/91.22 &  85.34 &  93.06 &  68.35 &  85.43 \\%params=1.0101
% init from the pretrained vocabulary.
%\prompttuning$^*$ &&&52.95&94.04& 84.80/89.12&84.72/80.93 &    &\\ 
\midrule 
\rowcolor{gray!20}\multicolumn{12}{c}{\it \textbf{Our Proposed Methods}}\\
\midrule 
% lr=0.003
%\phmadapter-4 ~\ding{171} &1.0021 &0.24\% & 59.21 &  93.69 &  87.25/90.91 &  90.23/86.99 &  90.55/90.73 &  85.93 &  93.04 &  69.78 &  85.30  \\
\phmadapter ($n=4$)& 1.017 & 11.30\% & 62.79 &  93.58 &  \textbf{89.22/92.41} &  90.23/87.01 &  90.61/90.81 &  \textbf{86.06} &  92.95 &  \textbf{75.54} &  \textbf{86.47} \\%params=1.0174
\phmadapter ($n=8$)& 1.011 & 11.22\% & 61.24 &  \textbf{94.38} &  88.73/91.99 &  90.28/87.08 &  90.53/90.98 &  85.94 &  \textbf{93.03} &  73.38 &  86.14 \\%params=1.0111
\phmadapter ($n=12$)& 1.013 & 11.24\%& \textbf{65.25} &  93.69 &  88.73/92.04 &  \textbf{90.34/87.16} &  \textbf{90.75/90.89} &  85.74 &  92.92 &  72.66 &  86.38 \\%params=1.0126
%\phmadapter-12 ~\ding{171} &1.0016 & 0.18\% & 57.35 &  94.50 &  91.67/93.86 &  90.25/87.05 &  90.45/90.84 &  85.97 &  92.92 &  75.54 &  86.40  \\
\midrule 
% task reduction factor = {8, 16, 32} lr=0.003
\compacter ($n=4$) & 1.004 & 11.13\% & \textbf{61.27} &  93.58 &  88.24/91.67 &  90.25/87.08 &  \textbf{90.67/91.02} &  \textbf{85.82} &  92.92 &  73.38 &  85.99\\%params=1.0041
\compacter ($n=8$) & 1.004 & 11.13\% &  60.31 &  \textbf{93.81} &  89.71/92.63 &  90.23/87.02 &  90.49/90.85 &  85.19 &  \textbf{93.08} &  71.94 &  85.93 \\%params=1.0041
\compacter ($n=12$) & 1.004 & 11.13\% & 59.25 &  93.12 &  \textbf{91.18/93.75} &  \textbf{90.31/87.16} &  90.37/90.82 &  85.33 &  92.97 &  \textbf{75.54} &  \textbf{86.35} \\ %params=1.0042
%\compacter-8 & 1.0005&0.07\%&61.78 &  93.81 &    90.2/93.1 &  90.23/87.03 &  90.16/90.44 &  85.78 &  93.08 &  74.1 &  86.34 \\ 
%\compacter-12 &1.0005&0.07\%& 61.38 &  93.69 &  91.18/93.71 &  90.11/86.88 &  90.53/90.98 &  85.76 &  93.12 &  70.5 &  86.17 \\ 
\midrule 
%\compacter-4-no-warmup &1.0005& 0.07\% &  61.23 &  93.69 &  88.24/91.89 &  90.13/86.86 &   91.07/91.2 &  85.84 &  92.35 &  74.82 &  86.12 \\
%\compacter-8-no-warmup &1.0005& 0.07\% &   63.77 &  93.46 &  88.73/92.26 &  90.19/87.04 &  90.27/90.66 &  85.98 &  92.93 &  74.82 &  86.37 \\
%\compacter-12-no-warmup &1.0005& 0.07\% &  58.34 &  93.69 &  92.16/94.33 &  90.24/87.04 &   90.4/90.71 &  85.58 &  92.90 &  74.82 &  86.38 \\
%\midrule
\compacteronlyff ($n=4$)& 1.002&11.11\% & \textbf{64.28} &  \textbf{94.27} &   90.20/92.96 &  \textbf{90.23/87.04} &  \textbf{90.27/90.61} &  \textbf{85.80} &  \textbf{92.97} &  73.38 &  \textbf{86.55}  \\%params=1.0020  
\compacteronlyff ($n=8$)& 1.002 &11.11\% & 63.78 &  93.58 &   \textbf{90.20/93.01} &  90.19/87.02 &  90.12/90.56 &  85.57 &  92.84 &  70.50 &  86.12\\%params=1.0021 
\compacteronlyff ($n=12$)& 1.002 & 11.11\% &  62.05 &  93.23 &  87.75/91.58 &  90.19/86.97 &  90.08/90.48 &  85.52 &  92.75 &  \textbf{79.86} &  86.41 \\ %params=1.0021
%\compacter-8-only-FFD  &1.0003&0.05\%&  62.79 &  92.55 &  88.24/91.95 &  90.16/86.94 &  90.43/90.78 &  85.36 &  92.82 &  73.38 &  85.95 \\
%\compacter-12-only-FFD  &1.0003&0.05\%&  63.01 &  93.92 &  91.18/93.75 &  90.23/87.01 &   90.4/90.65 &  85.46 &  92.88 &  71.22 &  86.34 \\
\bottomrule
\end{tabular}
\end{adjustbox}
 %All values are scaled by 100.
\label{tab:glue_results_with_lm_head} 
%\vspace{-1.4em}
\end{table} 



     
\section{Results on \superglue} \label{app:superglue}
Table~\ref{tab:superglue_all_results} shows the performance of our proposed methods on \superglue for different values of $n$. We include the learning rate obtaining the best validation performance for all methods reported in Table~\ref{tab:superglue_results} in Table~\ref{tab:lrs_superglue}.


\begin{table}[H] % change to [tp]
\centering 
\caption{Performance of our proposed methods on the tasks in \superglue for different values of $n$. For each method, we report the total number of parameters across all tasks and the percentage of parameters that are trained for each task as a multiple and proportion of \basebase model \citep{raffel2019exploring}. For CB, we report accuracy and F1. For MultiRC, we report  F1 over all answer-options (F1$_a$) and exact match of each question's set of answers (EM) \cite{wang2019superglue}. For ReCoRD, we report F1 and EM scores. For all other tasks, we report accuracy. Bold fonts indicate the best results in each block.}
\begin{adjustbox}{max width=\textwidth}
\begin{tabular}{l@{\hskip 0.02in}|l@{\hskip 0.06in}l@{\hskip 0.0in}|l@{\hskip 0.08in}l@{\hskip 0.08in}l@{\hskip 0.08in}l@{\hskip 0.08in}l@{\hskip 0.08in}l@{\hskip 0.08in}|l}
\toprule % / \textbf{task}
\textbf{Method} & \pbox{3cm}{\textbf{\#Total}\\ \textbf{params}} & \pbox{3cm}{\textbf{Trained} \\ \textbf{params /}\\ \textbf{per task\vspace{0.1em}}} & \textbf{BoolQ} &    \textbf{CB} &   \textbf{COPA} &   \textbf{MultiRC} &     \textbf{ReCoRD} & \textbf{WiC}  & \textbf{Avg} \\
\toprule 
%\rowcolor{gray!20}\multicolumn{10}{c}{\it \textbf{Our Proposed Methods}}\\
%\midrule 
\phmadapter ($n=4$)& 1.013 &0.24\% & \textbf{80.31} &  \textbf{85.71/73.52} &            44.0 &       \textbf{71.99/51.65} &       \textbf{74.62/73.60} &          67.40 &  \textbf{69.20}\\
\phmadapter ($n=8$) &1.008 &0.160\% &79.39 &  82.14/69.87 &            44.0 &       71.49/50.77 &      74.46/73.48 &          67.71 &  68.15  \\
\phmadapter ($n=12$)&1.009 & 0.179\% &79.33 &  78.57/75.43 &            \textbf{52.0} &       70.48/50.66 &      74.14/73.14 &          \textbf{68.65} &  69.16\\
\midrule 
\compacter ($n=4$) &1.003& 0.073\%& \textbf{79.88} &  89.29/82.51 &            42.0 &       \textbf{71.87/51.98} &   \textbf{74.64/73.59}       & 65.83 & 70.18 \\
\compacter ($n=8$) &1.003& 0.073\%&  79.57 &  85.71/80.06 &            \textbf{56.0} &       70.75/49.67 &    74.56/73.57     &  \textbf{70.85} & 71.19 \\
\compacter ($n=12$)&1.003& 0.073\%&  78.59 &  \textbf{96.43/87.44} &            48.0 &        70.80/49.67 &   74.49/73.54       & 65.20 & \textbf{71.57}\\
\midrule 
\compacteronlyff ($n=4$)& 1.002&  0.047\%&       \textbf{79.94} &  85.71/80.06 &            50.0 &       72.16/50.33 &       74.63/73.60 &          \textbf{68.34} &  70.53 \\
\compacteronlyff ($n=8$)& 1.002&  0.047\%&           78.23 &  82.14/70.87 &            48.0 &       \textbf{71.61/51.43} &      \textbf{74.62/73.64} &          67.71 &  68.69 \\
\compacteronlyff ($n=12$)& 1.002&  0.048\%&            78.84 &  \textbf{92.86/84.96} &            \textbf{52.0} &       70.68/50.99 &       74.55/73.50 &          68.03 &  \textbf{71.82} \\
\bottomrule
\end{tabular}
\end{adjustbox}
\label{tab:superglue_all_results} 
\end{table} 


\section{Impact of Model Size} \label{app:model size}
Table~\ref{tab:glue_results_small_model} shows the results of methods using \basesmall (60M parameters) on \glue. For all adapter-based methods, we experiment with adapters of bottleneck size of $\{16, 32, 64\}$. For our methods, we experiment with $n=\{4, 8, 16\}$.

All parameter-efficient fine-tuning methods are performing worse than full fine-tuning with this small model size. This is in contrast to the results of Table~\ref{tab:glue_results} and ~\ref{tab:superglue_results}, where some parameter-efficient fine-tuning methods were able to perform on par or outperform full fine-tuning with the larger model size of \basebase (222M parameters). Among all methods, adapters, and our proposed methods perform the best. We report the learning rate performing the best on the validation set of each method in Table~\ref{tab:lrs_t5_small}.
\begin{table}[H] % change to [tp]
\centering 
\caption{Performance of all methods on the tasks in GLUE. For each method, we report the total number of parameters across all tasks and the percentage of parameters that are trained for each task as a multiple and proportion of \basesmall model~\citep{raffel2019exploring}. For MNLI, we report accuracy on the matched validation set. For MRPC and QQP, we report accuracy and F1. For STS-B, we report Pearson and Spearman correlation coefficients. For CoLA, we report Matthews correlation. For all other tasks, we report accuracy. Bold fonts indicate the best results in each block. We repeat the experiments marked with $*$ multiple times for different seeds, but they were not successful.}
\begin{adjustbox}{max width=\textwidth}
\begin{tabular}{l@{\hskip 0.02in}|l@{\hskip 0.06in}l@{\hskip 0.0in}|l@{\hskip 0.08in}l@{\hskip 0.08in}l@{\hskip 0.08in}l@{\hskip 0.08in}l@{\hskip 0.08in}l@{\hskip 0.08in}l@{\hskip 0.08in}l|l}
\toprule % / \textbf{task}
\textbf{Method} & \pbox{3cm}{\textbf{\#Total}\\ \textbf{params}} & \pbox{3cm}{\textbf{Trained} \\ \textbf{params /}\\ \textbf{per task\vspace{0.1em}}} & \textbf{CoLA} &    \textbf{SST-2} &   \textbf{MRPC} &   \textbf{QQP} &     \textbf{STS-B} & \textbf{MNLI}  &    \textbf{QNLI} & \textbf{RTE} &   \textbf{Avg} \\
\toprule 
\rowcolor{gray!20}\multicolumn{12}{c}{\it \textbf{Baselines}}\\
\midrule 
\basesmall & 8$\times$1 &100\% & \textbf{46.90} &  \textbf{91.74} &  87.25/90.97 &  \textbf{90.07/86.68} &  88.75/89.20 &  \textbf{82.20} &  \textbf{90.59} &  \textbf{65.47} &  \textbf{82.71} \\ % lr = 3e-4, warmup = 0
\adapter &1.054 &0.698\%& 36.88 &  90.83 &  \textbf{88.73/91.93} &  88.09/84.06 &  88.98/89.34 &  80.50 &  89.75 &  62.59 &  81.06\\ 
\adapterdrop &1.009&0.139\% & 34.73 &  89.91 &  83.33/88.36 &  87.96/83.89 &  88.73/88.80 &  79.33 &  89.86 &  61.87 &  79.71 \\ 
\pfeifferadapter &1.027&0.363\% & 38.86 &  90.48 &  85.78/89.90 &  87.82/84.26 &  \textbf{89.24/89.56} &  80.63 &  89.84 &  57.55 &  80.36\\
\adapterlowrank &1.005&0.090\%&40.55 &  90.60 &  84.80/89.20 &  88.01/83.98 &  88.04/88.27 &  79.92 &  89.95 &  61.15 &  80.41 \\ 
\prompttuningrandom &1.007& 0.085\%&0.0$^*$ &  86.35 &  68.14/81.05 &  87.48/83.91 &  87.35/87.87 &  76.27 &  88.49 &  50.36 &  72.48 \\ 
\prompttuningtokens  &1.007& 0.085\%&  0.0$^*$ &  79.59 &  71.08/82.18 &  87.76/83.55 &  87.48/87.76 &  74.65 &  89.02 &  57.55 &  72.78  \\ 
\bitfit &1.015& 0.190\%& 25.59 &  90.48 &  84.80/89.42 &  88.01/83.77 &  87.58/87.89 &  78.15 &  88.94 &  63.31 &  78.90 \\
\intrinsic &1.003& 0.033\%&   0.0$^*$ &  90.25 &  84.80/89.05 &  88.07/84.00 &  87.81/88.08 &  79.02 &  89.90 &  52.52 &  75.77 \\ 
\midrule 
\rowcolor{gray!20}\multicolumn{12}{c}{\it \textbf{Our Proposed Methods}}\\
\midrule 
\phmadapter ($n=4$) &1.015 & 0.216\% &  40.08 &  90.60 &  \textbf{86.27/90.21} &  \textbf{88.26/84.25} &  \textbf{89.56/89.88} &  \textbf{80.73} &  \textbf{90.10} &  60.43 &  80.94 \\
\phmadapter ($n=8$) & 1.011& 0.170\% &  37.85 &  90.48 &  82.84/87.72 &  88.08/84.07 &  89.07/89.46 &  80.68 &  89.64 &  61.87 &  80.16 \\
\phmadapter ($n=16$) &1.031 & 0.414\% &  36.27 &  \textbf{90.83} &  83.82/88.34 &  88.03/84.02 &  87.94/88.44 &  80.04 &  89.95 &  58.99 &  79.70 \\
\midrule 
\compacter ($n=4$) & 1.005 & 0.090\% &  \textbf{44.65} &  89.45 &    84.80/89.20 &   88.00/83.96 &  88.19/88.47 &  79.54 &  89.66 &  64.03 &  80.90 \\
\compacter ($n=8$) & 1.005 & 0.091\% &  42.90 &  89.56 &  84.31/89.12 &  88.01/83.95 &  88.51/88.79 &  79.60 &  89.68 &  \textbf{66.19} &  \textbf{80.97} \\
\compacter ($n=16$) & 1.006&0.097\%  &  40.12 &  89.22 &  85.29/89.86 &  88.08/84.06 &   89.28/89.60 &  79.87 &  89.71 &  59.71 &  80.44 \\
\midrule 
\compacteronlyff ($n=4$) & 1.003 &0.059\%& 39.89 &  90.37 &  84.31/89.26 &  88.04/83.99 &  88.69/88.98 &  79.45 &  89.05 &  63.31 &  80.49 \\
\compacteronlyff ($n=8$) & 1.003 &0.059\%&34.98 &  90.37 &   83.82/88.50 &  88.02/83.99 &   88.87/89.30 &  79.39 &  89.57 &  64.03 &  80.08 \\
\compacteronlyff ($n=16$) & 1.003&0.065\%& 37.54 &  89.79 &   85.78/89.90 &  88.01/83.96 &   88.93/89.30 &  79.35 &  89.40 &  64.75 &  80.61 \\

\bottomrule
\end{tabular}
\label{tab:glue_results_small_model}
\end{adjustbox}
\end{table}








\begin{table}[H]
    \begin{minipage}{.5\linewidth}
     \centering
       \caption{Selected learning rates for all methods with \basesmall}
       \begin{tabular}{ll}
    \toprule
    \textbf{Method} & \textbf{Learning rate}   \\
    \midrule  
    \basesmall &  $3\mathrm{e}{-4}$\\
    \adapter & $3\mathrm{e}{-3}$\\ 
    \pfeifferadapter & $3\mathrm{e}{-4}$\\ 
    \adapterdrop & $3\mathrm{e}{-3}$\\ 
    \adapterlowrank & $3\mathrm{e}{-3}$ \\ 
    \prompttuningrandom & $3\mathrm{e}{-2}$\\ 
    \prompttuningtokens & $3\mathrm{e}{-1}$\\
    \intrinsic &  $3\mathrm{e}{-2}$ \\
    \bitfit & $3\mathrm{e}{-3}$\\ 
    \phmadapter &   $3\mathrm{e}{-3}$\\ 
    \compacter &  $3\mathrm{e}{-3}$ \\  
    \compacteronlyff & $3\mathrm{e}{-3}$ \\ 
    \bottomrule
    \end{tabular}
     \label{tab:lrs_t5_small}
    
    \end{minipage}\quad
    \begin{minipage}{.5\linewidth}
    %\vspace{-3.2em}
          \centering
       \caption{Selected learning rates for all methods with \basebase on \superglue.}
       \begin{tabular}{ll}
    \toprule
    \textbf{Method} & \textbf{Learning rate}   \\
    \midrule  
    \basebase &  $3\mathrm{e}{-4}$\\ 
    \adapter & $3\mathrm{e}{-4}$ \\
    \pfeifferadapter & $3\mathrm{e}{-4}$ \\ 
    \adapterdrop & $3\mathrm{e}{-4}$ \\ 
    \adapterlowrank & $3\mathrm{e}{-3}$ \\ 
    \prompttuningrandom &$3\mathrm{e}{-2}$ \\ 
    \prompttuningtokens & $3\mathrm{e}{-1}$\\
    \bitfit & $3\mathrm{e}{-4}$\\ 
    \intrinsic &  $3\mathrm{e}{-3}$\\
    \phmadapter & $3\mathrm{e}{-3}$  \\ 
    \compacter &  $3\mathrm{e}{-3}$ \\ 
    \compacteronlyff &  $3\mathrm{e}{-3}$ \\ 
    \bottomrule
    \end{tabular}
     \label{tab:lrs_superglue}
    
    \end{minipage} 
\end{table}



\end{document}
