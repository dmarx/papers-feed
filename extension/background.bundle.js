(()=>{"use strict";var e=class{constructor(e,t,o={}){this.token=e,this.repo=t,this.config={baseLabel:o.baseLabel??"stored-object",uidPrefix:o.uidPrefix??"UID:",reactions:{processed:o.reactions?.processed??"+1",initialState:o.reactions?.initialState??"rocket"}}}async fetchFromGitHub(e,t={}){let o=new URL(`https://api.github.com/repos/${this.repo}${e}`);t.params&&(Object.entries(t.params).forEach((([e,t])=>{o.searchParams.append(e,t)})),delete t.params);let i=await fetch(o.toString(),{...t,headers:{Authorization:`token ${this.token}`,Accept:"application/vnd.github.v3+json",...t.headers}});if(!i.ok)throw new Error(`GitHub API error: ${i.status}`);return i.json()}async getObject(e){let t=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(","),state:"closed"}});if(!t||0===t.length)throw new Error(`No object found with ID: ${e}`);let o=t[0],i=JSON.parse(o.body);return{meta:{objectId:e,label:`${this.config.uidPrefix}${e}`,createdAt:new Date(o.created_at),updatedAt:new Date(o.updated_at),version:await this._getVersion(o.number)},data:i}}async listAll(){let e=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:this.config.baseLabel,state:"closed"}}),t={};for(let o of e)if(!o.labels.some((e=>"archived"===e.name)))try{let e=this._getObjectIdFromLabels(o),i=JSON.parse(o.body),a={objectId:e,label:e,createdAt:new Date(o.created_at),updatedAt:new Date(o.updated_at),version:await this._getVersion(o.number)};t[e]={meta:a,data:i}}catch{continue}return t}async listUpdatedSince(e){let t=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:this.config.baseLabel,state:"closed",since:e.toISOString()}}),o={};for(let i of t)if(!i.labels.some((e=>"archived"===e.name)))try{let t=this._getObjectIdFromLabels(i),a=JSON.parse(i.body),n=new Date(i.updated_at);if(n>e){let e={objectId:t,label:t,createdAt:new Date(i.created_at),updatedAt:n,version:await this._getVersion(i.number)};o[t]={meta:e,data:a}}}catch{continue}return o}async getObjectHistory(e){let t=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(","),state:"all"}});if(!t||0===t.length)throw new Error(`No object found with ID: ${e}`);let o=t[0],i=await this.fetchFromGitHub(`/issues/${o.number}/comments`),a=[];for(let e of i)try{let t=JSON.parse(e.body);a.push({timestamp:e.created_at,type:t.type||"update",data:t.data||t,commentId:e.id})}catch{continue}return a}async _getVersion(e){return(await this.fetchFromGitHub(`/issues/${e}/comments`)).length+1}_getObjectIdFromLabels(e){for(let t of e.labels)if(t.name!==this.config.baseLabel&&t.name.startsWith(this.config.uidPrefix))return t.name.slice(this.config.uidPrefix.length);throw new Error(`No UID label found with prefix ${this.config.uidPrefix}`)}};Error;const t={idleThresholdMinutes:5,minSessionDurationSeconds:30,requireContinuousActivity:!0,logPartialSessions:!1,activityUpdateIntervalSeconds:1};function o(e){return{idleThreshold:60*e.idleThresholdMinutes*1e3,minSessionDuration:1e3*e.minSessionDurationSeconds,activityUpdateInterval:1e3*e.activityUpdateIntervalSeconds,requireContinuousActivity:e.requireContinuousActivity,logPartialSessions:e.logPartialSessions}}let i="",a="",n=null,r=null,s=null,c=null,l=null,u=null;chrome.storage.onChanged.addListener((async t=>{console.log("Storage changes detected:",Object.keys(t)),t.githubToken&&(i=t.githubToken.newValue),t.githubRepo&&(a=t.githubRepo.newValue),t.sessionConfig&&(u=o(t.sessionConfig.newValue),console.log("Session configuration updated:",u)),(t.githubToken||t.githubRepo)&&(n=i&&a?new e(i,a):null)}));class d{constructor(e,t){this.arxivId=e,this.startTime=Date.now(),this.activeTime=0,this.lastActiveTime=Date.now(),this.isTracking=!0,this.config=t}update(){if(this.isTracking){const e=Date.now(),t=e-this.lastActiveTime;t<this.config.idleThreshold?this.activeTime+=t:this.config.requireContinuousActivity&&(this.activeTime=0),this.lastActiveTime=e}}end(){return this.isTracking=!1,this.update(),this.config.logPartialSessions||this.activeTime>=this.config.minSessionDuration?this.activeTime:0}}async function g(e){const t=e.url?.includes("arxiv.org/");if(console.log("Tab change detected:",{isArxiv:t,url:e.url}),!t)return console.log("Not an arXiv page, ending current session"),void await h();s&&(console.log("Ending existing session before starting new one"),await h()),console.log("Processing arXiv URL for new session"),r=await p(e.url),r&&(console.log("Starting new session for:",r.arxivId),s=new d(r.arxivId,u),c||(console.log("Starting activity tracking"),c=setInterval((()=>{s&&s.update()}),u.activityUpdateInterval)))}async function h(){if(s&&r){console.log("Ending session for:",r.arxivId);const e=s.end();e>0&&(console.log("Creating reading event with duration:",e),await async function(e,t){if(!n||!e)return void console.error("Missing required data for creating reading event:",{hasClient:!!n,hasPaperData:!!e});const o=Math.round(t/1e3);if(t<u.minSessionDuration)return void console.log("Session too short to log:",o,"seconds");console.log("Creating reading event:",{arxivId:e.arxivId,duration:o,title:e.title});const i={type:"reading_session",arxivId:e.arxivId,timestamp:(new Date).toISOString(),duration_seconds:o,title:e.title,authors:e.authors,abstract:e.abstract,url:e.url,session_config:{idle_threshold_seconds:u.idleThreshold/1e3,min_duration_seconds:u.minSessionDuration/1e3,continuous_activity_required:u.requireContinuousActivity,partial_sessions_logged:u.logPartialSessions}};try{const t=`reading-${e.arxivId}-${Date.now()}`;return console.log("Creating stored object with ID:",t),await n.getObject(t).catch((()=>null))?await n.update(t,i):await n.create(t,i),console.log("Reading event created successfully"),t}catch(e){throw console.error("Error creating reading event:",e),e}}(r,e)),s=null,r=null,c&&(clearInterval(c),c=null),l&&(clearTimeout(l),l=null)}}async function p(e){console.log("Processing URL:",e);const t=[/arxiv\.org\/abs\/([0-9.]+)/,/arxiv\.org\/pdf\/([0-9.]+)\.pdf/,/arxiv\.org\/\w+\/([0-9.]+)/];let o=null;for(const i of t){const t=e.match(i);if(t){o=t[1];break}}if(!o)return console.log("No arXiv ID found in URL"),null;console.log("Found arXiv ID:",o);try{const t=`http://export.arxiv.org/api/query?id_list=${o}`;console.log("Fetching from arXiv API:",t);const i=await fetch(t);console.log("API response status:",i.status);const a=await i.text(),n=await async function(e){console.log("Parsing XML response...");try{const t=(e,t)=>{const o=t.match(/<entry>([\s\S]*?)<\/entry>/);if(o){const t=o[1],i=new RegExp(`<${e}[^>]*>(.*?)</${e}>`,"s"),a=t.match(i);return a?a[1].trim():""}return""},o=e=>{const t=[],o=/<author>[^]*?<name>([^]*?)<\/name>[^]*?<\/author>/g;let i;for(;i=o.exec(e);)t.push(i[1].trim());return t},i=e=>{const t=new Set,o=e.match(/<arxiv:primary_category[^>]*term="([^"]+)"/);o&&t.add(o[1]);const i=/<category[^>]*term="([^"]+)"/g;let a;for(;a=i.exec(e);)t.add(a[1]);return Array.from(t)},a=e=>{const t=e.match(/<published>([^<]+)<\/published>/);return t?t[1].trim():null},n={title:t("title",e),summary:t("summary",e),authors:o(e),published_date:a(e),arxiv_tags:i(e)};return console.log("Parsed XML:",n),n}catch(e){return console.error("Error parsing XML:",e),null}}(a);if(!n)return console.log("Failed to parse API response"),null;const r={arxivId:o,url:e,title:n.title,authors:n.authors.join(", "),abstract:n.summary,timestamp:(new Date).toISOString(),rating:"novote",published_date:n.published_date,arxiv_tags:n.arxiv_tags};return console.log("Paper data processed:",r),r}catch(e){return console.error("Error processing arXiv URL:",e),null}}!async function(){const r=await chrome.storage.sync.get(["githubToken","githubRepo"]);i=r.githubToken||"",a=r.githubRepo||"",console.log("Credentials loaded:",{hasToken:!!i,hasRepo:!!a}),i&&a&&(n=new e(i,a)),u=o(await async function(){const e=await chrome.storage.sync.get("sessionConfig");return{...t,...e.sessionConfig}}()),console.log("Session configuration loaded:",u)}(),chrome.webNavigation.onCompleted.addListener((async e=>{if(console.log("Navigation detected:",e.url),e.url.includes("arxiv.org")){console.log("arXiv URL detected, processing...");const t=await p(e.url);t?(console.log("Paper data extracted:",t),await async function(e){if(n)try{const t=`paper-${e.arxivId}`;return console.log("Creating GitHub issue for paper:",t),await n.getObject(t).catch((()=>null))?await n.update(t,{...e,labels:["paper",`rating:${e.rating}`]}):await n.create(t,{...e,labels:["paper",`rating:${e.rating}`]}),console.log("GitHub issue created/updated successfully"),r={...e,objectId:t},t}catch(e){throw console.error("Error creating/updating Github issue:",e),e}else console.error("GitHub client not initialized. Please configure extension options.")}(t)):console.log("Failed to extract paper data")}}),{url:[{hostSuffix:"arxiv.org"}]}),chrome.runtime.onMessage.addListener(((e,t,o)=>{if(console.log("Message received:",e),"getCurrentPaper"===e.type)console.log("Popup requested current paper:",r),o(r);else if("updateRating"===e.type){if(console.log("Rating update requested:",e.rating),r&&r.objectId)return async function(e,t){if(n)try{console.log(`Updating rating for paper ${e} to ${t}`),await n.update(e,{rating:t,labels:["paper",`rating:${t}`]}),console.log("Rating updated successfully")}catch(e){throw console.error("Error updating rating:",e),e}else console.error("GitHub client not initialized. Please configure extension options.")}(r.objectId,e.rating).then((()=>{r.rating=e.rating,o({success:!0})})).catch((e=>{console.error("Error updating rating:",e),o({success:!1,error:e.message})})),!0;o({success:!1,error:"No current paper or object ID"})}return!0})),chrome.tabs.onActivated.addListener((async e=>{g(await chrome.tabs.get(e.tabId))})),chrome.tabs.onUpdated.addListener(((e,t,o)=>{"complete"===t.status&&g(o)})),chrome.windows.onFocusChanged.addListener((e=>{e===chrome.windows.WINDOW_ID_NONE&&h()})),chrome.runtime.onMessage.addListener(((e,t,o)=>{if("updateAnnotation"===e.type)return async function(e,t){if(!n)throw new Error("GitHub credentials not set");const{paperId:o}=t;let i;switch(e){case"vote":i={type:"vote",paperId:o,vote:t.vote,timestamp:(new Date).toISOString(),labels:["annotation","vote",`rating:${t.vote}`]};break;case"notes":i={type:"notes",paperId:o,notes:t.notes,timestamp:(new Date).toISOString(),labels:["annotation","notes"]};break;default:throw new Error(`Unknown annotation type: ${e}`)}try{const t=`${e}-${o}-${Date.now()}`;return await n.create(t,i),t}catch(e){throw console.error("Error creating annotation:",e),e}}(e.annotationType,e.data).then((()=>o({success:!0}))).catch((e=>o({success:!1,error:e.message}))),!0}))})();