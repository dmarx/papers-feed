(()=>{"use strict";var e=class{constructor(e,t,o={}){this.token=e,this.repo=t,this.config={baseLabel:o.baseLabel??"stored-object",uidPrefix:o.uidPrefix??"UID:",reactions:{processed:o.reactions?.processed??"+1",initialState:o.reactions?.initialState??"rocket"}}}async fetchFromGitHub(e,t={}){let o=new URL(`https://api.github.com/repos/${this.repo}${e}`);t.params&&(Object.entries(t.params).forEach((([e,t])=>{o.searchParams.append(e,t)})),delete t.params);let i=await fetch(o.toString(),{...t,headers:{Authorization:`token ${this.token}`,Accept:"application/vnd.github.v3+json",...t.headers}});if(!i.ok)throw new Error(`GitHub API error: ${i.status}`);return i.json()}async getObject(e){let t=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(","),state:"closed"}});if(!t||0===t.length)throw new Error(`No object found with ID: ${e}`);let o=t[0],i=JSON.parse(o.body);return{meta:{objectId:e,label:`${this.config.uidPrefix}${e}`,createdAt:new Date(o.created_at),updatedAt:new Date(o.updated_at),version:await this._getVersion(o.number)},data:i}}async listAll(){let e=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:this.config.baseLabel,state:"closed"}}),t={};for(let o of e)if(!o.labels.some((e=>"archived"===e.name)))try{let e=this._getObjectIdFromLabels(o),i=JSON.parse(o.body),n={objectId:e,label:e,createdAt:new Date(o.created_at),updatedAt:new Date(o.updated_at),version:await this._getVersion(o.number)};t[e]={meta:n,data:i}}catch{continue}return t}async listUpdatedSince(e){let t=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:this.config.baseLabel,state:"closed",since:e.toISOString()}}),o={};for(let i of t)if(!i.labels.some((e=>"archived"===e.name)))try{let t=this._getObjectIdFromLabels(i),n=JSON.parse(i.body),s=new Date(i.updated_at);if(s>e){let e={objectId:t,label:t,createdAt:new Date(i.created_at),updatedAt:s,version:await this._getVersion(i.number)};o[t]={meta:e,data:n}}}catch{continue}return o}async getObjectHistory(e){let t=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(","),state:"all"}});if(!t||0===t.length)throw new Error(`No object found with ID: ${e}`);let o=t[0],i=await this.fetchFromGitHub(`/issues/${o.number}/comments`),n=[];for(let e of i)try{let t=JSON.parse(e.body);n.push({timestamp:e.created_at,type:t.type||"update",data:t.data||t,commentId:e.id})}catch{continue}return n}async _getVersion(e){return(await this.fetchFromGitHub(`/issues/${e}/comments`)).length+1}_getObjectIdFromLabels(e){for(let t of e.labels)if(t.name!==this.config.baseLabel&&t.name.startsWith(this.config.uidPrefix))return t.name.slice(this.config.uidPrefix.length);throw new Error(`No UID label found with prefix ${this.config.uidPrefix}`)}};Error;const t={idleThresholdMinutes:5,minSessionDurationSeconds:30,requireContinuousActivity:!0,logPartialSessions:!1,activityUpdateIntervalSeconds:1};function o(e){return{idleThreshold:60*e.idleThresholdMinutes*1e3,minSessionDuration:1e3*e.minSessionDurationSeconds,activityUpdateInterval:1e3*e.activityUpdateIntervalSeconds,requireContinuousActivity:e.requireContinuousActivity,logPartialSessions:e.logPartialSessions}}let i="",n="",s=null,r=null,a=null,c=null,l=null,u=null;chrome.storage.onChanged.addListener((async t=>{console.log("Storage changes detected:",Object.keys(t)),t.githubToken&&(i=t.githubToken.newValue),t.githubRepo&&(n=t.githubRepo.newValue),t.sessionConfig&&(u=o(t.sessionConfig.newValue),console.log("Session configuration updated:",u)),(t.githubToken||t.githubRepo)&&(s=i&&n?new e(i,n):null)}));class d{constructor(e,t){this.arxivId=e,this.startTime=Date.now(),this.activeTime=0,this.lastActiveTime=Date.now(),this.isTracking=!0,this.config=t}update(){if(this.isTracking){const e=Date.now(),t=e-this.lastActiveTime;t<this.config.idleThreshold?this.activeTime+=t:this.config.requireContinuousActivity&&(this.activeTime=0),this.lastActiveTime=e}}end(){return this.isTracking=!1,this.update(),this.config.logPartialSessions||this.activeTime>=this.config.minSessionDuration?this.activeTime:0}}async function g(e){const t=e.url?.includes("arxiv.org/");if(console.log("Tab change detected:",{isArxiv:t,url:e.url}),!t)return console.log("Not an arXiv page, ending current session"),void await h();a&&(console.log("Ending existing session before starting new one"),await h()),console.log("Processing arXiv URL for new session"),r=await p(e.url),r&&(console.log("Starting new session for:",r.arxivId),a=new d(r.arxivId,u),c||(console.log("Starting activity tracking"),c=setInterval((()=>{a&&a.update()}),u.activityUpdateInterval)))}async function h(){if(a&&r){console.log("Ending session for:",r.arxivId);const e=a.end();e>0&&(console.log("Creating reading event with duration:",e),await async function(e,t){if(!s||!e)return void console.error("Missing required data for creating reading event:",{hasClient:!!s,hasPaperData:!!e});const o=Math.round(t/1e3);if(t<u.minSessionDuration)return void console.log("Session too short to log:",o,"seconds");console.log("Creating reading event:",{arxivId:e.arxivId,duration:o,title:e.title});const i={type:"reading_session",arxivId:e.arxivId,timestamp:(new Date).toISOString(),duration_seconds:o,title:e.title,authors:e.authors,abstract:e.abstract,url:e.url,session_config:{idle_threshold_seconds:u.idleThreshold/1e3,min_duration_seconds:u.minSessionDuration/1e3,continuous_activity_required:u.requireContinuousActivity,partial_sessions_logged:u.logPartialSessions}};try{const t=await s.create(`reading-${e.arxivId}-${Date.now()}`,i);return console.log("Reading event created:",t),t}catch(e){console.error("Error creating reading event:",e)}}(r,e)),a=null,r=null,c&&(clearInterval(c),c=null),l&&(clearTimeout(l),l=null)}}async function p(e){console.log("Processing URL:",e);const t=[/arxiv\.org\/abs\/([0-9.]+)/,/arxiv\.org\/pdf\/([0-9.]+)\.pdf/,/arxiv\.org\/\w+\/([0-9.]+)/];let o=null;for(const i of t){const t=e.match(i);if(t){o=t[1];break}}if(!o)return console.log("No arXiv ID found in URL"),null;console.log("Found arXiv ID:",o);try{const t=`http://export.arxiv.org/api/query?id_list=${o}`;console.log("Fetching from arXiv API:",t);const i=await fetch(t);console.log("API response status:",i.status);const n=await i.text(),s=await async function(e){console.log("Parsing XML response...");try{const t=(e,t)=>{const o=t.match(/<entry>([\s\S]*?)<\/entry>/);if(o){const t=o[1],i=new RegExp(`<${e}[^>]*>(.*?)</${e}>`,"s"),n=t.match(i);return n?n[1].trim():""}return""},o=e=>{const t=[],o=/<author>[^]*?<name>([^]*?)<\/name>[^]*?<\/author>/g;let i;for(;i=o.exec(e);)t.push(i[1].trim());return t},i=e=>{const t=new Set,o=e.match(/<arxiv:primary_category[^>]*term="([^"]+)"/);o&&t.add(o[1]);const i=/<category[^>]*term="([^"]+)"/g;let n;for(;n=i.exec(e);)t.add(n[1]);return Array.from(t)},n=e=>{const t=e.match(/<published>([^<]+)<\/published>/);return t?t[1].trim():null},s={title:t("title",e),summary:t("summary",e),authors:o(e),published_date:n(e),arxiv_tags:i(e)};return console.log("Parsed XML:",s),s}catch(e){return console.error("Error parsing XML:",e),null}}(n);if(!s)return console.log("Failed to parse API response"),null;const r={arxivId:o,url:e,title:s.title,authors:s.authors.join(", "),abstract:s.summary,timestamp:(new Date).toISOString(),rating:"novote",published_date:s.published_date,arxiv_tags:s.arxiv_tags};return console.log("Paper data processed:",r),r}catch(e){return console.error("Error processing arXiv URL:",e),null}}!async function(){const r=await chrome.storage.sync.get(["githubToken","githubRepo"]);i=r.githubToken||"",n=r.githubRepo||"",console.log("Credentials loaded:",{hasToken:!!i,hasRepo:!!n}),i&&n&&(s=new e(i,n)),u=o(await async function(){const e=await chrome.storage.sync.get("sessionConfig");return{...t,...e.sessionConfig}}()),console.log("Session configuration loaded:",u)}(),chrome.webNavigation.onCompleted.addListener((async e=>{if(console.log("Navigation detected:",e.url),e.url.includes("arxiv.org")){console.log("arXiv URL detected, processing...");const t=await p(e.url);t?(console.log("Paper data extracted:",t),await async function(e){if(s)try{console.log("Creating GitHub issue for paper:",e.arxivId);const t=await s.create(`paper-${e.arxivId}`,{...e,labels:["paper",`rating:${e.rating}`]});return console.log("GitHub issue created successfully:",t),r={...e,issueNumber:t.meta.objectId},t}catch(e){console.error("Error creating Github issue:",e)}else console.error("GitHub client not initialized. Please configure extension options.")}(t)):console.log("Failed to extract paper data")}}),{url:[{hostSuffix:"arxiv.org"}]}),chrome.runtime.onMessage.addListener(((e,t,o)=>{if(console.log("Message received:",e),"getCurrentPaper"===e.type)console.log("Popup requested current paper:",r),o(r);else if("updateRating"===e.type){if(console.log("Rating update requested:",e.rating),r&&r.issueNumber)return async function(e,t){if(s)try{console.log(`Updating rating for paper ${e} to ${t}`),await s.update(e,{rating:t,labels:["paper",`rating:${t}`]}),console.log("Rating updated successfully")}catch(e){throw console.error("Error updating rating:",e),e}else console.error("GitHub client not initialized. Please configure extension options.")}(r.issueNumber,e.rating).then((()=>{r.rating=e.rating,o({success:!0})})).catch((e=>{console.error("Error updating rating:",e),o({success:!1,error:e.message})})),!0;o({success:!1,error:"No current paper or issue number"})}return!0})),chrome.tabs.onActivated.addListener((async e=>{g(await chrome.tabs.get(e.tabId))})),chrome.tabs.onUpdated.addListener(((e,t,o)=>{"complete"===t.status&&g(o)})),chrome.windows.onFocusChanged.addListener((e=>{e===chrome.windows.WINDOW_ID_NONE&&h()})),chrome.runtime.onMessage.addListener(((e,t,o)=>{if("updateAnnotation"===e.type)return async function(e,t){if(!i||!n)throw new Error("GitHub credentials not set");const{paperId:o}=t;let s,r,a;switch(e){case"vote":s=`[Vote] ${o}`,r=JSON.stringify({type:"vote",paperId:o,vote:t.vote,timestamp:(new Date).toISOString()},null,2),a=["annotation","vote",`rating:${t.vote}`];break;case"notes":s=`[Notes] ${o}`,r=JSON.stringify({type:"notes",paperId:o,notes:t.notes,timestamp:(new Date).toISOString()},null,2),a=["annotation","notes"];break;default:throw new Error(`Unknown annotation type: ${e}`)}try{const e=await fetch(`https://api.github.com/repos/${n}/issues`,{method:"POST",headers:{Authorization:`token ${i}`,Accept:"application/vnd.github.v3+json"},body:JSON.stringify({title:s,body:r,labels:a})});if(!e.ok)throw new Error(`GitHub API error: ${e.status}`);return await e.json()}catch(e){throw console.error("Error creating annotation:",e),e}}(e.annotationType,e.data).then((()=>o({success:!0}))).catch((e=>o({success:!1,error:e.message}))),!0}))})();