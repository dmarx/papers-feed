{"version":3,"file":"background.bundle.js","sources":["../papers/plugins/registry.ts","../papers/plugins/source_factory.ts","../utils/worker_safe_parser.ts","../papers/plugins/sources/arxiv_plugin.ts","../papers/plugins/loader.ts","../papers/detection_service.ts","../node_modules/gh-store-client/dist/index.mjs","../papers/source_utils.ts","../papers/manager.ts","../background/credential_manager.ts","../config/session.ts","../background/session_manager.ts","../papers/metadata_service.ts","../papers/paper_processor.ts","../background/github_integration.ts","../background/event_handlers.ts","../background/debug.ts","../background/index.ts"],"sourcesContent":["// extension/papers/plugins/registry.ts\n// Enhanced plugin registry with improved validation and logging\n\nimport { SourcePlugin } from './source_plugin';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('PluginRegistry');\nconst debugLogger = loguru.getLogger('PluginRegistryDebug');\n\n/**\n * Registry for paper source plugins\n * Manages plugin registration, discovery, and lookup\n */\nclass PluginRegistry {\n  private plugins: Map<string, SourcePlugin> = new Map();\n  \n  /**\n   * Register a plugin with the registry\n   * @param plugin Plugin to register\n   */\n  register(plugin: SourcePlugin): void {\n    debugLogger.info(`Registering plugin: ${plugin.id} (${plugin.name})`);\n    \n    // Validate plugin has required fields\n    if (!plugin.id || typeof plugin.id !== 'string') {\n      debugLogger.error(`Plugin missing valid id: ${JSON.stringify(plugin)}`);\n      return;\n    }\n    \n    if (!Array.isArray(plugin.urlPatterns) || plugin.urlPatterns.length === 0) {\n      debugLogger.warning(`Plugin ${plugin.id} has no URL patterns`);\n    }\n    \n    if (!plugin.extractId || typeof plugin.extractId !== 'function') {\n      debugLogger.error(`Plugin ${plugin.id} missing required extractId method`);\n      return;\n    }\n    \n    if (!plugin.getContentScriptExtractor || typeof plugin.getContentScriptExtractor !== 'function') {\n      debugLogger.error(`Plugin ${plugin.id} missing required getContentScriptExtractor method`);\n      return;\n    }\n    \n    if (!plugin.formatId || typeof plugin.formatId !== 'function') {\n      debugLogger.error(`Plugin ${plugin.id} missing required formatId method`);\n      return;\n    }\n    \n    if (!plugin.evaluateMetadataQuality || typeof plugin.evaluateMetadataQuality !== 'function') {\n      debugLogger.error(`Plugin ${plugin.id} missing required evaluateMetadataQuality method`);\n      return;\n    }\n    \n    if (this.plugins.has(plugin.id)) {\n      debugLogger.warning(`Plugin with ID ${plugin.id} already registered, overwriting`);\n      logger.warning(`Plugin with ID ${plugin.id} already registered, overwriting`);\n    }\n    \n    this.plugins.set(plugin.id, plugin);\n    debugLogger.info(`Successfully registered plugin: ${plugin.name} (${plugin.id})`);\n    debugLogger.info(`Plugin capabilities: hasApi=${!!plugin.hasApi}, formatId=${!!plugin.formatId}`);\n    logger.info(`Registered plugin: ${plugin.name} (${plugin.id})`);\n  }\n  \n  /**\n   * Get all registered plugins\n   * @returns Array of registered plugins\n   */\n  getAll(): SourcePlugin[] {\n    debugLogger.info(`Getting all plugins, currently ${this.plugins.size} registered`);\n    return Array.from(this.plugins.values());\n  }\n  \n  /**\n   * Get a plugin by ID\n   * @param id Plugin ID\n   * @returns Plugin instance or undefined if not found\n   */\n  get(id: string): SourcePlugin | undefined {\n    debugLogger.info(`Looking up plugin by id: ${id}`);\n    const plugin = this.plugins.get(id);\n    if (!plugin) {\n      debugLogger.warning(`No plugin found with id: ${id}`);\n    } else {\n      debugLogger.info(`Found plugin: ${plugin.name} (${plugin.id})`);\n    }\n    return plugin;\n  }\n  \n  /**\n   * Find a plugin that can handle a URL and extract its ID\n   * @param url URL to find a plugin for\n   * @returns Object with plugin and extracted ID, or null if no match\n   */\n  findForUrl(url: string): { plugin: SourcePlugin; id: string } | null {\n    debugLogger.info(`Finding plugin for URL: ${url}`);\n    \n    for (const plugin of this.plugins.values()) {\n      debugLogger.info(`Testing URL against plugin: ${plugin.id}`);\n      \n      for (const pattern of plugin.urlPatterns) {\n        debugLogger.info(`Testing pattern: ${pattern.toString()}`);\n        \n        if (pattern.test(url)) {\n          debugLogger.info(`URL matches pattern for plugin: ${plugin.id}`);\n          \n          const id = plugin.extractId(url);\n          if (id) {\n            debugLogger.info(`Successfully extracted ID: ${id}`);\n            return { plugin, id };\n          } else {\n            debugLogger.warning(`Pattern matched but failed to extract ID`);\n          }\n        }\n      }\n    }\n    \n    debugLogger.warning(`No plugin found for URL: ${url}`);\n    return null;\n  }\n  \n  /**\n   * Get the content script extractor code for a plugin\n   * @param id Plugin ID\n   * @returns Extractor code as string or null if plugin not found\n   */\n  getExtractorCode(id: string): string | null {\n    const plugin = this.get(id);\n    if (!plugin) {\n      return null;\n    }\n    \n    try {\n      return plugin.getContentScriptExtractor();\n    } catch (error) {\n      debugLogger.error(`Error getting extractor code for plugin ${id}: ${error}`);\n      return null;\n    }\n  }\n  \n  /**\n   * Check if a URL is supported by any registered plugin\n   * @param url URL to check\n   * @returns True if URL is supported\n   */\n  isSupportedUrl(url: string): boolean {\n    for (const plugin of this.plugins.values()) {\n      for (const pattern of plugin.urlPatterns) {\n        if (pattern.test(url)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  \n  /**\n   * Get information about all registered plugins\n   * @returns Array of plugin information objects\n   */\n  getPluginInfo(): Array<{\n    id: string;\n    name: string;\n    description: string;\n    version: string;\n    hasApi: boolean;\n  }> {\n    return this.getAll().map(plugin => ({\n      id: plugin.id,\n      name: plugin.name,\n      description: plugin.description,\n      version: plugin.version,\n      hasApi: !!plugin.hasApi\n    }));\n  }\n}\n\n// Export singleton instance\nexport const pluginRegistry = new PluginRegistry();\ndebugLogger.info('PluginRegistry singleton instance created');\n","// extension/papers/plugins/source_factory.ts\n// Factory to simplify creation of new source plugins\n\nimport { SourcePlugin, MetadataQualityResult } from './source_plugin';\nimport { pluginRegistry } from './registry';\nimport { UnifiedPaperData } from '../types';\nimport { loguru } from '../../utils/logger';\n\n/**\n * Base configuration for creating a source plugin\n */\nexport interface SourcePluginConfig {\n  id: string;\n  name: string;\n  description: string;\n  version: string;\n  urlPatterns: RegExp[];\n  color?: string;\n  icon?: string;\n  \n  // Core functionality\n  idExtractor: (url: string) => string | null;\n  formatId: (id: string) => string;\n  \n  // Content script extractor function as a string\n  contentScriptExtractorCode: string;\n  \n  // Service worker operations\n  apiDataFetcher?: (id: string) => Promise<Partial<UnifiedPaperData>>;\n  \n  // Optional custom quality evaluation\n  evaluateMetadataQuality?: (paperData: Partial<UnifiedPaperData>) => MetadataQualityResult;\n}\n\n/**\n * Factory for creating source plugins with consistent behavior\n */\nexport class SourcePluginFactory {\n  private logger = loguru.getLogger('SourcePluginFactory');\n\n  /**\n   * Create a new source plugin from configuration and register it\n   * \n   * @param config Plugin configuration\n   * @returns The created plugin\n   */\n  createPlugin(config: SourcePluginConfig): SourcePlugin {\n    this.logger.info(`Creating plugin: ${config.id}`);\n    \n    // Validate required fields\n    this.validateConfig(config);\n    \n    const plugin: SourcePlugin = {\n      id: config.id,\n      name: config.name,\n      description: config.description,\n      version: config.version,\n      urlPatterns: config.urlPatterns,\n      color: config.color,\n      icon: config.icon,\n      hasApi: !!config.apiDataFetcher,\n      \n      // ID extraction function\n      extractId: (url: string): string | null => {\n        try {\n          return config.idExtractor(url);\n        } catch (error) {\n          this.logger.error(`Error extracting ID for ${config.id}:`, error);\n          return null;\n        }\n      },\n      \n      // Content script extraction code provider\n      getContentScriptExtractor: (): string => {\n        return config.contentScriptExtractorCode;\n      },\n      \n      // Default metadata quality evaluation method\n      evaluateMetadataQuality: (paperData: Partial<UnifiedPaperData>): MetadataQualityResult => {\n        try {\n          // If custom evaluator is provided, use it\n          if (config.evaluateMetadataQuality) {\n            return config.evaluateMetadataQuality(paperData);\n          }\n          \n          // Define required fields for different quality levels\n          const essentialFields = ['title', 'primary_id', 'url'];\n          const standardFields = [...essentialFields, 'authors'];\n          const completeFields = [...standardFields, 'abstract', 'timestamp'];\n          \n          // Check which fields are missing\n          const missingEssential = essentialFields.filter(field => {\n            const value = paperData[field];\n            return value === undefined || value === null || value === '';\n          });\n          \n          const missingStandard = standardFields.filter(field => {\n            const value = paperData[field];\n            return value === undefined || value === null || value === '';\n          });\n          \n          const missingComplete = completeFields.filter(field => {\n            const value = paperData[field];\n            return value === undefined || value === null || value === '';\n          });\n          \n          // Calculate quality level\n          let quality: 'minimal' | 'partial' | 'complete';\n          \n          if (missingEssential.length > 0) {\n            quality = 'minimal';\n          } else if (missingComplete.length > 0) {\n            quality = 'partial';\n          } else {\n            quality = 'complete';\n          }\n          \n          return {\n            quality,\n            missingFields: missingComplete,\n            hasEssentialFields: missingEssential.length === 0\n          };\n        } catch (error) {\n          this.logger.error(`Error evaluating metadata quality: ${error}`);\n          return {\n            quality: 'minimal',\n            missingFields: ['error'],\n            hasEssentialFields: false\n          };\n        }\n      },\n      \n      // ID formatting function\n      formatId: config.formatId\n    };\n    \n    // Add API data fetcher if provided\n    if (config.apiDataFetcher) {\n      plugin.fetchApiData = async (id: string): Promise<Partial<UnifiedPaperData>> => {\n        try {\n          const data = await config.apiDataFetcher!(id);\n          this.logger.info(`Fetched API data for ${config.id}:${id}`);\n          return data;\n        } catch (error) {\n          this.logger.error(`Error fetching API data for ${config.id}:${id}:`, error);\n          return {};\n        }\n      };\n    }\n    \n    // Register the plugin\n    pluginRegistry.register(plugin);\n    \n    return plugin;\n  }\n  \n  /**\n   * Validate plugin configuration\n   * @param config Configuration to validate\n   * @throws Error if required fields are missing\n   */\n  private validateConfig(config: SourcePluginConfig): void {\n    // Required fields must exist\n    const requiredFields = [\n      'id', 'name', 'description', 'version', 'urlPatterns',\n      'idExtractor', 'formatId', 'contentScriptExtractorCode'\n    ];\n    \n    const missingFields = requiredFields.filter(field => \n      !config[field as keyof SourcePluginConfig]);\n    \n    if (missingFields.length > 0) {\n      const error = `Plugin configuration missing required fields: ${missingFields.join(', ')}`;\n      this.logger.error(error);\n      throw new Error(error);\n    }\n    \n    // URL patterns must be an array with at least one pattern\n    if (!Array.isArray(config.urlPatterns) || config.urlPatterns.length === 0) {\n      const error = `Plugin ${config.id} has no URL patterns`;\n      this.logger.error(error);\n      throw new Error(error);\n    }\n    \n    // Validate function fields\n    if (typeof config.idExtractor !== 'function') {\n      const error = `Plugin ${config.id} has invalid idExtractor: not a function`;\n      this.logger.error(error);\n      throw new Error(error);\n    }\n    \n    if (typeof config.formatId !== 'function') {\n      const error = `Plugin ${config.id} has invalid formatId: not a function`;\n      this.logger.error(error);\n      throw new Error(error);\n    }\n    \n    // Content script extractor code must be a non-empty string\n    if (typeof config.contentScriptExtractorCode !== 'string' || \n        config.contentScriptExtractorCode.trim() === '') {\n      const error = `Plugin ${config.id} has invalid contentScriptExtractorCode: empty or not a string`;\n      this.logger.error(error);\n      throw new Error(error);\n    }\n    \n    // If apiDataFetcher is provided, it must be a function\n    if (config.apiDataFetcher !== undefined && typeof config.apiDataFetcher !== 'function') {\n      const error = `Plugin ${config.id} has invalid apiDataFetcher: not a function`;\n      this.logger.error(error);\n      throw new Error(error);\n    }\n    \n    // If evaluateMetadataQuality is provided, it must be a function\n    if (config.evaluateMetadataQuality !== undefined && \n        typeof config.evaluateMetadataQuality !== 'function') {\n      const error = `Plugin ${config.id} has invalid evaluateMetadataQuality: not a function`;\n      this.logger.error(error);\n      throw new Error(error);\n    }\n  }\n}\n\n// Export a singleton instance\nexport const sourcePluginFactory = new SourcePluginFactory();\n","// extension/utils/worker_safe_parser.ts\n\n/**\n * Simple XML parser that works in service worker environment\n */\nexport function parseXML(xmlText: string) {\n  return {\n    getTagContent(tag: string, content?: string): string {\n      const searchText = content || xmlText;\n      const regex = new RegExp(`<${tag}[^>]*>(.*?)</${tag}>`, 's');\n      const match = searchText.match(regex);\n      return match ? match[1].trim() : '';\n    },\n    \n    getAll(tag: string): string[] {\n      const result: string[] = [];\n      const regex = new RegExp(`<${tag}[^>]*>(.*?)</${tag}>`, 'gs');\n      let match;\n      while ((match = regex.exec(xmlText)) !== null) {\n        result.push(match[1].trim());\n      }\n      return result;\n    },\n    \n    getAttribute(tag: string, attr: string): string[] {\n      const result: string[] = [];\n      const regex = new RegExp(`<${tag}[^>]*${attr}=\"([^\"]+)\"`, 'g');\n      let match;\n      while ((match = regex.exec(xmlText)) !== null) {\n        result.push(match[1]);\n      }\n      return result;\n    },\n    \n    getEntry(text?: string): string {\n      const searchText = text || xmlText;\n      const entryRegex = /<entry>([\\s\\S]*?)<\\/entry>/;\n      const entryMatch = searchText.match(entryRegex);\n      return entryMatch ? entryMatch[1] : '';\n    },\n    \n    getAuthor(text?: string): string[] {\n      const searchText = text || xmlText;\n      const authors = [];\n      const regex = /<author>[^]*?<name>([^]*?)<\\/name>[^]*?<\\/author>/g;\n      let match;\n      while (match = regex.exec(searchText)) {\n        authors.push(match[1].trim());\n      }\n      return authors;\n    },\n    \n    getCategories(text?: string): string[] {\n      const searchText = text || xmlText;\n      const categories = new Set();\n      \n      const primaryMatch = searchText.match(/<arxiv:primary_category[^>]*term=\"([^\"]+)\"/);\n      if (primaryMatch) {\n        categories.add(primaryMatch[1]);\n      }\n      \n      const categoryRegex = /<category[^>]*term=\"([^\"]+)\"/g;\n      let match;\n      while (match = categoryRegex.exec(searchText)) {\n        categories.add(match[1]);\n      }\n      \n      return Array.from(categories) as string[];\n    },\n    \n    getPublishedDate(text?: string): string {\n      const searchText = text || xmlText;\n      const match = searchText.match(/<published>([^<]+)<\\/published>/);\n      return match ? match[1].trim() : '';\n    }\n  };\n}\n","// extension/papers/plugins/sources/arxiv_plugin.ts\n// ArXiv plugin implementation using source factory\n\nimport { sourcePluginFactory } from '../source_factory';\nimport { UnifiedPaperData } from '../../types';\nimport { loguru } from '../../../utils/logger';\nimport { parseXML } from '../../../utils/worker_safe_parser';\n\nconst logger = loguru.getLogger('ArXivPlugin');\n\n// Content script extractor function as a string\n// This will be executed in the content script context\nconst extractorCode = `\n  // Extract arXiv ID from URL\n  const idMatch = url.match(/arxiv\\\\.org\\\\/(?:abs|pdf)\\\\/([0-9.]+)(v[0-9]+)?/);\n  const arxivId = idMatch ? (idMatch[1] + (idMatch[2] || '')) : '';\n  \n  if (!arxivId) {\n    return null;\n  }\n  \n  // Create standardized ID\n  const primary_id = \\`arxiv.\\${arxivId}\\`;\n  \n  // Extract title\n  let title = '';\n  const titleElement = document.querySelector('.title');\n  if (titleElement) {\n    title = titleElement.textContent?.replace('Title:', '').trim() || '';\n  }\n  \n  // Extract authors\n  let authors = '';\n  const authorElements = document.querySelectorAll('.authors a');\n  if (authorElements.length > 0) {\n    authors = Array.from(authorElements)\n      .map(el => el.textContent?.trim())\n      .filter(Boolean)\n      .join(', ');\n  }\n  \n  // Extract abstract\n  let abstract = '';\n  const abstractElement = document.querySelector('.abstract');\n  if (abstractElement) {\n    abstract = abstractElement.textContent?.replace('Abstract:', '').trim() || '';\n  }\n  \n  // Extract categories\n  const categories = [];\n  const categoryElements = document.querySelectorAll('.subjects .tag');\n  categoryElements.forEach(el => {\n    const text = el.textContent?.trim();\n    if (text) categories.push(text);\n  });\n  \n  // Return structured metadata\n  return {\n    primary_id,\n    source: 'arxiv',\n    sourceId: arxivId,\n    url,\n    title,\n    authors,\n    abstract,\n    source_specific_metadata: {\n      arxiv_tags: categories\n    },\n    timestamp: new Date().toISOString()\n  };\n`;\n\n// Create the arXiv plugin using the factory\nexport const arxivPlugin = sourcePluginFactory.createPlugin({\n  id: 'arxiv',\n  name: 'arXiv',\n  description: 'Support for arXiv papers',\n  version: '1.0.0',\n  color: '#B31B1B',\n  icon: '📝',\n  \n  // URL patterns for detecting arXiv papers\n  urlPatterns: [\n    /arxiv\\.org\\/abs\\/([0-9.]+)(v[0-9]+)?/,\n    /arxiv\\.org\\/pdf\\/([0-9.]+)(v[0-9]+)?\\.pdf/,\n    /arxiv\\.org\\/[a-z]+\\/([0-9.]+)(v[0-9]+)?/\n  ],\n  \n  // Extract ID from URL\n  idExtractor: (url: string): string | null => {\n    for (const pattern of [\n      /arxiv\\.org\\/abs\\/([0-9.]+)(v[0-9]+)?/,\n      /arxiv\\.org\\/pdf\\/([0-9.]+)(v[0-9]+)?\\.pdf/,\n      /arxiv\\.org\\/[a-z]+\\/([0-9.]+)(v[0-9]+)?/\n    ]) {\n      const match = url.match(pattern);\n      if (match) {\n        return match[1] + (match[2] || '');\n      }\n    }\n    return null;\n  },\n  \n  // Content script extraction code\n  contentScriptExtractorCode: extractorCode,\n  \n  // API-based metadata fetching (service worker)\n  apiDataFetcher: async (id: string): Promise<Partial<UnifiedPaperData>> => {\n    logger.info(`Fetching arXiv API data for ID: ${id}`);\n    \n    try {\n      const apiUrl = `https://export.arxiv.org/api/query?id_list=${id}`;\n      \n      // Use fetch for service worker compatibility\n      const response = await fetch(apiUrl);\n      \n      if (!response.ok) {\n        throw new Error(`API error: ${response.status}`);\n      }\n      \n      const text = await response.text();\n      \n      // Use our service-worker safe XML parser\n      const parser = parseXML(text);\n      \n      // Extract entry data\n      const entryContent = parser.getEntry();\n      \n      // Extract title\n      const title = parser.getTagContent('title');\n      \n      // Extract authors\n      const authorsList = parser.getAuthor();\n      const authors = authorsList.join(', ');\n      \n      // Extract summary\n      const abstract = parser.getTagContent('summary');\n      \n      // Extract categories\n      const categories = parser.getCategories();\n      \n      // Extract published date\n      const published = parser.getPublishedDate();\n      \n      // Format primary ID\n      const primary_id = `arxiv.${id}`;\n      \n      // Return structured metadata\n      return {\n        primary_id,\n        source: 'arxiv',\n        sourceId: id,\n        url: `https://arxiv.org/abs/${id}`,\n        title,\n        authors,\n        abstract,\n        timestamp: new Date().toISOString(),\n        source_specific_metadata: {\n          arxiv_tags: categories,\n          published_date: published\n        }\n      };\n    } catch (error) {\n      logger.error(`Error fetching arXiv API data: ${error}`);\n      return {};\n    }\n  },\n  \n  // Custom ID formatting\n  formatId: (id: string): string => `arxiv.${id}`,\n  \n  // Custom metadata quality evaluation\n  evaluateMetadataQuality: (paperData: Partial<UnifiedPaperData>) => {\n    // Define required fields for different quality levels\n    const essentialFields = ['title', 'primary_id', 'url'];\n    const standardFields = [...essentialFields, 'authors'];\n    const completeFields = [...standardFields, 'abstract', 'source_specific_metadata'];\n    \n    // Check which fields are missing\n    const missingEssential = essentialFields.filter(field => \n      !paperData[field] || paperData[field] === '');\n    \n    const missingStandard = standardFields.filter(field => \n      !paperData[field] || paperData[field] === '');\n    \n    const missingComplete = completeFields.filter(field => {\n      if (field === 'source_specific_metadata') {\n        return !paperData.source_specific_metadata || \n              !paperData.source_specific_metadata.arxiv_tags || \n              !Array.isArray(paperData.source_specific_metadata.arxiv_tags) || \n              paperData.source_specific_metadata.arxiv_tags.length === 0;\n      }\n      return !paperData[field] || paperData[field] === '';\n    });\n    \n    // Calculate quality level\n    let quality: 'minimal' | 'partial' | 'complete';\n    \n    if (missingEssential.length > 0) {\n      quality = 'minimal';\n    } else if (missingComplete.length > 0) {\n      quality = 'partial';\n    } else {\n      quality = 'complete';\n    }\n    \n    return {\n      quality,\n      missingFields: missingComplete,\n      hasEssentialFields: missingEssential.length === 0\n    };\n  }\n});\n\n// Export the plugin for direct import\nexport default arxivPlugin;\n","// extension/papers/plugins/loader.ts\n// Improved plugin loader with better initialization handling\n\nimport { loguru } from '../../utils/logger';\nimport { pluginRegistry } from './registry';\n\n// Import plugins directly (static imports only)\n// This is the key change - we need to use static imports only in service workers\nimport { arxivPlugin } from './sources/arxiv_plugin';\n//import { semanticScholarPlugin } from './sources/semantic_scholar_plugin';\n//import { openreviewPlugin } from './sources/openreview_plugin';\n\nconst logger = loguru.getLogger('PluginLoader');\n\n// Track plugin initialization state\nlet pluginsInitialized = false;\nlet initializationPromise: Promise<void> | null = null;\n\n/**\n * Register core plugins manually instead of dynamic imports\n * Service workers don't support dynamic imports\n */\nfunction registerCorePlugins(): void {\n  try {\n    // Clear existing plugins to avoid duplicates in case of retries\n    const existingPlugins = pluginRegistry.getAll();\n    if (existingPlugins.length > 0) {\n      logger.info(`Found ${existingPlugins.length} plugins already registered`);\n      return; // Already registered\n    }\n    \n    // Register each plugin manually - static imports\n    pluginRegistry.register(arxivPlugin);\n    //pluginRegistry.register(semanticScholarPlugin);\n    //pluginRegistry.register(openreviewPlugin);\n    \n    const pluginCount = pluginRegistry.getAll().length;\n    logger.info(`Registered ${pluginCount} core plugins manually`);\n  } catch (error) {\n    logger.error('Error registering core plugins:', error);\n    throw error;\n  }\n}\n\n/**\n * Load all built-in source plugins with improved error handling\n */\nasync function loadBuiltinPlugins(): Promise<void> {\n  logger.info('Loading built-in plugins');\n  \n  try {\n    // Register the core plugins directly - no dynamic imports\n    registerCorePlugins();\n    \n    // Check if plugins were registered successfully\n    const pluginCount = pluginRegistry.getAll().length;\n    \n    if (pluginCount === 0) {\n      logger.warning('No plugins were registered. Attempting emergency direct registration.');\n      \n      // Emergency fallback - try direct plugin registration again\n      try {\n        // These are the same plugins, but we try again in case of registration issues\n        pluginRegistry.register(arxivPlugin);\n        //pluginRegistry.register(semanticScholarPlugin);\n        //pluginRegistry.register(openreviewPlugin);\n        \n        // Check if emergency registration worked\n        const emergencyCount = pluginRegistry.getAll().length;\n        if (emergencyCount > 0) {\n          logger.info(`Emergency plugin registration successful: ${emergencyCount} plugins registered`);\n        } else {\n          throw new Error('Failed to register any plugins even with emergency registration');\n        }\n      } catch (emergencyError) {\n        logger.error('Emergency plugin registration failed:', emergencyError);\n        throw emergencyError;\n      }\n    } else {\n      logger.info(`${pluginCount} plugins are registered`);\n    }\n  } catch (error) {\n    logger.error('Error loading plugins', error);\n    // Log detailed error information for debugging\n    if (error instanceof Error) {\n      logger.error(`Plugin loading error: ${error.message}`);\n      if (error.stack) {\n        logger.error(`Stack trace: ${error.stack}`);\n      }\n    }\n    // Rethrow to indicate initialization failure\n    throw error;\n  }\n}\n\n/**\n * Initialize the plugin system with retry capability\n * @param {number} retries Number of retries if initialization fails\n * @returns {Promise<void>}\n */\nexport async function initializePluginSystem(retries = 3): Promise<void> {\n  // If already initialized, return immediately\n  if (pluginsInitialized) {\n    return;\n  }\n  \n  // If initialization is in progress, return the existing promise\n  if (initializationPromise) {\n    return initializationPromise;\n  }\n  \n  // Start initialization\n  logger.info('Initializing plugin system');\n  \n  // Create a new initialization promise\n  initializationPromise = (async () => {\n    let attemptCount = 0;\n    let lastError: Error | null = null;\n    \n    // Try initialization with retries\n    while (attemptCount < retries) {\n      try {\n        await loadBuiltinPlugins();\n        \n        // Log loaded plugins\n        const loadedPlugins = pluginRegistry.getAll();\n        logger.info(`Initialized ${loadedPlugins.length} plugins:`);\n        \n        loadedPlugins.forEach(plugin => {\n          logger.info(`- ${plugin.name} (${plugin.id}) v${plugin.version}`);\n        });\n        \n        // Mark as successful\n        pluginsInitialized = true;\n        return;\n      } catch (error) {\n        attemptCount++;\n        lastError = error instanceof Error ? error : new Error(String(error));\n        logger.warning(`Plugin initialization attempt ${attemptCount} failed: ${lastError.message}`);\n        \n        if (attemptCount < retries) {\n          // Wait before retrying\n          const delay = Math.pow(2, attemptCount) * 500; // Exponential backoff\n          logger.info(`Retrying plugin initialization in ${delay}ms...`);\n          await new Promise(resolve => setTimeout(resolve, delay));\n        }\n      }\n    }\n    \n    // If we get here, all retries failed\n    logger.error(`Plugin initialization failed after ${retries} attempts.`);\n    if (lastError) {\n      throw lastError;\n    } else {\n      throw new Error('Plugin initialization failed for unknown reasons');\n    }\n  })();\n  \n  try {\n    await initializationPromise;\n    return;\n  } catch (error) {\n    // Reset the promise so future calls can try again\n    initializationPromise = null;\n    throw error;\n  }\n}\n\n/**\n * Check if plugins are initialized\n * @returns {boolean} True if plugins are initialized\n */\nexport function arePluginsInitialized(): boolean {\n  return pluginsInitialized;\n}\n\n/**\n * Get current plugin initialization state\n * @returns {Object} Initialization state\n */\nexport function getPluginInitializationState() {\n  return {\n    initialized: pluginsInitialized,\n    initializationInProgress: !!initializationPromise,\n    pluginCount: pluginRegistry.getAll().length\n  };\n}\n\n/**\n * Manually reset plugin initialization state\n * Used primarily for testing and emergency recovery\n */\nexport function resetPluginInitialization(): void {\n  pluginsInitialized = false;\n  initializationPromise = null;\n  logger.warning('Plugin initialization state has been reset');\n}\n","// extension/papers/detection_service.ts\n// Enhanced paper detection service using the plugin system\n\nimport { loguru } from \"../utils/logger\";\nimport { SourceInfo } from './types';\nimport { pluginRegistry } from './plugins/registry';\nimport { arePluginsInitialized, initializePluginSystem } from './plugins/loader';\n\nconst logger = loguru.getLogger('DetectionService');\n\n// Define interfaces for detection service\nexport interface DetectedSourceInfo extends SourceInfo {\n  plugin?: any; // Plugin instance\n}\n\n// Define NavDetails interface for Chrome API types\ninterface NavDetails {\n    tabId: number;\n    url: string;\n    frameId: number;\n    timeStamp: number;\n}\n\n/**\n * Enhanced URL detection service\n */\nexport class URLDetectionService {\n  // Track processing state\n  private pendingUrls = new Set<string>();\n  private detectionCache = new Map<string, DetectedSourceInfo>();\n  \n  constructor() {\n    logger.info('URL Detection Service initialized');\n  }\n  \n  /**\n   * Check if URL is valid\n   * @param {string} url URL to check\n   * @returns {boolean} Whether URL is valid\n   */\n  isValidUrl(url: string): boolean {\n    if (!url) return false;\n    \n    try {\n      new URL(url);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * Detect paper source info from URL\n   * @param {string} url URL to analyze\n   * @returns {Promise<DetectedSourceInfo|null>} Detection result with plugin\n   */\n  async detectSource(url: string): Promise<DetectedSourceInfo | null> {\n    if (!url) {\n      logger.warning('Empty URL provided to detectSource');\n      return null;\n    }\n    \n    // Check cache first\n    if (this.detectionCache.has(url)) {\n      logger.info(`Cache hit for ${url}`);\n      return this.detectionCache.get(url) as DetectedSourceInfo;\n    }\n    \n    // Ensure plugins are initialized\n    if (!arePluginsInitialized()) {\n      logger.info('Plugins not initialized, initializing now...');\n      try {\n        await initializePluginSystem();\n      } catch (error) {\n        logger.error('Failed to initialize plugins:', error);\n        return null;\n      }\n    }\n    \n    // Check if URL is already being processed\n    if (this.isUrlPending(url)) {\n      logger.info(`URL already being processed: ${url}`);\n      return null;\n    }\n    \n    try {\n      // Mark URL as pending\n      this.addPendingUrl(url);\n      \n      // Use the plugin registry to find a matching plugin\n      const result = pluginRegistry.findForUrl(url);\n      \n      if (result) {\n        // Create a standardized result\n        const sourceInfo: DetectedSourceInfo = {\n          type: result.plugin.id,\n          id: result.id,\n          primary_id: result.plugin.formatId(result.id),\n          url: url,\n          plugin: result.plugin\n        };\n        \n        // Cache the result\n        this.detectionCache.set(url, sourceInfo);\n        \n        logger.info(`Detected source: ${sourceInfo.type}:${sourceInfo.id}`);\n        return sourceInfo;\n      }\n      \n      logger.info(`No matching source found for URL: ${url}`);\n      return null;\n    } finally {\n      // Remove from pending after a delay to prevent immediate reprocessing\n      setTimeout(() => {\n        this.pendingUrls.delete(url);\n      }, 500);\n    }\n  }\n  \n  /**\n   * Check if URL is pending processing\n   * @param url URL to check\n   * @returns True if URL is pending\n   */\n  isUrlPending(url: string): boolean {\n    return this.pendingUrls.has(url);\n  }\n  \n  /**\n   * Add URL to pending set\n   * @param url URL to add\n   */\n  addPendingUrl(url: string): void {\n    this.pendingUrls.add(url);\n  }\n  \n  /**\n   * Clear detection cache\n   */\n  clearCache(): void {\n    this.detectionCache.clear();\n    logger.info('Detection cache cleared');\n  }\n  \n  /**\n   * Get a plugin's extractor code for a URL\n   * @param url URL to get extractor for\n   * @returns Extractor code as string or null\n   */\n  async getExtractorForUrl(url: string): Promise<string | null> {\n    const sourceInfo = await this.detectSource(url);\n    if (!sourceInfo || !sourceInfo.plugin) {\n      return null;\n    }\n    \n    try {\n      return sourceInfo.plugin.getContentScriptExtractor();\n    } catch (error) {\n      logger.error(`Error getting extractor for ${url}:`, error);\n      return null;\n    }\n  }\n  \n  /**\n   * Get extractor code for a specific plugin\n   * @param pluginId Plugin ID\n   * @returns Extractor code or null\n   */\n  getExtractorForPlugin(pluginId: string): string | null {\n    return pluginRegistry.getExtractorCode(pluginId);\n  }\n}\n\n// Create singleton instance\nexport const urlDetectionService = new URLDetectionService();\n\n/**\n * Process a URL using the detection service\n * @param {string} url URL to process\n * @returns {Promise<DetectedSourceInfo|null>} Detection result\n */\nexport async function processUrl(url: string): Promise<DetectedSourceInfo | null> {\n  if (!urlDetectionService.isValidUrl(url)) {\n    logger.info(`Invalid or unsupported URL: ${url}`);\n    return null;\n  }\n  \n  try {\n    return await urlDetectionService.detectSource(url);\n  } catch (error) {\n    logger.error(`Error processing URL ${url}:`, error);\n    return null;\n  }\n}\n\n/**\n * Process a tab using the detection service\n * @param {chrome.tabs.Tab} tab Tab to process\n * @returns {Promise<DetectedSourceInfo|null>} Detection result\n */\nexport async function processTab(tab: chrome.tabs.Tab): Promise<DetectedSourceInfo | null> {\n  if (!tab.url) {\n    logger.info('Tab has no URL');\n    return null;\n  }\n  \n  return processUrl(tab.url);\n}\n\n/**\n * Process navigation event using the detection service\n * @param {NavDetails} details Navigation details\n * @returns {Promise<DetectedSourceInfo|null>} Detection result\n */\nexport async function processNavigation(details: NavDetails): Promise<DetectedSourceInfo | null> {\n  if (!details.url) {\n    logger.info('Navigation event has no URL');\n    return null;\n  }\n  \n  return processUrl(details.url);\n}\n","var d=class{constructor(e={}){this.cache=new Map,this.maxSize=e.maxSize??1e3,this.ttl=e.ttl??1e3*60*60,this.accessOrder=[]}get(e){let s=this.cache.get(e);if(s){if(Date.now()-s.lastAccessed>this.ttl){this.cache.delete(e),this.removeFromAccessOrder(e);return}return s.lastAccessed=Date.now(),this.updateAccessOrder(e),s.issueNumber}}set(e,s,t){if(this.cache.size>=this.maxSize&&!this.cache.has(e)){let r=this.accessOrder[this.accessOrder.length-1];r&&(this.cache.delete(r),this.removeFromAccessOrder(r))}this.cache.set(e,{issueNumber:s,lastAccessed:Date.now(),createdAt:t.createdAt,updatedAt:t.updatedAt}),this.updateAccessOrder(e)}remove(e){this.cache.delete(e),this.removeFromAccessOrder(e)}clear(){this.cache.clear(),this.accessOrder=[]}getStats(){return{size:this.cache.size,maxSize:this.maxSize,ttl:this.ttl}}shouldRefresh(e,s){let t=this.cache.get(e);return t?s>t.updatedAt:!0}updateAccessOrder(e){this.removeFromAccessOrder(e),this.accessOrder.unshift(e)}removeFromAccessOrder(e){let s=this.accessOrder.indexOf(e);s>-1&&this.accessOrder.splice(s,1)}};var l=\"0.3.2\";var f=class{constructor(e,s,t={}){this.token=e,this.repo=s,this.config={baseLabel:t.baseLabel??\"stored-object\",uidPrefix:t.uidPrefix??\"UID:\",reactions:{processed:t.reactions?.processed??\"+1\",initialState:t.reactions?.initialState??\"rocket\"}},this.cache=new d(t.cache)}async fetchFromGitHub(e,s={}){let t=new URL(`https://api.github.com/repos/${this.repo}${e}`);s.params&&(Object.entries(s.params).forEach(([i,a])=>{t.searchParams.append(i,a)}),delete s.params);let r=await fetch(t.toString(),{...s,headers:{Authorization:`token ${this.token}`,Accept:\"application/vnd.github.v3+json\",...s.headers}});if(!r.ok)throw new Error(`GitHub API error: ${r.status}`);return r.json()}createCommentPayload(e,s){let t={_data:e,_meta:{client_version:l,timestamp:new Date().toISOString(),update_mode:\"append\"}};return s&&(t.type=s),t}async getObject(e){let s=this.cache.get(e),t;if(s)try{t=await this.fetchFromGitHub(`/issues/${s}`),this._verifyIssueLabels(t,e)||(this.cache.remove(e),t=void 0)}catch{this.cache.remove(e)}if(!t){let c=await this.fetchFromGitHub(\"/issues\",{method:\"GET\",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(\",\"),state:\"closed\"}});if(!c||c.length===0)throw new Error(`No object found with ID: ${e}`);t=c[0]}if(!t?.body)throw new Error(`Invalid issue data received for ID: ${e}`);let r=JSON.parse(t.body),i=new Date(t.created_at),a=new Date(t.updated_at);return this.cache.set(e,t.number,{createdAt:i,updatedAt:a}),{meta:{objectId:e,label:`${this.config.uidPrefix}${e}`,createdAt:i,updatedAt:a,version:await this._getVersion(t.number)},data:r}}async createObject(e,s){let t=`${this.config.uidPrefix}${e}`,r=await this.fetchFromGitHub(\"/issues\",{method:\"POST\",body:JSON.stringify({title:`Stored Object: ${e}`,body:JSON.stringify(s,null,2),labels:[this.config.baseLabel,t]})});this.cache.set(e,r.number,{createdAt:new Date(r.created_at),updatedAt:new Date(r.updated_at)});let i=this.createCommentPayload(s,\"initial_state\"),a=await this.fetchFromGitHub(`/issues/${r.number}/comments`,{method:\"POST\",body:JSON.stringify({body:JSON.stringify(i,null,2)})});return await this.fetchFromGitHub(`/issues/comments/${a.id}/reactions`,{method:\"POST\",body:JSON.stringify({content:this.config.reactions.processed})}),await this.fetchFromGitHub(`/issues/comments/${a.id}/reactions`,{method:\"POST\",body:JSON.stringify({content:this.config.reactions.initialState})}),await this.fetchFromGitHub(`/issues/${r.number}`,{method:\"PATCH\",body:JSON.stringify({state:\"closed\"})}),{meta:{objectId:e,label:t,createdAt:new Date(r.created_at),updatedAt:new Date(r.updated_at),version:1},data:s}}_verifyIssueLabels(e,s){let t=new Set([this.config.baseLabel,`${this.config.uidPrefix}${s}`]);return e.labels.some(r=>t.has(r.name))}async updateObject(e,s){let t=await this.fetchFromGitHub(\"/issues\",{method:\"GET\",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(\",\"),state:\"all\"}});if(!t||t.length===0)throw new Error(`No object found with ID: ${e}`);let r=t[0],i=this.createCommentPayload(s);return await this.fetchFromGitHub(`/issues/${r.number}/comments`,{method:\"POST\",body:JSON.stringify({body:JSON.stringify(i,null,2)})}),await this.fetchFromGitHub(`/issues/${r.number}`,{method:\"PATCH\",body:JSON.stringify({state:\"open\"})}),this.getObject(e)}async listAll(){let e=await this.fetchFromGitHub(\"/issues\",{method:\"GET\",params:{labels:this.config.baseLabel,state:\"closed\"}}),s={};for(let t of e)if(!t.labels.some(r=>r.name===\"archived\"))try{let r=this._getObjectIdFromLabels(t),i=JSON.parse(t.body),a={objectId:r,label:r,createdAt:new Date(t.created_at),updatedAt:new Date(t.updated_at),version:await this._getVersion(t.number)};s[r]={meta:a,data:i}}catch{continue}return s}async listUpdatedSince(e){let s=await this.fetchFromGitHub(\"/issues\",{method:\"GET\",params:{labels:this.config.baseLabel,state:\"closed\",since:e.toISOString()}}),t={};for(let r of s)if(!r.labels.some(i=>i.name===\"archived\"))try{let i=this._getObjectIdFromLabels(r),a=JSON.parse(r.body),n=new Date(r.updated_at);if(n>e){let c={objectId:i,label:i,createdAt:new Date(r.created_at),updatedAt:n,version:await this._getVersion(r.number)};t[i]={meta:c,data:a}}}catch{continue}return t}async getObjectHistory(e){let s=await this.fetchFromGitHub(\"/issues\",{method:\"GET\",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(\",\"),state:\"all\"}});if(!s||s.length===0)throw new Error(`No object found with ID: ${e}`);let t=s[0],r=await this.fetchFromGitHub(`/issues/${t.number}/comments`),i=[];for(let a of r)try{let n=JSON.parse(a.body),c=\"update\",m,b={client_version:\"legacy\",timestamp:a.created_at,update_mode:\"append\"};typeof n==\"object\"?\"_data\"in n?(c=n.type||\"update\",m=n._data,b=n._meta||b):\"type\"in n&&n.type===\"initial_state\"?(c=\"initial_state\",m=n.data):m=n:m=n,i.push({timestamp:a.created_at,type:c,data:m,commentId:a.id})}catch{continue}return i}async _getVersion(e){return(await this.fetchFromGitHub(`/issues/${e}/comments`)).length+1}_getObjectIdFromLabels(e){for(let s of e.labels)if(s.name!==this.config.baseLabel&&s.name.startsWith(this.config.uidPrefix))return s.name.slice(this.config.uidPrefix.length);throw new Error(`No UID label found with prefix ${this.config.uidPrefix}`)}};var u={baseLabel:\"stored-object\",uidPrefix:\"UID:\",reactions:{processed:\"+1\",initialState:\"rocket\"},retries:{maxAttempts:3,backoffFactor:2},rateLimit:{maxRequestsPerHour:1e3}};function _(o){return{...u,...o,reactions:{...u.reactions,...o.reactions},retries:{...u.retries,...o.retries},rateLimit:{...u.rateLimit,...o.rateLimit}}}function v(o){return/^gh[ps]_[a-zA-Z0-9]{36}$/.test(o)}function P(o){return/^[\\w-]+\\/[\\w-]+$/.test(o)}var h=class extends Error{constructor(e){super(e),this.name=\"ConfigError\"}},g=class extends h{constructor(e=\"Invalid GitHub token format\"){super(e),this.name=\"TokenError\"}},p=class extends h{constructor(e=\"Invalid repository format. Use owner/repo\"){super(e),this.name=\"RepoError\"}};export{h as ConfigError,u as DEFAULT_CONFIG,f as GitHubStoreClient,p as RepoError,g as TokenError,_ as mergeConfig,P as validateRepo,v as validateToken};\n//# sourceMappingURL=index.mjs.map","// extension/papers/source_utils.ts\n// Fixed to export isNewFormat function\n\nimport { pluginRegistry } from './plugins/registry';\nimport { loguru } from '../utils/logger';\n\nconst logger = loguru.getLogger('SourceUtils');\n\n/**\n * Format a source-specific ID into a universal primary ID format\n * Uses source-specific formatId from plugin if available\n * \n * @param {string} source - Source type (e.g. 'arxiv', 'doi')\n * @param {string} id - Original source-specific identifier\n * @returns {string} Formatted primary ID\n */\nexport function formatPrimaryId(source: string, id: string): string {\n  // First check if we have a plugin for this source\n  const plugin = pluginRegistry.get(source);\n  \n  // Use plugin's formatId method if available\n  if (plugin && plugin.formatId) {\n    return plugin.formatId(id);\n  }\n  \n  // Sanitize the ID by replacing problematic characters\n  const safeId = id\n    .replace(/\\//g, '_')\n    .replace(/:/g, '.')\n    .replace(/\\s/g, '_')\n    .replace(/\\\\/g, '_');\n  \n  return `${source}.${safeId}`;\n}\n\n/**\n * Parse a primary ID into its source type and original source ID\n * \n * @param {string} prefixedId - The primary ID in the format \"{source_prefix}.{id}\"\n * @returns {Object} Object with source type and source ID\n */\nexport function parseId(prefixedId: string): { type: string; id: string } {\n  // Split at the first dot\n  const [prefix, ...idParts] = prefixedId.split('.');\n  const id = idParts.join('.'); // Rejoin in case ID contains periods\n  \n  // Map prefix to source type by looking up plugins\n  const plugins = pluginRegistry.getAll();\n  for (const plugin of plugins) {\n    // Check if the plugin's ID format matches the prefix\n    if (plugin.formatId) {\n      const sampleId = plugin.formatId('test');\n      const samplePrefix = sampleId.split('.')[0];\n      if (samplePrefix === prefix) {\n        return {\n          type: plugin.id,\n          id: id\n        };\n      }\n    }\n  }\n  \n  // Assume the prefix is the source type\n  return {\n    type: prefix,\n    id: prefix === 'doi' ? id.replace(/_/g, '/') : id\n  };\n}\n\n/**\n * Checks if a string is in the required prefixed format\n * @param {string} id - ID to check\n * @returns {boolean} True if the ID is in the correct format\n */\nexport function isNewFormat(id: string): boolean {\n  if (!id) return false;\n  \n  // Check if it contains a dot, which separates the source from the ID\n  return id.includes('.');\n}\n\n/**\n * Gets a display label for a source type using the plugin if available\n * \n * @param {string} sourceType - Source type\n * @returns {string} Human-readable label\n */\nexport function getSourceLabel(sourceType: string): string {\n  const plugin = pluginRegistry.get(sourceType);\n  if (plugin) {\n    return plugin.name;\n  }\n  \n  return sourceType.charAt(0).toUpperCase() + sourceType.slice(1);\n}\n\n/**\n * Get canonical URL for a paper using the plugin if available\n * \n * @param {string} sourceType - Source type\n * @param {string} id - Source ID\n * @returns {string} Canonical URL\n */\nexport function getCanonicalUrl(sourceType: string, id: string): string {\n  // First check if a plugin is available for this source\n  const plugin = pluginRegistry.get(sourceType);\n  if (plugin) {\n    // If the plugin has any URL patterns, try to construct a URL\n    if (plugin.urlPatterns && plugin.urlPatterns.length > 0) {\n      const pattern = plugin.urlPatterns[0].toString();\n      // Extract the domain and path pattern\n      const match = pattern.match(/([^/]+)(\\/[^)]+)/);\n      if (match) {\n        const domain = match[1].replace(/\\\\\\./, '.');\n        const path = match[2]\n          .replace(/\\\\\\//g, '/')\n          .replace(/\\([^)]+\\)/, id);\n        return `https://${domain}${path}`;\n      }\n    }\n  }\n  \n  switch (sourceType) {\n    case 'arxiv':\n      return `https://arxiv.org/abs/${id}`;\n    case 'semanticscholar':\n      return `https://www.semanticscholar.org/paper/${id}`;\n    case 'doi':\n      return `https://doi.org/${id}`;\n    case 'acm':\n      return `https://dl.acm.org/doi/${id}`;\n    case 'openreview':\n      return `https://openreview.net/forum?id=${id}`;\n    default:\n      return id.startsWith('10.') ? `https://doi.org/${id}` : \"\";\n  }\n}\n","// extension/papers/manager.ts\n// Refactored to remove legacy ID handling\n\nimport { GitHubStoreClient } from 'gh-store-client';\nimport type { Json } from 'gh-store-client';\nimport { \n  type PaperMetadata, \n  type InteractionLog, \n  type Interaction,\n  type ReadingSessionData\n} from './types';\nimport { formatPrimaryId } from './source_utils';\nimport { loguru } from '../utils/logger';\n\nconst logger = loguru.getLogger('PaperManager');\n\n/**\n * Checks if data is an interaction log\n */\nfunction isInteractionLog(data: any): data is InteractionLog {\n  return typeof data === \"object\" && \n         data !== null && \n         typeof data.paper_id === \"string\" && \n         Array.isArray(data.interactions);\n}\n\nexport class PaperManager {\n  private client: GitHubStoreClient;\n  // Concurrency control locks\n  private creationLocks = new Map<string, Promise<any>>();\n  \n  constructor(client: GitHubStoreClient) {\n    this.client = client;\n  }\n\n  /**\n   * Get or create a paper record\n   */\n  async getOrCreatePaper(paperData: any): Promise<any> {\n    // Ensure paperData has a primary_id\n    if (!paperData.primary_id) {\n      if (paperData.source && paperData.sourceId) {\n        paperData.primary_id = formatPrimaryId(paperData.source, paperData.sourceId);\n      } else {\n        throw new Error(\"Invalid paper data: missing primary_id and cannot generate it\");\n      }\n    }\n    \n    const objectId = `paper:${paperData.primary_id}`;\n    logger.info(`Getting or creating paper: ${objectId}`);\n    \n    try {\n      // Try to get the paper\n      const obj = await this.client.getObject(objectId);\n      const data = obj.data as Record<string, any>;\n      \n      logger.info(`Found existing paper: ${objectId}`);\n      return data;\n    } catch (error) {\n      if (error instanceof Error && error.message.includes(\"No object found\")) {\n        // Create new paper with appropriate fields\n        const defaultPaperData: Record<string, any> = {\n          primary_id: paperData.primary_id,\n          source: paperData.source,\n          sourceId: paperData.sourceId,\n          url: paperData.url || '',\n          title: paperData.title || paperData.sourceId,\n          authors: paperData.authors || '',\n          abstract: paperData.abstract || '',\n          timestamp: new Date().toISOString(),\n          rating: 'novote'\n        };\n        \n        // Add source-specific data directly\n        if (paperData.source_specific_metadata) {\n          defaultPaperData.source_specific_metadata = paperData.source_specific_metadata;\n        }\n        \n        // Always add identifiers object\n        defaultPaperData.identifiers = {\n          original: paperData.sourceId,\n          url: paperData.url\n        };\n        \n        // Add cross-references if available\n        if (paperData.doi) {\n          defaultPaperData.identifiers.doi = paperData.doi;\n        }\n        \n        logger.info(`Creating new paper object: ${objectId}`);\n        try {\n          await this.client.createObject(objectId, defaultPaperData);\n          logger.info(`Successfully created paper: ${objectId}`);\n          return defaultPaperData;\n        } catch (createError) {\n          logger.error(`Error creating paper object: ${createError}`);\n          throw createError;\n        }\n      }\n      logger.error(`Error in getOrCreatePaper: ${error}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Get or create an interaction log\n   */\n  private async getOrCreateInteractionLog(paperId: string): Promise<InteractionLog> {\n    const objectId = `interactions:${paperId}`;\n    \n    // Check if we're already creating this log\n    if (this.creationLocks.has(objectId)) {\n      logger.info(`Waiting for existing creation of interaction log: ${objectId}`);\n      return this.creationLocks.get(objectId) as Promise<InteractionLog>;\n    }\n    \n    // Create a new promise for this operation\n    const creationPromise = (async () => {\n      try {\n        const obj = await this.client.getObject(objectId);\n        const data = obj.data;\n        \n        if (isInteractionLog(data)) {\n          return data;\n        }\n        \n        throw new Error('Invalid interaction log format');\n      } catch (error) {\n        if (error instanceof Error && error.message.includes('No object found')) {\n          // Create new log\n          const newLog: InteractionLog = {\n            paper_id: paperId,\n            interactions: []\n          };\n          \n          logger.info(`Creating new interaction log: ${objectId}`);\n          await this.client.createObject(objectId, newLog);\n          return newLog;\n        }\n        throw error;\n      } finally {\n        // Release the lock after a delay\n        setTimeout(() => {\n          this.creationLocks.delete(objectId);\n        }, 500);\n      }\n    })();\n    \n    // Store the promise\n    this.creationLocks.set(objectId, creationPromise);\n    \n    return creationPromise;\n  }\n\n  /**\n   * Log a reading session for a paper\n   */\n  async logReadingSession(\n    paperId: string,\n    session: ReadingSessionData,\n    paperData?: any\n  ): Promise<void> {\n    // Ensure paper exists with proper data\n    if (paperData) {\n      if (!paperData.primary_id) {\n        paperData.primary_id = paperId;\n      }\n      await this.getOrCreatePaper(paperData);\n    }\n\n    // Log the session as interaction\n    await this.addInteraction(paperId, {\n      type: \"reading_session\",\n      timestamp: new Date().toISOString(),\n      data: session\n    });\n  }\n\n  /**\n   * Log an annotation for a paper\n   */\n  async logAnnotation(\n    paperId: string,\n    key: string,\n    value: Json,\n    paperData?: any\n  ): Promise<void> {\n    // Ensure paper exists with proper data\n    if (paperData) {\n      if (!paperData.primary_id) {\n        paperData.primary_id = paperId;\n      }\n      await this.getOrCreatePaper(paperData);\n    }\n\n    // Log the annotation as interaction\n    await this.addInteraction(paperId, {\n      type: \"annotation\",\n      timestamp: new Date().toISOString(),\n      data: { key, value }\n    });\n  }\n\n  /**\n   * Update a paper's rating\n   */\n  async updateRating(\n    paperId: string,\n    rating: string,\n    paperData?: any\n  ): Promise<void> {\n    // Get existing paper data\n    const paper = await this.getOrCreatePaper(paperData || { primary_id: paperId });\n\n    // Update rating\n    const objectId = `paper:${paperId}`;\n    await this.client.updateObject(objectId, { \n      ...paper,\n      rating \n    });\n\n    // Log rating change\n    await this.addInteraction(paperId, {\n      type: \"rating\",\n      timestamp: new Date().toISOString(),\n      data: { rating }\n    });\n  }\n\n  /**\n   * Add an interaction to a paper's log\n   */\n  private async addInteraction(paperId: string, interaction: Interaction): Promise<void> {\n    const log = await this.getOrCreateInteractionLog(paperId);\n    log.interactions.push(interaction);\n    \n    // Store with the standard format ID\n    const objectId = `interactions:${paperId}`;\n    await this.client.updateObject(objectId, log);\n  }\n\n  /**\n   * Get interactions for a paper\n   */\n  async getInteractions(\n    paperId: string,\n    options: {\n      type?: string;\n      startTime?: Date;\n      endTime?: Date;\n    } = {}\n  ): Promise<Interaction[]> {\n    try {\n      const log = await this.getOrCreateInteractionLog(paperId);\n      let interactions = log.interactions;\n\n      if (options.type) {\n        interactions = interactions.filter((i: Interaction) => i.type === options.type);\n      }\n\n      if (options.startTime || options.endTime) {\n        interactions = interactions.filter((i: Interaction) => {\n          const time = new Date(i.timestamp);\n          if (options.startTime && time < options.startTime) return false;\n          if (options.endTime && time > options.endTime) return false;\n          return true;\n        });\n      }\n\n      return interactions;\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('No object found')) {\n        return [];\n      }\n      throw error;\n    }\n  }\n  \n  /**\n   * Get total reading time for a paper\n   */\n  async getPaperReadingTime(paperId: string): Promise<number> {\n    const interactions = await this.getInteractions(paperId, { type: 'reading_session' });\n    return interactions.reduce((total, i) => {\n      const data = i.data;\n      if (typeof data === 'object' && data !== null && 'duration_seconds' in data) {\n        return total + (data.duration_seconds as number);\n      }\n      return total;\n    }, 0);\n  }\n\n  /**\n   * Get paper history\n   */\n  async getPaperHistory(paperId: string): Promise<Json[]> {\n    const objectId = `paper:${paperId}`;\n    return this.client.getObjectHistory(objectId);\n  }\n}\n","// extension/background/credential_manager.ts - Handles GitHub credentials\n\nimport { loguru } from \"../utils/logger\";\nimport { GitHubStoreClient } from 'gh-store-client';\nimport { PaperManager } from '../papers/manager';\n\nconst logger = loguru.getLogger('CredentialManager');\n\n/**\n * Manages GitHub credentials and paper manager instantiation\n */\nexport class CredentialManager {\n  private githubToken: string;\n  private githubRepo: string;\n  private paperManager: PaperManager | null;\n  \n  constructor() {\n    this.githubToken = '';\n    this.githubRepo = '';\n    this.paperManager = null;\n    \n    // Setup storage change listener\n    chrome.storage.onChanged.addListener(this._handleStorageChanges.bind(this));\n  }\n\n  /**\n   * Load credentials from storage\n   * @returns {Promise<{paperManager: PaperManager|null}>}\n   */\n  async loadCredentials(): Promise<{paperManager: PaperManager | null}> {\n    const items = await chrome.storage.sync.get(['githubToken', 'githubRepo']);\n    this.githubToken = items.githubToken || '';\n    this.githubRepo = items.githubRepo || '';\n    \n    logger.info('Credentials loaded:', { \n      hasToken: !!this.githubToken, \n      hasRepo: !!this.githubRepo \n    });\n    \n    return this._initializePaperManager();\n  }\n\n  /**\n   * Initialize the paper manager if credentials are available\n   * @private\n   * @returns {Promise<{paperManager: PaperManager|null}>}\n   */\n  private async _initializePaperManager(): Promise<{paperManager: PaperManager | null}> {\n    if (this.githubToken && this.githubRepo) {\n      const githubClient = new GitHubStoreClient(this.githubToken, this.githubRepo);\n      this.paperManager = new PaperManager(githubClient);\n      logger.info('Paper manager initialized');\n    } else {\n      this.paperManager = null;\n      logger.info('Paper manager not initialized - missing credentials');\n    }\n    \n    return { paperManager: this.paperManager };\n  }\n\n  /**\n   * Handle storage changes\n   * @private\n   * @param {Object} changes - Storage changes object\n   */\n  private async _handleStorageChanges(changes: {[key: string]: chrome.storage.StorageChange}) {\n    let credentialsChanged = false;\n    \n    if (changes.githubToken) {\n      this.githubToken = changes.githubToken.newValue;\n      credentialsChanged = true;\n    }\n    \n    if (changes.githubRepo) {\n      this.githubRepo = changes.githubRepo.newValue;\n      credentialsChanged = true;\n    }\n    \n    if (credentialsChanged) {\n      logger.info('GitHub credentials changed, reinitializing paper manager');\n      await this._initializePaperManager();\n    }\n  }\n\n  /**\n   * Get the current paper manager instance\n   * @returns {PaperManager|null}\n   */\n  getPaperManager(): PaperManager | null {\n    return this.paperManager;\n  }\n\n  /**\n   * Check if credentials are configured\n   * @returns {boolean}\n   */\n  hasValidCredentials(): boolean {\n    return !!(this.githubToken && this.githubRepo);\n  }\n}\n\nexport default new CredentialManager();\n","// extension/config/session.ts\n\n// Define the configuration interface\nexport interface SessionConfig {\n    idleThresholdMinutes: number;\n    minSessionDurationSeconds: number;\n    requireContinuousActivity: boolean;\n    logPartialSessions: boolean;\n    activityUpdateIntervalSeconds: number;\n}\n\nexport interface SessionConfigMs {\n    idleThreshold: number;\n    minSessionDuration: number;\n    activityUpdateInterval: number;\n    requireContinuousActivity: boolean;\n    logPartialSessions: boolean;\n}\n\n// Default configuration values\nexport const DEFAULT_CONFIG: SessionConfig = {\n    idleThresholdMinutes: 5,\n    minSessionDurationSeconds: 30,\n    // Adding more granular control\n    requireContinuousActivity: true,  // If true, resets timer on idle\n    logPartialSessions: false,        // If true, logs sessions even if under minimum duration\n    activityUpdateIntervalSeconds: 1  // How often to update active time\n};\n\n// Load session configuration from storage\nexport async function loadSessionConfig(): Promise<SessionConfig> {\n    const items = await chrome.storage.sync.get('sessionConfig');\n    return { ...DEFAULT_CONFIG, ...items.sessionConfig };\n}\n\n// Save session configuration to storage\nexport async function saveSessionConfig(config: Partial<SessionConfig>): Promise<void> {\n    await chrome.storage.sync.set({\n        sessionConfig: {\n            idleThresholdMinutes: Number(config.idleThresholdMinutes),\n            minSessionDurationSeconds: Number(config.minSessionDurationSeconds),\n            requireContinuousActivity: Boolean(config.requireContinuousActivity),\n            logPartialSessions: Boolean(config.logPartialSessions),\n            activityUpdateIntervalSeconds: Number(config.activityUpdateIntervalSeconds)\n        }\n    });\n}\n\n// Convert configuration to milliseconds for internal use\nexport function getConfigurationInMs(config: SessionConfig): SessionConfigMs {\n    return {\n        idleThreshold: config.idleThresholdMinutes * 60 * 1000,\n        minSessionDuration: config.minSessionDurationSeconds * 1000,\n        activityUpdateInterval: config.activityUpdateIntervalSeconds * 1000,\n        requireContinuousActivity: config.requireContinuousActivity,\n        logPartialSessions: config.logPartialSessions\n    };\n}\n","// extension/background/session_manager.ts - Manages reading sessions\n\nimport { loguru } from \"../utils/logger\";\nimport { \n  loadSessionConfig, \n  getConfigurationInMs, \n  SessionConfig as SessionConfigBase,\n  SessionConfigMs,\n  DEFAULT_CONFIG\n} from '../config/session';\nimport credentialManager from './credential_manager';\n\nconst logger = loguru.getLogger('SessionManager');\n\n// Use the SessionConfigMs interface from our module\ntype SessionConfig = SessionConfigMs;\n\ninterface PaperData {\n  primary_id: string;\n  source: string;\n  sourceId: string;\n  url: string;\n  title: string;\n  [key: string]: any;\n}\n\ninterface SessionData {\n  session_id: string;\n  duration_seconds: number;\n  idle_seconds: number;\n  start_time: string;\n  end_time: string;\n  total_elapsed_seconds: number;\n  [key: string]: any;\n}\n\ninterface SessionMetadata {\n  sourceType: string;\n  paperId: string;\n  title: string;\n  sessionId: string;\n  startTime: string;\n  activeSeconds: number;\n  idleSeconds: number;\n}\n\n/**\n * Enhanced reading session for modern format\n */\nclass EnhancedReadingSession {\n  paperId: string;\n  paperData: PaperData;\n  sessionId: string;\n  startTime: Date;\n  activeTime: number;\n  idleTime: number;\n  lastActiveTime: Date;\n  isTracking: boolean;\n  config: SessionConfig;\n  endTime: Date | null;\n  finalizedData: SessionData | null;\n\n  /**\n   * Create a new reading session\n   * @param {PaperData} paperData - Paper metadata\n   * @param {SessionConfig} config - Session configuration\n   */\n  constructor(paperData: PaperData, config: SessionConfig) {\n    // Validate required fields\n    if (!paperData.primary_id) {\n      throw new Error('Paper data must include primary_id');\n    }\n    \n    this.paperId = paperData.primary_id;\n    this.paperData = paperData;\n    \n    // Generate unique session ID\n    this.sessionId = `session_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n    \n    // Initialize timing data\n    this.startTime = new Date();\n    this.activeTime = 0;\n    this.idleTime = 0;\n    this.lastActiveTime = new Date();\n    this.isTracking = true;\n    this.config = config;\n    this.endTime = null;\n    this.finalizedData = null;\n  }\n  \n  /**\n   * Update session timing data\n   */\n  update(): void {\n    if (this.isTracking && !this.finalizedData) {\n      const now = new Date();\n      const timeSinceLastActive = now.getTime() - this.lastActiveTime.getTime();\n      \n      if (timeSinceLastActive < this.config.idleThreshold) {\n        this.activeTime += timeSinceLastActive;\n      } else {\n        this.idleTime += timeSinceLastActive;\n      }\n      \n      this.lastActiveTime = now;\n    }\n  }\n  \n  /**\n   * Finalize session data\n   * @returns {SessionData|null} Session data or null if session was too short\n   */\n  finalize(): SessionData | null {\n    if (this.finalizedData) {\n      return this.finalizedData;\n    }\n \n    this.update();\n    this.isTracking = false;\n    this.endTime = new Date();\n    const totalElapsed = this.endTime.getTime() - this.startTime.getTime();\n \n    if (this.activeTime >= this.config.minSessionDuration) {\n      this.finalizedData = {\n        session_id: this.sessionId,\n        duration_seconds: Math.round(this.activeTime / 1000),\n        idle_seconds: Math.round(this.idleTime / 1000),\n        start_time: this.startTime.toISOString(),\n        end_time: this.endTime.toISOString(),\n        total_elapsed_seconds: Math.round(totalElapsed / 1000)\n      };\n      return this.finalizedData;\n    }\n    return null;\n  }\n  \n  /**\n   * Get session metadata\n   * @returns {SessionMetadata} Session metadata\n   */\n  getMetadata(): SessionMetadata {\n    return {\n      sourceType: this.paperData.source,\n      paperId: this.paperId,\n      title: this.paperData.title,\n      sessionId: this.sessionId,\n      startTime: this.startTime.toISOString(),\n      activeSeconds: Math.round(this.activeTime / 1000),\n      idleSeconds: Math.round(this.idleTime / 1000)\n    };\n  }\n}\n\n/**\n * Manages paper reading sessions\n */\nexport class SessionManager {\n  currentPaperData: PaperData | null;\n  currentSession: EnhancedReadingSession | null;\n  activityInterval: number | null;\n  sessionConfig: SessionConfig | null;\n\n  constructor() {\n    this.currentPaperData = null;\n    this.currentSession = null;\n    this.activityInterval = null;\n    this.sessionConfig = null;\n  }\n\n  /**\n   * Load session configuration\n   * @returns {Promise<SessionConfig>} Session configuration\n   */\n  async loadSessionConfig(): Promise<SessionConfig> {\n    const config = await loadSessionConfig();\n    this.sessionConfig = getConfigurationInMs(config);\n    logger.info('Session configuration loaded:', this.sessionConfig);\n    \n    // Listen for configuration changes\n    chrome.storage.onChanged.addListener((changes) => {\n      if (changes.sessionConfig) {\n        this.sessionConfig = getConfigurationInMs(changes.sessionConfig.newValue);\n        logger.info('Session configuration updated:', this.sessionConfig);\n      }\n    });\n    \n    return this.sessionConfig;\n  }\n\n  /**\n   * Start a new reading session for a paper\n   * @param {PaperData} paperData - Paper metadata\n   * @returns {SessionMetadata|null} Session metadata\n   */\n  startSession(paperData: PaperData): SessionMetadata | null {\n    if (!paperData || !paperData.primary_id) {\n      logger.error('Cannot start session: invalid paper data');\n      return null;\n    }\n\n    if (!this.sessionConfig) {\n      logger.error('Session configuration not loaded, loading default config');\n      // Use default config if not loaded\n      this.sessionConfig = getConfigurationInMs(DEFAULT_CONFIG);\n    }\n    \n    // End any existing session\n    if (this.currentSession) {\n      logger.info('Ending existing session before starting new one');\n      this.endCurrentSession();\n    }\n    \n    logger.info(`Starting new session for: ${paperData.primary_id}`);\n    \n    // Store current paper data\n    this.currentPaperData = paperData;\n    \n    // Create a new reading session\n    this.currentSession = new EnhancedReadingSession(paperData, this.sessionConfig);\n    \n    const metadata = this.currentSession.getMetadata();\n    logger.info('New session created:', metadata);\n    \n    // Start tracking reading time\n    this._startActivityTracking();\n    \n    return metadata;\n  }\n\n  /**\n   * End the current reading session\n   * @returns {Promise<{paperData: PaperData, sessionData: SessionData} | null>} Session result or null if no active session\n   */\n  async endCurrentSession(): Promise<{paperData: PaperData, sessionData: SessionData | null} | null> {\n    if (this.currentSession && this.currentPaperData) {\n      logger.info(`Ending session for: ${this.currentPaperData.primary_id}`);\n      const sessionData = this.currentSession.finalize();\n      \n      if (sessionData) {\n        logger.info('Creating reading event:', sessionData);\n        await this._createReadingEvent(this.currentPaperData, sessionData);\n      }\n      \n      const result = {\n        paperData: this.currentPaperData,\n        sessionData: sessionData\n      };\n      \n      this.currentSession = null;\n      this.currentPaperData = null;\n      this._stopActivityTracking();\n      \n      return result;\n    }\n    \n    return null;\n  }\n\n  /**\n   * Get the current paper data\n   * @returns {PaperData|null} Current paper data\n   */\n  getCurrentPaper(): PaperData | null {\n    return this.currentPaperData;\n  }\n\n  /**\n   * Start tracking activity\n   * @private\n   */\n  private _startActivityTracking(): void {\n    if (!this.activityInterval && this.sessionConfig) {\n      logger.info('Starting activity tracking');\n      this.activityInterval = window.setInterval(() => {\n        if (this.currentSession) {\n          this.currentSession.update();\n        }\n      }, this.sessionConfig.activityUpdateInterval);\n    }\n  }\n\n  /**\n   * Stop tracking activity\n   * @private\n   */\n  private _stopActivityTracking(): void {\n    if (this.activityInterval) {\n      clearInterval(this.activityInterval);\n      this.activityInterval = null;\n    }\n  }\n\n  /**\n   * Create reading event in GitHub\n   * @private\n   * @param {PaperData} paperData - Paper metadata\n   * @param {SessionData} sessionData - Session data\n   * @returns {Promise<void>}\n   */\n  private async _createReadingEvent(paperData: PaperData, sessionData: SessionData): Promise<void> {\n    const paperManager = credentialManager.getPaperManager();\n    \n    if (!paperManager || !paperData) {\n      logger.error('Missing required data for creating reading event:', {\n        hasPaperManager: !!paperManager,\n        hasPaperData: !!paperData\n      });\n      return;\n    }\n\n    try {\n      // Always use primary_id for storage\n      if (!paperData.primary_id) {\n        logger.error('Paper data missing primary_id. This should not happen.');\n        return;\n      }\n      \n      const paperId = paperData.primary_id;\n      \n      await paperManager.logReadingSession(\n        paperId,\n        sessionData,\n        paperData\n      );\n      \n      logger.info('Reading session logged:', {\n        paperId: paperId,\n        sessionId: sessionData.session_id,\n        activeTime: sessionData.duration_seconds,\n        idleTime: sessionData.idle_seconds,\n        totalTime: sessionData.total_elapsed_seconds\n      });\n      \n    } catch (error) {\n      logger.error('Error logging reading session:', error);\n    }\n  }\n}\n\nexport default new SessionManager();\n","// extension/papers/metadata_service.ts - Paper metadata extraction service\n\nimport { loguru } from \"../utils/logger\";\nimport { DetectedSourceInfo } from './detection_service';\n\nconst logger = loguru.getLogger('MetadataService');\n\n/**\n * Extract metadata from a detected source using its plugin\n * @param {DetectedSourceInfo} sourceInfo Source info with plugin\n * @returns {Promise<any|null>} Extracted metadata or null\n */\nexport async function extractMetadataFromSource(sourceInfo: DetectedSourceInfo): Promise<any | null> {\n  if (!sourceInfo || !sourceInfo.plugin) {\n    logger.info('No valid source info or plugin');\n    return null;\n  }\n  \n  try {\n    // Try to use the plugin's API if available\n    if (sourceInfo.plugin.hasApi && sourceInfo.plugin.fetchApiData) {\n      try {\n        logger.info(`Using ${sourceInfo.plugin.id} plugin API to extract metadata`);\n        const apiData = await sourceInfo.plugin.fetchApiData(sourceInfo.id);\n        \n        if (apiData && Object.keys(apiData).length > 0) {\n          // Ensure required fields are present\n          return {\n            ...apiData,\n            source: sourceInfo.type,\n            sourceId: sourceInfo.id,\n            primary_id: sourceInfo.primary_id,\n            url: sourceInfo.url\n          };\n        }\n      } catch (apiError) {\n        logger.error(`Error using plugin API: ${apiError}`);\n      }\n    }\n    \n    // Fall back to default minimal data\n    return {\n      source: sourceInfo.type,\n      sourceId: sourceInfo.id,\n      primary_id: sourceInfo.primary_id,\n      url: sourceInfo.url,\n      title: `${sourceInfo.type.toUpperCase()} Paper: ${sourceInfo.id}`,\n      timestamp: new Date().toISOString(),\n      rating: 'novote'\n    };\n  } catch (error) {\n    logger.error(`Error extracting metadata: ${error}`);\n    return null;\n  }\n}\n\n/**\n * Extract metadata from DOM using plugin's extraction method\n * @param {number} tabId Tab ID for DOM access\n * @param {DetectedSourceInfo} sourceInfo Source info with plugin\n * @returns {Promise<any|null>} Extracted metadata or null\n */\nexport async function extractMetadataFromDOM(tabId: number, sourceInfo: DetectedSourceInfo): Promise<any | null> {\n  if (!sourceInfo || !sourceInfo.plugin || !sourceInfo.plugin.extractMetadata) {\n    return null;\n  }\n  \n  try {\n    logger.info(`Attempting DOM extraction for ${sourceInfo.type}`);\n    \n    // Execute script to get HTML document\n    const script = await chrome.scripting.executeScript({\n      target: { tabId },\n      func: () => document.documentElement.outerHTML\n    });\n    \n    if (script && script[0] && script[0].result) {\n      // Create DOM document from HTML for service worker context\n      // Use non-DOM parser for service worker environment\n      try {\n        const htmlString = script[0].result as string;\n        \n        // Since we're in a service worker, we need to use a different approach for metadata extraction\n        // Ask the plugin to extract metadata - must be a service worker safe implementation\n        const metadata = await sourceInfo.plugin.extractMetadata({\n          documentElement: { outerHTML: htmlString }\n        }, sourceInfo.url);\n        \n        if (metadata && Object.keys(metadata).length > 0) {\n          return {\n            ...metadata,\n            source: sourceInfo.type,\n            sourceId: sourceInfo.id,\n            primary_id: sourceInfo.primary_id,\n            url: sourceInfo.url\n          };\n        }\n      } catch (parserError) {\n        logger.error(`Error parsing HTML in service worker: ${parserError}`);\n        // Fall back to direct string content\n        try {\n          // Use a simpler approach - pass the HTML as a string\n          const metadata = await sourceInfo.plugin.extractMetadata(\n            { innerHTML: script[0].result },\n            sourceInfo.url\n          );\n          \n          if (metadata && Object.keys(metadata).length > 0) {\n            return {\n              ...metadata,\n              source: sourceInfo.type,\n              sourceId: sourceInfo.id,\n              primary_id: sourceInfo.primary_id,\n              url: sourceInfo.url\n            };\n          }\n        } catch (fallbackError) {\n          logger.error(`Error with fallback metadata extraction: ${fallbackError}`);\n        }\n      }\n    }\n  } catch (error) {\n    logger.error(`Error extracting metadata from DOM: ${error}`);\n  }\n  \n  return null;\n}\n\n/**\n * Process a paper URL to extract full metadata\n * @param {string} url URL to process\n * @param {DetectedSourceInfo} sourceInfo Source detection info\n * @param {number|null} tabId Optional tab ID for DOM access\n * @returns {Promise<any|null>} Full paper data or null\n */\nexport async function extractPaperMetadata(\n  sourceInfo: DetectedSourceInfo, \n  tabId: number | null = null\n): Promise<any | null> {\n  try {\n    if (!sourceInfo) {\n      logger.info('No source info provided');\n      return null;\n    }\n    \n    logger.info(`Extracting metadata for ${sourceInfo.type} paper: ${sourceInfo.id}`);\n    \n    // Try API metadata extraction first\n    let paperData = await extractMetadataFromSource(sourceInfo);\n    \n    // If API extraction failed or returned minimal data and we have a tab ID,\n    // try DOM extraction as a fallback\n    if (tabId && (!paperData || !paperData.title || paperData.title.includes(sourceInfo.id))) {\n      logger.info('API extraction failed or returned minimal data, trying DOM extraction');\n      const domData = await extractMetadataFromDOM(tabId, sourceInfo);\n      \n      if (domData) {\n        // Merge API and DOM data, with DOM data taking precedence\n        paperData = {\n          ...paperData,\n          ...domData,\n          // Ensure critical fields are preserved\n          source: sourceInfo.type,\n          sourceId: sourceInfo.id,\n          primary_id: sourceInfo.primary_id,\n          url: sourceInfo.url\n        };\n      }\n    }\n    \n    if (paperData) {\n      logger.info(`Successfully extracted metadata: ${paperData.title || paperData.primary_id}`);\n    }\n    \n    return paperData;\n  } catch (error) {\n    logger.error(`Error extracting paper metadata: ${error}`);\n    return null;\n  }\n}\n","// extension/papers/paper_processor.ts - Complete paper processing pipeline\n\nimport { loguru } from \"../utils/logger\";\nimport { processUrl, processTab, processNavigation } from './detection_service';\nimport { extractPaperMetadata } from './metadata_service';\n\nconst logger = loguru.getLogger('PaperProcessor');\n\n/**\n * Fully process a URL with detection and metadata extraction\n * @param {string} url URL to process\n * @param {number|null} tabId Optional tab ID for DOM access\n * @returns {Promise<Object|null>} Full paper data or null\n */\nexport async function fullyProcessUrl(url: string, tabId: number | null = null): Promise<any | null> {\n  try {\n    // First detect the source\n    const sourceInfo = await processUrl(url);\n    \n    if (!sourceInfo) {\n      logger.info(`No source detected for URL: ${url}`);\n      return null;\n    }\n    \n    logger.info(`Detected ${sourceInfo.type} paper: ${sourceInfo.id}`);\n    \n    // Then extract metadata using the appropriate plugin\n    return await extractPaperMetadata(sourceInfo, tabId);\n  } catch (error) {\n    logger.error(`Error fully processing URL ${url}:`, error);\n    return null;\n  }\n}\n\n/**\n * Fully process a tab with detection and metadata extraction\n * @param {chrome.tabs.Tab} tab Tab to process\n * @returns {Promise<Object|null>} Full paper data or null\n */\nexport async function fullyProcessTab(tab: chrome.tabs.Tab): Promise<any | null> {\n  if (!tab.url || !tab.id) {\n    logger.info('Tab has no URL or ID');\n    return null;\n  }\n  \n  try {\n    // First detect the source\n    const sourceInfo = await processTab(tab);\n    \n    if (!sourceInfo) {\n      logger.info(`No source detected for tab URL: ${tab.url}`);\n      return null;\n    }\n    \n    logger.info(`Detected ${sourceInfo.type} paper: ${sourceInfo.id} in tab ${tab.id}`);\n    \n    // Then extract metadata using the appropriate plugin\n    return await extractPaperMetadata(sourceInfo, tab.id);\n  } catch (error) {\n    logger.error(`Error fully processing tab: ${error}`);\n    return null;\n  }\n}\n\n/**\n * Fully process a navigation event with detection and metadata extraction\n * @param {Object} details Navigation details\n * @returns {Promise<Object|null>} Full paper data or null\n */\nexport async function fullyProcessNavigation(details: {\n  tabId: number;\n  url: string;\n  frameId: number;\n  timeStamp: number;\n}): Promise<any | null> {\n  if (!details.url || !details.tabId) {\n    logger.info('Navigation has no URL or tab ID');\n    return null;\n  }\n  \n  try {\n    // First detect the source\n    const sourceInfo = await processNavigation(details);\n    \n    if (!sourceInfo) {\n      logger.info(`No source detected for navigation URL: ${details.url}`);\n      return null;\n    }\n    \n    logger.info(`Detected ${sourceInfo.type} paper: ${sourceInfo.id} in navigation`);\n    \n    // Then extract metadata using the appropriate plugin\n    return await extractPaperMetadata(sourceInfo, details.tabId);\n  } catch (error) {\n    logger.error(`Error fully processing navigation: ${error}`);\n    return null;\n  }\n}\n","// extension/background/github_integration.ts - GitHub API integration\n\nimport { loguru } from \"../utils/logger\";\nimport { formatPrimaryId } from '../papers/source_utils';\nimport credentialManager from './credential_manager';\nimport { PaperData } from '../types/common';\n\nconst logger = loguru.getLogger('GitHubIntegration');\n\n/**\n * Handles GitHub integration for paper storage\n */\nexport class GitHubIntegration {\n  /**\n   * Create or update a GitHub issue for a paper\n   * @param {PaperData} paperData - Paper metadata\n   * @returns {Promise<PaperData|null>} Created or updated paper data\n   */\n  async createGithubIssue(paperData: PaperData): Promise<PaperData | null> {\n    const paperManager = credentialManager.getPaperManager();\n    \n    if (!paperManager) {\n      logger.error('Paper manager not initialized');\n      return null;\n    }\n\n    // Ensure paper has primary_id\n    if (!paperData.primary_id) {\n      if (paperData.source && paperData.sourceId) {\n        paperData.primary_id = formatPrimaryId(paperData.source, paperData.sourceId);\n      } else {\n        logger.error('Cannot create paper - no valid identifier');\n        return null;\n      }\n    }\n    \n    try {\n      logger.info(`Creating/getting paper issue: ${paperData.primary_id}`);\n      const existingPaper = await paperManager.getOrCreatePaper(paperData);\n      logger.info(`Paper metadata stored/retrieved: ${existingPaper.primary_id}`);\n      return existingPaper;\n    } catch (error) {\n      logger.error(`Error handling paper metadata: ${error}`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Update paper rating\n   * @param {PaperData} paperData - Paper metadata\n   * @param {string} rating - Rating value\n   * @returns {Promise<boolean>} Success status\n   */\n  async updateRating(paperData: PaperData, rating: string): Promise<boolean> {\n    const paperManager = credentialManager.getPaperManager();\n    \n    if (!paperManager) {\n      logger.error('Paper manager not initialized');\n      return false;\n    }\n\n    try {\n      // Always use primary_id for rating updates\n      const paperId = paperData.primary_id;\n      \n      if (!paperId) {\n        logger.error('Paper data missing primary_id');\n        return false;\n      }\n      \n      await paperManager.updateRating(paperId, rating, paperData);\n      logger.info(`Updated rating for ${paperId}: ${rating}`);\n      return true;\n    } catch (error) {\n      logger.error('Error updating rating:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Update paper annotation\n   * @param {string} type - Annotation type\n   * @param {Object} data - Annotation data\n   * @returns {Promise<boolean>} Success status\n   */\n  async updateAnnotation(type: string, data: {\n    paperId: string;\n    source?: string;\n    title?: string;\n    vote?: string;\n    notes?: string;\n    [key: string]: any;\n  }): Promise<boolean> {\n    const paperManager = credentialManager.getPaperManager();\n    \n    if (!paperManager) {\n      logger.error('Paper manager not initialized');\n      return false;\n    }\n\n    try {\n      // Ensure we have a valid paper ID\n      let paperId = data.paperId;\n      \n      // If we get a legacy ID without the source prefix, try to determine the source from context\n      if (!paperId.includes('.')) {\n        // Try to determine source from data\n        const source = data.source || 'arxiv'; // Default to arxiv if not specified\n        paperId = formatPrimaryId(source, paperId);\n        logger.info(`Converted ID to standardized format: ${paperId}`);\n      }\n      \n      const paperData: PaperData | undefined = data.title ? {\n        title: data.title,\n        source: data.source || 'unknown',\n        sourceId: paperId.split('.')[1] || paperId,\n        primary_id: paperId,\n        url: ''\n      } : undefined;\n\n      if (type === 'vote') {\n        await paperManager.updateRating(\n          paperId,\n          data.vote!,\n          paperData\n        );\n      } else {\n        await paperManager.logAnnotation(\n          paperId,\n          'notes',\n          data.notes!,\n          paperData\n        );\n      }\n\n      return true;\n    } catch (error) {\n      logger.error('Error logging interaction:', error);\n      return false;\n    }\n  }\n}\n\nexport default new GitHubIntegration();\n","// extension/background/event_handlers.ts - Tab and navigation event handlers\n\nimport { loguru } from \"../utils/logger\";\nimport { processNavigation, processTab } from '../papers/detection_service';\nimport { fullyProcessUrl, fullyProcessTab } from '../papers/paper_processor';\nimport { pluginRegistry } from '../papers/plugins/registry';\nimport sessionManager from './session_manager';\nimport githubIntegration from './github_integration';\n\nconst logger = loguru.getLogger('EventHandlers');\n\ninterface NavDetails {\n  tabId: number;\n  url: string;\n  frameId: number;\n  timeStamp: number;\n}\n\ninterface HostPattern {\n  hostSuffix?: string;\n  hostEquals?: string;\n  hostPrefix?: string;\n  [key: string]: string | undefined;\n}\n\ntype Plugin = {\n  id: string;\n  urlPatterns: RegExp[];\n  [key: string]: any;\n};\n\n/**\n * Manages tab and navigation event handlers\n */\nexport class EventHandlers {\n  private pendingUrls: Set<string>;\n\n  constructor() {\n    this.pendingUrls = new Set();\n  }\n\n  /**\n   * Set up all event listeners\n   * @returns {Promise<void>}\n   */\n  async setupListeners(): Promise<void> {\n    logger.info('Setting up unified event listeners');\n    \n    // Get all supported hosts from plugins\n    const plugins = pluginRegistry.getAll();\n    \n    // Create host patterns from all plugins\n    const hostPatterns = this._buildHostPatterns(plugins);\n    \n    logger.info(`Setting up navigation listener with patterns: ${JSON.stringify(hostPatterns)}`);\n    \n    // CONSOLIDATED LISTENER: Set up a single navigation listener with all hosts\n    chrome.webNavigation.onCompleted.addListener(\n      this.handleUnifiedNavigation.bind(this), \n      { url: hostPatterns }\n    );\n    \n    // CONSOLIDATED LISTENER: Set up a single tab activation listener\n    chrome.tabs.onActivated.addListener(\n      this.handleUnifiedTabActivation.bind(this)\n    );\n    \n    // CONSOLIDATED LISTENER: Set up a single tab update listener\n    chrome.tabs.onUpdated.addListener(\n      this.handleUnifiedTabUpdate.bind(this)\n    );\n    \n    // Window focus changes\n    chrome.windows.onFocusChanged.addListener((windowId) => {\n      if (windowId === chrome.windows.WINDOW_ID_NONE) {\n        sessionManager.endCurrentSession();\n      }\n    });\n    \n    logger.info('All event listeners initialized');\n  }\n\n  /**\n   * Build host patterns from plugins\n   * @private\n   * @param {Plugin[]} plugins - Available plugins\n   * @returns {HostPattern[]} Host patterns for navigation listener\n   */\n  private _buildHostPatterns(plugins: Plugin[]): HostPattern[] {\n    const hostPatterns: HostPattern[] = [];\n    \n    for (const plugin of plugins) {\n      // Add all the plugin URL patterns if possible\n      try {\n        // Extract domain patterns from the plugin's URL patterns\n        for (const pattern of plugin.urlPatterns) {\n          const patternStr = pattern.toString();\n          // Extract domain from pattern - this is a simplified approach\n          const match = patternStr.match(/([a-zA-Z0-9.-]+)\\\\?\\.([a-zA-Z]+)/);\n          if (match) {\n            const domain = match[1];\n            const tld = match[2];\n            hostPatterns.push({ hostSuffix: `${domain}.${tld}` });\n          }\n        }\n      } catch (err) {\n        logger.error(`Error processing plugin URL patterns: ${err}`);\n      }\n    }\n    \n    // Add default patterns if we couldn't extract from plugins\n    if (hostPatterns.length === 0) {\n      hostPatterns.push(\n        { hostSuffix: 'arxiv.org' },\n        { hostSuffix: 'semanticscholar.org' },\n        { hostSuffix: 'doi.org' },\n        { hostSuffix: 'dl.acm.org' },\n        { hostSuffix: 'openreview.net' }\n      );\n    }\n    \n    return hostPatterns;\n  }\n\n  /**\n   * Handle navigation events\n   * @param {NavDetails} details - Navigation details\n   * @returns {Promise<void>}\n   */\n  async handleUnifiedNavigation(details: NavDetails): Promise<void> {\n    logger.info(`Unified navigation handler: ${details.url}`);\n    \n    try {\n      // Use enhanced detection service\n      const sourceInfo = await processNavigation(details);\n      \n      if (!sourceInfo) {\n        logger.info('Not a recognized paper URL');\n        return;\n      }\n      \n      logger.info(`Detected paper: ${sourceInfo.type}:${sourceInfo.id}`);\n      \n      // Check if tab is active\n      const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n      if (tabs.length > 0 && tabs[0].id === details.tabId) {\n        // This is the active tab, handle as tab change\n        await this.handleTabChangeWithPlugins(tabs[0]);\n      } else {\n        // Process URL but don't start a session\n        const paperData = await fullyProcessUrl(details.url);\n        if (paperData) {\n          logger.info(`Processed paper data: ${paperData.title}`);\n        }\n      }\n    } catch (error) {\n      logger.error(`Error in navigation handler: ${error}`);\n    }\n  }\n\n  /**\n   * Handle tab activation events\n   * @param {chrome.tabs.TabActiveInfo} activeInfo - Tab activation info\n   * @returns {Promise<void>}\n   */\n  async handleUnifiedTabActivation(activeInfo: chrome.tabs.TabActiveInfo): Promise<void> {\n    logger.info(`Unified tab activation handler: ${activeInfo.tabId}`);\n    const tab = await chrome.tabs.get(activeInfo.tabId);\n    \n    if (!tab.url || this.pendingUrls.has(tab.url)) {\n      logger.info(`Tab URL empty or already being processed: ${tab.url}`);\n      return;\n    }\n    \n    try {\n      // Mark URL as being processed\n      this.pendingUrls.add(tab.url);\n      \n      // Delegate to the appropriate handler\n      await this.handleTabChangeWithPlugins(tab);\n    } catch (error) {\n      logger.error(`Error in tab activation handler: ${error}`);\n    } finally {\n      setTimeout(() => {\n        if (tab.url) this.pendingUrls.delete(tab.url);\n      }, 500);\n    }\n  }\n\n  /**\n   * Handle tab update events\n   * @param {number} tabId - Tab ID\n   * @param {chrome.tabs.TabChangeInfo} changeInfo - Change info\n   * @param {chrome.tabs.Tab} tab - Tab object\n   * @returns {Promise<void>}\n   */\n  async handleUnifiedTabUpdate(\n    tabId: number, \n    changeInfo: chrome.tabs.TabChangeInfo, \n    tab: chrome.tabs.Tab\n  ): Promise<void> {\n    if (changeInfo.status !== 'complete' || !tab.url || this.pendingUrls.has(tab.url)) {\n      return;\n    }\n    \n    logger.info(`Unified tab update handler: ${tab.url}`);\n    \n    try {\n      // Mark URL as being processed\n      this.pendingUrls.add(tab.url);\n      \n      // Delegate to the appropriate handler\n      await this.handleTabChangeWithPlugins(tab);\n    } catch (error) {\n      logger.error(`Error in tab update handler: ${error}`);\n    } finally {\n      setTimeout(() => {\n        if (tab.url) this.pendingUrls.delete(tab.url);\n      }, 500);\n    }\n  }\n\n  /**\n   * Handle tab changes for papers\n   * @param {chrome.tabs.Tab} tab - Tab object\n   * @returns {Promise<void>}\n   */\n  async handleTabChangeWithPlugins(tab: chrome.tabs.Tab): Promise<void> {\n    if (!tab.url) return;\n    \n    // Use enhanced detection service\n    const sourceInfo = await processTab(tab);\n    \n    if (!sourceInfo) {\n      logger.info('Not a recognized paper page, ending current session');\n      await sessionManager.endCurrentSession();\n      return;\n    }\n\n    // Process the paper URL with full metadata extraction\n    logger.info(`Processing paper URL: ${tab.url}`);\n    const paperData = await fullyProcessTab(tab);\n    \n    if (paperData) {\n      logger.info(`Starting new session for: ${paperData.primary_id}`);\n      \n      // Start a new session\n      sessionManager.startSession(paperData);\n      \n      // Create GitHub issue\n      logger.info(`Creating GitHub issue for: ${paperData.primary_id}`);\n      try {\n        await githubIntegration.createGithubIssue(paperData);\n      } catch (error) {\n        logger.error(`Error creating GitHub issue: ${error}`);\n      }\n    }\n  }\n\n  /**\n   * Process a paper URL\n   * @param {string} url - Paper URL\n   * @param {Object} options - Processing options\n   * @returns {Promise<any|null>} Paper data or null\n   */\n  async processPaperUrl(url: string, options: {tabId?: number} = {}): Promise<any | null> {\n    logger.info(`Processing paper URL: ${url}`);\n    \n    try {\n      // Use the enhanced services for full processing\n      const tabId = options.tabId || null;\n      return await fullyProcessUrl(url, tabId);\n    } catch (error) {\n      logger.error(`Error processing paper URL: ${error}`);\n      return null;\n    }\n  }\n}\n\nexport default new EventHandlers();\n","// extension/background/debug.ts - Debug utilities for service worker\n\nimport { loguru } from \"../utils/logger\";\nimport { urlDetectionService } from '../papers/detection_service';\nimport { getPluginInitializationState } from '../papers/plugins/loader';\nimport credentialManager from './credential_manager';\nimport sessionManager from './session_manager';\n\nconst logger = loguru.getLogger('Debug');\n\n// Define properly typed interfaces for debug objects\ninterface EnhancedServices {\n  urlDetectionService: typeof urlDetectionService;\n  getPluginState: typeof getPluginInitializationState;\n  handleUrl?: (url: string) => Promise<any>;\n  [key: string]: any;\n}\n\n// Don't redeclare __DEBUG__ here since it's already declared elsewhere\n// We'll use the existing declaration\n\n/**\n * Initialize debug objects in service worker scope\n * @param {Partial<EnhancedServices>} enhancedServices - Enhanced services object\n */\nexport function initializeDebugObjects(enhancedServices?: Partial<EnhancedServices>): void {\n  // Use self for service worker context\n  if (typeof self !== 'undefined') {\n    (self as any).__DEBUG__ = {\n      // Paper manager\n      get paperManager() { \n        return credentialManager.getPaperManager(); \n      },\n      \n      // GitHub client - use any to bypass type checking for this property\n      getGithubClient: (): any => {\n        return credentialManager.getPaperManager();\n      },\n      \n      // Session info\n      getCurrentPaper: () => sessionManager.getCurrentPaper(),\n      getCurrentSession: () => sessionManager.currentSession,\n      getConfig: () => sessionManager.sessionConfig,\n      \n      // Enhanced services - construct with proper defaults\n      enhancedServices: {\n        urlDetectionService,\n        getPluginState: getPluginInitializationState,\n        handleUrl: enhancedServices?.handleUrl || ((url: string) => Promise.resolve(null)),\n        ...(enhancedServices || {})\n      }\n    };\n\n    logger.info('Debug objects registered, access via __DEBUG__ in service worker console');\n  } else {\n    logger.warning('Debug objects not initialized: service worker context not detected');\n  }\n}\n\nexport default {\n  initializeDebugObjects\n};\n","// extension/background/index.ts - Main extension background service worker\n\nimport { loguru } from \"../utils/logger\";\nimport { initializePluginSystem } from '../papers/plugins/loader';\nimport { processUrl, urlDetectionService } from '../papers/detection_service';\nimport { getPluginInitializationState } from '../papers/plugins/loader';\nimport credentialManager from './credential_manager';\nimport sessionManager from './session_manager';\nimport eventHandlers from './event_handlers';\nimport messageHandlers from './message_handlers';\nimport debugModule from './debug';\n\nconst logger = loguru.getLogger('Background');\n\n/**\n * Initialize the extension\n * @returns {Promise<void>}\n */\nasync function initialize(): Promise<void> {\n  logger.info('Initializing extension');\n  \n  try {\n    // Load credentials and config\n    const { paperManager } = await credentialManager.loadCredentials();\n    logger.info('Credentials loaded:', {\n      hasPaperManager: !!paperManager\n    });\n    \n    // Load session configuration\n    const sessionConfig = await sessionManager.loadSessionConfig();\n    logger.info('Session configuration loaded');\n    \n    // Initialize plugin system with retry capability\n    logger.info('Initializing plugin system');\n    await initializePluginSystem(3);\n    logger.info('Plugin system initialized');\n    \n    // Set up event listeners\n    await eventHandlers.setupListeners();\n    \n    // Initialize debug objects (message handlers are self-initializing)\n    debugModule.initializeDebugObjects({\n      urlDetectionService,\n      getPluginState: getPluginInitializationState,\n      handleUrl: processUrl\n    });\n    \n    logger.info('Extension initialized successfully');\n  } catch (error) {\n    logger.error('Extension initialization failed:', error);\n  }\n}\n\n// Initialize extension\ninitialize();\n"],"names":["logger","GitHubStoreClient"],"mappings":"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","x_google_ignoreList":[6]}