{"version":3,"file":"background.bundle.js","sources":["../node_modules/gh-store-client/dist/index.mjs","../utils/logger.ts","../papers/plugins/registry.ts","../papers/source_utils.ts","../papers/manager.ts","../config/session.js","../utils/worker_safe_parser.ts","../utils/service_worker_parser.ts","../papers/plugins/sources/arxiv_plugin.ts","../papers/plugins/sources/semantic_scholar_plugin.ts","../papers/plugins/sources/openreview_plugin.ts","../papers/plugins/loader.ts","../papers/url_detection_service.ts","../background_integration.ts","../background.js"],"sourcesContent":["var d=class{constructor(e={}){this.cache=new Map,this.maxSize=e.maxSize??1e3,this.ttl=e.ttl??1e3*60*60,this.accessOrder=[]}get(e){let s=this.cache.get(e);if(s){if(Date.now()-s.lastAccessed>this.ttl){this.cache.delete(e),this.removeFromAccessOrder(e);return}return s.lastAccessed=Date.now(),this.updateAccessOrder(e),s.issueNumber}}set(e,s,t){if(this.cache.size>=this.maxSize&&!this.cache.has(e)){let r=this.accessOrder[this.accessOrder.length-1];r&&(this.cache.delete(r),this.removeFromAccessOrder(r))}this.cache.set(e,{issueNumber:s,lastAccessed:Date.now(),createdAt:t.createdAt,updatedAt:t.updatedAt}),this.updateAccessOrder(e)}remove(e){this.cache.delete(e),this.removeFromAccessOrder(e)}clear(){this.cache.clear(),this.accessOrder=[]}getStats(){return{size:this.cache.size,maxSize:this.maxSize,ttl:this.ttl}}shouldRefresh(e,s){let t=this.cache.get(e);return t?s>t.updatedAt:!0}updateAccessOrder(e){this.removeFromAccessOrder(e),this.accessOrder.unshift(e)}removeFromAccessOrder(e){let s=this.accessOrder.indexOf(e);s>-1&&this.accessOrder.splice(s,1)}};var l=\"0.3.2\";var f=class{constructor(e,s,t={}){this.token=e,this.repo=s,this.config={baseLabel:t.baseLabel??\"stored-object\",uidPrefix:t.uidPrefix??\"UID:\",reactions:{processed:t.reactions?.processed??\"+1\",initialState:t.reactions?.initialState??\"rocket\"}},this.cache=new d(t.cache)}async fetchFromGitHub(e,s={}){let t=new URL(`https://api.github.com/repos/${this.repo}${e}`);s.params&&(Object.entries(s.params).forEach(([i,a])=>{t.searchParams.append(i,a)}),delete s.params);let r=await fetch(t.toString(),{...s,headers:{Authorization:`token ${this.token}`,Accept:\"application/vnd.github.v3+json\",...s.headers}});if(!r.ok)throw new Error(`GitHub API error: ${r.status}`);return r.json()}createCommentPayload(e,s){let t={_data:e,_meta:{client_version:l,timestamp:new Date().toISOString(),update_mode:\"append\"}};return s&&(t.type=s),t}async getObject(e){let s=this.cache.get(e),t;if(s)try{t=await this.fetchFromGitHub(`/issues/${s}`),this._verifyIssueLabels(t,e)||(this.cache.remove(e),t=void 0)}catch{this.cache.remove(e)}if(!t){let c=await this.fetchFromGitHub(\"/issues\",{method:\"GET\",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(\",\"),state:\"closed\"}});if(!c||c.length===0)throw new Error(`No object found with ID: ${e}`);t=c[0]}if(!t?.body)throw new Error(`Invalid issue data received for ID: ${e}`);let r=JSON.parse(t.body),i=new Date(t.created_at),a=new Date(t.updated_at);return this.cache.set(e,t.number,{createdAt:i,updatedAt:a}),{meta:{objectId:e,label:`${this.config.uidPrefix}${e}`,createdAt:i,updatedAt:a,version:await this._getVersion(t.number)},data:r}}async createObject(e,s){let t=`${this.config.uidPrefix}${e}`,r=await this.fetchFromGitHub(\"/issues\",{method:\"POST\",body:JSON.stringify({title:`Stored Object: ${e}`,body:JSON.stringify(s,null,2),labels:[this.config.baseLabel,t]})});this.cache.set(e,r.number,{createdAt:new Date(r.created_at),updatedAt:new Date(r.updated_at)});let i=this.createCommentPayload(s,\"initial_state\"),a=await this.fetchFromGitHub(`/issues/${r.number}/comments`,{method:\"POST\",body:JSON.stringify({body:JSON.stringify(i,null,2)})});return await this.fetchFromGitHub(`/issues/comments/${a.id}/reactions`,{method:\"POST\",body:JSON.stringify({content:this.config.reactions.processed})}),await this.fetchFromGitHub(`/issues/comments/${a.id}/reactions`,{method:\"POST\",body:JSON.stringify({content:this.config.reactions.initialState})}),await this.fetchFromGitHub(`/issues/${r.number}`,{method:\"PATCH\",body:JSON.stringify({state:\"closed\"})}),{meta:{objectId:e,label:t,createdAt:new Date(r.created_at),updatedAt:new Date(r.updated_at),version:1},data:s}}_verifyIssueLabels(e,s){let t=new Set([this.config.baseLabel,`${this.config.uidPrefix}${s}`]);return e.labels.some(r=>t.has(r.name))}async updateObject(e,s){let t=await this.fetchFromGitHub(\"/issues\",{method:\"GET\",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(\",\"),state:\"all\"}});if(!t||t.length===0)throw new Error(`No object found with ID: ${e}`);let r=t[0],i=this.createCommentPayload(s);return await this.fetchFromGitHub(`/issues/${r.number}/comments`,{method:\"POST\",body:JSON.stringify({body:JSON.stringify(i,null,2)})}),await this.fetchFromGitHub(`/issues/${r.number}`,{method:\"PATCH\",body:JSON.stringify({state:\"open\"})}),this.getObject(e)}async listAll(){let e=await this.fetchFromGitHub(\"/issues\",{method:\"GET\",params:{labels:this.config.baseLabel,state:\"closed\"}}),s={};for(let t of e)if(!t.labels.some(r=>r.name===\"archived\"))try{let r=this._getObjectIdFromLabels(t),i=JSON.parse(t.body),a={objectId:r,label:r,createdAt:new Date(t.created_at),updatedAt:new Date(t.updated_at),version:await this._getVersion(t.number)};s[r]={meta:a,data:i}}catch{continue}return s}async listUpdatedSince(e){let s=await this.fetchFromGitHub(\"/issues\",{method:\"GET\",params:{labels:this.config.baseLabel,state:\"closed\",since:e.toISOString()}}),t={};for(let r of s)if(!r.labels.some(i=>i.name===\"archived\"))try{let i=this._getObjectIdFromLabels(r),a=JSON.parse(r.body),n=new Date(r.updated_at);if(n>e){let c={objectId:i,label:i,createdAt:new Date(r.created_at),updatedAt:n,version:await this._getVersion(r.number)};t[i]={meta:c,data:a}}}catch{continue}return t}async getObjectHistory(e){let s=await this.fetchFromGitHub(\"/issues\",{method:\"GET\",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(\",\"),state:\"all\"}});if(!s||s.length===0)throw new Error(`No object found with ID: ${e}`);let t=s[0],r=await this.fetchFromGitHub(`/issues/${t.number}/comments`),i=[];for(let a of r)try{let n=JSON.parse(a.body),c=\"update\",m,b={client_version:\"legacy\",timestamp:a.created_at,update_mode:\"append\"};typeof n==\"object\"?\"_data\"in n?(c=n.type||\"update\",m=n._data,b=n._meta||b):\"type\"in n&&n.type===\"initial_state\"?(c=\"initial_state\",m=n.data):m=n:m=n,i.push({timestamp:a.created_at,type:c,data:m,commentId:a.id})}catch{continue}return i}async _getVersion(e){return(await this.fetchFromGitHub(`/issues/${e}/comments`)).length+1}_getObjectIdFromLabels(e){for(let s of e.labels)if(s.name!==this.config.baseLabel&&s.name.startsWith(this.config.uidPrefix))return s.name.slice(this.config.uidPrefix.length);throw new Error(`No UID label found with prefix ${this.config.uidPrefix}`)}};var u={baseLabel:\"stored-object\",uidPrefix:\"UID:\",reactions:{processed:\"+1\",initialState:\"rocket\"},retries:{maxAttempts:3,backoffFactor:2},rateLimit:{maxRequestsPerHour:1e3}};function _(o){return{...u,...o,reactions:{...u.reactions,...o.reactions},retries:{...u.retries,...o.retries},rateLimit:{...u.rateLimit,...o.rateLimit}}}function v(o){return/^gh[ps]_[a-zA-Z0-9]{36}$/.test(o)}function P(o){return/^[\\w-]+\\/[\\w-]+$/.test(o)}var h=class extends Error{constructor(e){super(e),this.name=\"ConfigError\"}},g=class extends h{constructor(e=\"Invalid GitHub token format\"){super(e),this.name=\"TokenError\"}},p=class extends h{constructor(e=\"Invalid repository format. Use owner/repo\"){super(e),this.name=\"RepoError\"}};export{h as ConfigError,u as DEFAULT_CONFIG,f as GitHubStoreClient,p as RepoError,g as TokenError,_ as mergeConfig,P as validateRepo,v as validateToken};\n//# sourceMappingURL=index.mjs.map","// extension/utils/logger.ts\n\n/**\n * Simple logger utility inspired by loguru\n */\nclass Logger {\n  private name: string;\n  \n  constructor(name: string) {\n    this.name = name;\n  }\n  \n  info(message: string, ...args: any[]): void {\n    console.log(`[INFO] ${this.name}: ${message}`, ...args);\n  }\n  \n  warning(message: string, ...args: any[]): void {\n    console.warn(`[WARNING] ${this.name}: ${message}`, ...args);\n  }\n  \n  error(message: string, ...args: any[]): void {\n    console.error(`[ERROR] ${this.name}: ${message}`, ...args);\n  }\n  \n  debug(message: string, ...args: any[]): void {\n    console.debug(`[DEBUG] ${this.name}: ${message}`, ...args);\n  }\n}\n\nexport const loguru = {\n  getLogger: (name: string) => new Logger(name)\n};\n","// extension/papers/plugins/registry.ts - Enhanced registry logging\n\nimport { SourcePlugin } from './source_plugin';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('PluginRegistry');\nconst debugLogger = loguru.getLogger('PluginRegistryDebug');\n\nclass PluginRegistry {\n  private plugins: Map<string, SourcePlugin> = new Map();\n  \n  register(plugin: SourcePlugin): void {\n    debugLogger.info(`Registering plugin: ${plugin.id} (${plugin.name})`);\n    \n    // Validate plugin has required fields\n    if (!plugin.id || typeof plugin.id !== 'string') {\n      debugLogger.error(`Plugin missing valid id: ${JSON.stringify(plugin)}`);\n      return;\n    }\n    \n    if (!Array.isArray(plugin.urlPatterns) || plugin.urlPatterns.length === 0) {\n      debugLogger.warning(`Plugin ${plugin.id} has no URL patterns`);\n    }\n    \n    if (!plugin.extractId || typeof plugin.extractId !== 'function') {\n      debugLogger.error(`Plugin ${plugin.id} missing required extractId method`);\n      return;\n    }\n    \n    if (this.plugins.has(plugin.id)) {\n      debugLogger.warning(`Plugin with ID ${plugin.id} already registered, overwriting`);\n      logger.warning(`Plugin with ID ${plugin.id} already registered, overwriting`);\n    }\n    \n    this.plugins.set(plugin.id, plugin);\n    debugLogger.info(`Successfully registered plugin: ${plugin.name} (${plugin.id})`);\n    debugLogger.info(`Plugin capabilities: hasApi=${!!plugin.hasApi}, formatId=${!!plugin.formatId}`);\n    logger.info(`Registered plugin: ${plugin.name} (${plugin.id})`);\n  }\n  \n  getAll(): SourcePlugin[] {\n    debugLogger.info(`Getting all plugins, currently ${this.plugins.size} registered`);\n    return Array.from(this.plugins.values());\n  }\n  \n  get(id: string): SourcePlugin | undefined {\n    debugLogger.info(`Looking up plugin by id: ${id}`);\n    const plugin = this.plugins.get(id);\n    if (!plugin) {\n      debugLogger.warning(`No plugin found with id: ${id}`);\n    } else {\n      debugLogger.info(`Found plugin: ${plugin.name} (${plugin.id})`);\n    }\n    return plugin;\n  }\n  \n  findForUrl(url: string): { plugin: SourcePlugin; id: string } | null {\n    debugLogger.info(`Finding plugin for URL: ${url}`);\n    \n    for (const plugin of this.plugins.values()) {\n      debugLogger.info(`Testing URL against plugin: ${plugin.id}`);\n      \n      for (const pattern of plugin.urlPatterns) {\n        debugLogger.info(`Testing pattern: ${pattern.toString()}`);\n        \n        if (pattern.test(url)) {\n          debugLogger.info(`URL matches pattern for plugin: ${plugin.id}`);\n          \n          const id = plugin.extractId(url);\n          if (id) {\n            debugLogger.info(`Successfully extracted ID: ${id}`);\n            return { plugin, id };\n          } else {\n            debugLogger.warning(`Pattern matched but failed to extract ID`);\n          }\n        }\n      }\n    }\n    \n    debugLogger.warning(`No plugin found for URL: ${url}`);\n    return null;\n  }\n}\n\n// Export singleton instance\nexport const pluginRegistry = new PluginRegistry();\ndebugLogger.info('PluginRegistry singleton instance created');\n","// extension/papers/source_utils.ts\n// Fixed to export isNewFormat function\n\nimport { pluginRegistry } from './plugins/registry';\nimport { loguru } from '../utils/logger';\n\nconst logger = loguru.getLogger('SourceUtils');\n\n/**\n * Format a source-specific ID into a universal primary ID format\n * Uses source-specific formatId from plugin if available\n * \n * @param {string} source - Source type (e.g. 'arxiv', 'doi')\n * @param {string} id - Original source-specific identifier\n * @returns {string} Formatted primary ID\n */\nexport function formatPrimaryId(source: string, id: string): string {\n  // First check if we have a plugin for this source\n  const plugin = pluginRegistry.get(source);\n  \n  // Use plugin's formatId method if available\n  if (plugin && plugin.formatId) {\n    return plugin.formatId(id);\n  }\n  \n  // Sanitize the ID by replacing problematic characters\n  const safeId = id\n    .replace(/\\//g, '_')\n    .replace(/:/g, '.')\n    .replace(/\\s/g, '_')\n    .replace(/\\\\/g, '_');\n  \n  return `${source}.${safeId}`;\n}\n\n/**\n * Parse a primary ID into its source type and original source ID\n * \n * @param {string} prefixedId - The primary ID in the format \"{source_prefix}.{id}\"\n * @returns {Object} Object with source type and source ID\n */\nexport function parseId(prefixedId: string): { type: string; id: string } {\n  // Split at the first dot\n  const [prefix, ...idParts] = prefixedId.split('.');\n  const id = idParts.join('.'); // Rejoin in case ID contains periods\n  \n  // Map prefix to source type by looking up plugins\n  const plugins = pluginRegistry.getAll();\n  for (const plugin of plugins) {\n    // Check if the plugin's ID format matches the prefix\n    if (plugin.formatId) {\n      const sampleId = plugin.formatId('test');\n      const samplePrefix = sampleId.split('.')[0];\n      if (samplePrefix === prefix) {\n        return {\n          type: plugin.id,\n          id: id\n        };\n      }\n    }\n  }\n  \n  // Assume the prefix is the source type\n  return {\n    type: prefix,\n    id: prefix === 'doi' ? id.replace(/_/g, '/') : id\n  };\n}\n\n/**\n * Checks if a string is in the required prefixed format\n * @param {string} id - ID to check\n * @returns {boolean} True if the ID is in the correct format\n */\nexport function isNewFormat(id: string): boolean {\n  if (!id) return false;\n  \n  // Check if it contains a dot, which separates the source from the ID\n  return id.includes('.');\n}\n\n/**\n * Gets a display label for a source type using the plugin if available\n * \n * @param {string} sourceType - Source type\n * @returns {string} Human-readable label\n */\nexport function getSourceLabel(sourceType: string): string {\n  const plugin = pluginRegistry.get(sourceType);\n  if (plugin) {\n    return plugin.name;\n  }\n  \n  return sourceType.charAt(0).toUpperCase() + sourceType.slice(1);\n}\n\n/**\n * Get canonical URL for a paper using the plugin if available\n * \n * @param {string} sourceType - Source type\n * @param {string} id - Source ID\n * @returns {string} Canonical URL\n */\nexport function getCanonicalUrl(sourceType: string, id: string): string {\n  // First check if a plugin is available for this source\n  const plugin = pluginRegistry.get(sourceType);\n  if (plugin) {\n    // If the plugin has any URL patterns, try to construct a URL\n    if (plugin.urlPatterns && plugin.urlPatterns.length > 0) {\n      const pattern = plugin.urlPatterns[0].toString();\n      // Extract the domain and path pattern\n      const match = pattern.match(/([^/]+)(\\/[^)]+)/);\n      if (match) {\n        const domain = match[1].replace(/\\\\\\./, '.');\n        const path = match[2]\n          .replace(/\\\\\\//g, '/')\n          .replace(/\\([^)]+\\)/, id);\n        return `https://${domain}${path}`;\n      }\n    }\n  }\n  \n  switch (sourceType) {\n    case 'arxiv':\n      return `https://arxiv.org/abs/${id}`;\n    case 'semanticscholar':\n      return `https://www.semanticscholar.org/paper/${id}`;\n    case 'doi':\n      return `https://doi.org/${id}`;\n    case 'acm':\n      return `https://dl.acm.org/doi/${id}`;\n    case 'openreview':\n      return `https://openreview.net/forum?id=${id}`;\n    default:\n      return id.startsWith('10.') ? `https://doi.org/${id}` : \"\";\n  }\n}\n","// extension/papers/manager.ts\n// Refactored to remove legacy ID handling\n\nimport { GitHubStoreClient } from 'gh-store-client';\nimport type { Json } from 'gh-store-client';\nimport { \n  type PaperMetadata, \n  type InteractionLog, \n  type Interaction,\n  type ReadingSessionData\n} from './types';\nimport { formatPrimaryId } from './source_utils';\nimport { loguru } from '../utils/logger';\n\nconst logger = loguru.getLogger('PaperManager');\n\n/**\n * Checks if data is an interaction log\n */\nfunction isInteractionLog(data: any): data is InteractionLog {\n  return typeof data === \"object\" && \n         data !== null && \n         typeof data.paper_id === \"string\" && \n         Array.isArray(data.interactions);\n}\n\nexport class PaperManager {\n  private client: GitHubStoreClient;\n  // Concurrency control locks\n  private creationLocks = new Map<string, Promise<any>>();\n  \n  constructor(client: GitHubStoreClient) {\n    this.client = client;\n  }\n\n  /**\n   * Get or create a paper record\n   */\n  async getOrCreatePaper(paperData: any): Promise<any> {\n    // Ensure paperData has a primary_id\n    if (!paperData.primary_id) {\n      if (paperData.source && paperData.sourceId) {\n        paperData.primary_id = formatPrimaryId(paperData.source, paperData.sourceId);\n      } else {\n        throw new Error(\"Invalid paper data: missing primary_id and cannot generate it\");\n      }\n    }\n    \n    const objectId = `paper:${paperData.primary_id}`;\n    logger.info(`Getting or creating paper: ${objectId}`);\n    \n    try {\n      // Try to get the paper\n      const obj = await this.client.getObject(objectId);\n      const data = obj.data as Record<string, any>;\n      \n      logger.info(`Found existing paper: ${objectId}`);\n      return data;\n    } catch (error) {\n      if (error instanceof Error && error.message.includes(\"No object found\")) {\n        // Create new paper with appropriate fields\n        const defaultPaperData: Record<string, any> = {\n          primary_id: paperData.primary_id,\n          source: paperData.source,\n          sourceId: paperData.sourceId,\n          url: paperData.url || '',\n          title: paperData.title || paperData.sourceId,\n          authors: paperData.authors || '',\n          abstract: paperData.abstract || '',\n          timestamp: new Date().toISOString(),\n          rating: 'novote'\n        };\n        \n        // Add source-specific data directly\n        if (paperData.source_specific_metadata) {\n          defaultPaperData.source_specific_metadata = paperData.source_specific_metadata;\n        }\n        \n        // Always add identifiers object\n        defaultPaperData.identifiers = {\n          original: paperData.sourceId,\n          url: paperData.url\n        };\n        \n        // Add cross-references if available\n        if (paperData.doi) {\n          defaultPaperData.identifiers.doi = paperData.doi;\n        }\n        \n        logger.info(`Creating new paper object: ${objectId}`);\n        try {\n          await this.client.createObject(objectId, defaultPaperData);\n          logger.info(`Successfully created paper: ${objectId}`);\n          return defaultPaperData;\n        } catch (createError) {\n          logger.error(`Error creating paper object: ${createError}`);\n          throw createError;\n        }\n      }\n      logger.error(`Error in getOrCreatePaper: ${error}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Get or create an interaction log\n   */\n  private async getOrCreateInteractionLog(paperId: string): Promise<InteractionLog> {\n    const objectId = `interactions:${paperId}`;\n    \n    // Check if we're already creating this log\n    if (this.creationLocks.has(objectId)) {\n      logger.info(`Waiting for existing creation of interaction log: ${objectId}`);\n      return this.creationLocks.get(objectId) as Promise<InteractionLog>;\n    }\n    \n    // Create a new promise for this operation\n    const creationPromise = (async () => {\n      try {\n        const obj = await this.client.getObject(objectId);\n        const data = obj.data;\n        \n        if (isInteractionLog(data)) {\n          return data;\n        }\n        \n        throw new Error('Invalid interaction log format');\n      } catch (error) {\n        if (error instanceof Error && error.message.includes('No object found')) {\n          // Create new log\n          const newLog: InteractionLog = {\n            paper_id: paperId,\n            interactions: []\n          };\n          \n          logger.info(`Creating new interaction log: ${objectId}`);\n          await this.client.createObject(objectId, newLog);\n          return newLog;\n        }\n        throw error;\n      } finally {\n        // Release the lock after a delay\n        setTimeout(() => {\n          this.creationLocks.delete(objectId);\n        }, 500);\n      }\n    })();\n    \n    // Store the promise\n    this.creationLocks.set(objectId, creationPromise);\n    \n    return creationPromise;\n  }\n\n  /**\n   * Log a reading session for a paper\n   */\n  async logReadingSession(\n    paperId: string,\n    session: ReadingSessionData,\n    paperData?: any\n  ): Promise<void> {\n    // Ensure paper exists with proper data\n    if (paperData) {\n      if (!paperData.primary_id) {\n        paperData.primary_id = paperId;\n      }\n      await this.getOrCreatePaper(paperData);\n    }\n\n    // Log the session as interaction\n    await this.addInteraction(paperId, {\n      type: \"reading_session\",\n      timestamp: new Date().toISOString(),\n      data: session\n    });\n  }\n\n  /**\n   * Log an annotation for a paper\n   */\n  async logAnnotation(\n    paperId: string,\n    key: string,\n    value: Json,\n    paperData?: any\n  ): Promise<void> {\n    // Ensure paper exists with proper data\n    if (paperData) {\n      if (!paperData.primary_id) {\n        paperData.primary_id = paperId;\n      }\n      await this.getOrCreatePaper(paperData);\n    }\n\n    // Log the annotation as interaction\n    await this.addInteraction(paperId, {\n      type: \"annotation\",\n      timestamp: new Date().toISOString(),\n      data: { key, value }\n    });\n  }\n\n  /**\n   * Update a paper's rating\n   */\n  async updateRating(\n    paperId: string,\n    rating: string,\n    paperData?: any\n  ): Promise<void> {\n    // Get existing paper data\n    const paper = await this.getOrCreatePaper(paperData || { primary_id: paperId });\n\n    // Update rating\n    const objectId = `paper:${paperId}`;\n    await this.client.updateObject(objectId, { \n      ...paper,\n      rating \n    });\n\n    // Log rating change\n    await this.addInteraction(paperId, {\n      type: \"rating\",\n      timestamp: new Date().toISOString(),\n      data: { rating }\n    });\n  }\n\n  /**\n   * Add an interaction to a paper's log\n   */\n  private async addInteraction(paperId: string, interaction: Interaction): Promise<void> {\n    const log = await this.getOrCreateInteractionLog(paperId);\n    log.interactions.push(interaction);\n    \n    // Store with the standard format ID\n    const objectId = `interactions:${paperId}`;\n    await this.client.updateObject(objectId, log);\n  }\n\n  /**\n   * Get interactions for a paper\n   */\n  async getInteractions(\n    paperId: string,\n    options: {\n      type?: string;\n      startTime?: Date;\n      endTime?: Date;\n    } = {}\n  ): Promise<Interaction[]> {\n    try {\n      const log = await this.getOrCreateInteractionLog(paperId);\n      let interactions = log.interactions;\n\n      if (options.type) {\n        interactions = interactions.filter((i: Interaction) => i.type === options.type);\n      }\n\n      if (options.startTime || options.endTime) {\n        interactions = interactions.filter((i: Interaction) => {\n          const time = new Date(i.timestamp);\n          if (options.startTime && time < options.startTime) return false;\n          if (options.endTime && time > options.endTime) return false;\n          return true;\n        });\n      }\n\n      return interactions;\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('No object found')) {\n        return [];\n      }\n      throw error;\n    }\n  }\n  \n  /**\n   * Get total reading time for a paper\n   */\n  async getPaperReadingTime(paperId: string): Promise<number> {\n    const interactions = await this.getInteractions(paperId, { type: 'reading_session' });\n    return interactions.reduce((total, i) => {\n      const data = i.data;\n      if (typeof data === 'object' && data !== null && 'duration_seconds' in data) {\n        return total + (data.duration_seconds as number);\n      }\n      return total;\n    }, 0);\n  }\n\n  /**\n   * Get paper history\n   */\n  async getPaperHistory(paperId: string): Promise<Json[]> {\n    const objectId = `paper:${paperId}`;\n    return this.client.getObjectHistory(objectId);\n  }\n}\n","// extension/config/session.js\n\n// Default configuration values\nconst DEFAULT_CONFIG = {\n    idleThresholdMinutes: 5,\n    minSessionDurationSeconds: 30,\n    // Adding more granular control\n    requireContinuousActivity: true,  // If true, resets timer on idle\n    logPartialSessions: false,        // If true, logs sessions even if under minimum duration\n    activityUpdateIntervalSeconds: 1  // How often to update active time\n};\n\n// Load session configuration from storage\nasync function loadSessionConfig() {\n    const items = await chrome.storage.sync.get('sessionConfig');\n    return { ...DEFAULT_CONFIG, ...items.sessionConfig };\n}\n\n// Save session configuration to storage\nasync function saveSessionConfig(config) {\n    await chrome.storage.sync.set({\n        sessionConfig: {\n            idleThresholdMinutes: Number(config.idleThresholdMinutes),\n            minSessionDurationSeconds: Number(config.minSessionDurationSeconds),\n            requireContinuousActivity: Boolean(config.requireContinuousActivity),\n            logPartialSessions: Boolean(config.logPartialSessions),\n            activityUpdateIntervalSeconds: Number(config.activityUpdateIntervalSeconds)\n        }\n    });\n}\n\n// Convert configuration to milliseconds for internal use\nfunction getConfigurationInMs(config) {\n    return {\n        idleThreshold: config.idleThresholdMinutes * 60 * 1000,\n        minSessionDuration: config.minSessionDurationSeconds * 1000,\n        activityUpdateInterval: config.activityUpdateIntervalSeconds * 1000,\n        requireContinuousActivity: config.requireContinuousActivity,\n        logPartialSessions: config.logPartialSessions\n    };\n}\n\nexport { loadSessionConfig, saveSessionConfig, getConfigurationInMs, DEFAULT_CONFIG };","// extension/utils/worker_safe_parser.ts\n\n/**\n * Simple XML parser that works in service worker environment\n */\nexport function parseXML(xmlText: string) {\n  return {\n    getTagContent(tag: string, content?: string): string {\n      const searchText = content || xmlText;\n      const regex = new RegExp(`<${tag}[^>]*>(.*?)</${tag}>`, 's');\n      const match = searchText.match(regex);\n      return match ? match[1].trim() : '';\n    },\n    \n    getAll(tag: string): string[] {\n      const result: string[] = [];\n      const regex = new RegExp(`<${tag}[^>]*>(.*?)</${tag}>`, 'gs');\n      let match;\n      while ((match = regex.exec(xmlText)) !== null) {\n        result.push(match[1].trim());\n      }\n      return result;\n    },\n    \n    getAttribute(tag: string, attr: string): string[] {\n      const result: string[] = [];\n      const regex = new RegExp(`<${tag}[^>]*${attr}=\"([^\"]+)\"`, 'g');\n      let match;\n      while ((match = regex.exec(xmlText)) !== null) {\n        result.push(match[1]);\n      }\n      return result;\n    },\n    \n    getEntry(text?: string): string {\n      const searchText = text || xmlText;\n      const entryRegex = /<entry>([\\s\\S]*?)<\\/entry>/;\n      const entryMatch = searchText.match(entryRegex);\n      return entryMatch ? entryMatch[1] : '';\n    },\n    \n    getAuthor(text?: string): string[] {\n      const searchText = text || xmlText;\n      const authors = [];\n      const regex = /<author>[^]*?<name>([^]*?)<\\/name>[^]*?<\\/author>/g;\n      let match;\n      while (match = regex.exec(searchText)) {\n        authors.push(match[1].trim());\n      }\n      return authors;\n    },\n    \n    getCategories(text?: string): string[] {\n      const searchText = text || xmlText;\n      const categories = new Set();\n      \n      const primaryMatch = searchText.match(/<arxiv:primary_category[^>]*term=\"([^\"]+)\"/);\n      if (primaryMatch) {\n        categories.add(primaryMatch[1]);\n      }\n      \n      const categoryRegex = /<category[^>]*term=\"([^\"]+)\"/g;\n      let match;\n      while (match = categoryRegex.exec(searchText)) {\n        categories.add(match[1]);\n      }\n      \n      return Array.from(categories) as string[];\n    },\n    \n    getPublishedDate(text?: string): string {\n      const searchText = text || xmlText;\n      const match = searchText.match(/<published>([^<]+)<\\/published>/);\n      return match ? match[1].trim() : '';\n    }\n  };\n}\n","// extension/utils/service_worker_parser.ts\n// A DOM parser that works in service worker contexts\n\nimport { loguru } from './logger';\n\nconst logger = loguru.getLogger('ServiceWorkerParser');\n\n// Define types for our lightweight DOM elements\ninterface LightDOMElement {\n  textContent?: string;\n  content?: string;\n  innerHTML?: string;\n  getAttribute: (attr: string) => string | null;\n}\n\n/**\n * Create a simplified document-like object from HTML string for plugins to use\n * This is a workaround for service workers that don't have access to the DOM\n * \n * @param htmlString The HTML string to parse\n * @returns A document-like object with simplified query methods\n */\nexport function createServiceWorkerDOM(htmlString: string): any {\n  const dom = {\n    _html: htmlString,\n    \n    // Simplified querySelector that uses regex\n    querySelector(selector: string): LightDOMElement | null {\n      try {\n        // Very basic selector support - optimize for common cases\n        \n        // Handle ID selectors\n        if (selector.startsWith('#')) {\n          const idName = selector.substring(1);\n          const match = new RegExp(`id=[\"']${idName}[\"'][^>]*>(.*?)<`, 'is').exec(htmlString);\n          if (match) {\n            return {\n              textContent: match[1].replace(/<[^>]*>/g, ''),\n              getAttribute: (attr: string) => {\n                const attrMatch = new RegExp(`id=[\"']${idName}[\"'][^>]*${attr}=[\"']([^\"']*)[\"']`, 'i').exec(htmlString);\n                return attrMatch ? attrMatch[1] : null;\n              }\n            };\n          }\n        }\n        \n        // Handle class selectors\n        if (selector.startsWith('.')) {\n          const className = selector.substring(1);\n          const match = new RegExp(`class=[\"'][^\"']*${className}[^\"']*[\"'][^>]*>(.*?)<`, 'is').exec(htmlString);\n          if (match) {\n            return {\n              textContent: match[1].replace(/<[^>]*>/g, ''),\n              getAttribute: (attr: string) => {\n                const attrMatch = new RegExp(`class=[\"'][^\"']*${className}[^\"']*[\"'][^>]*${attr}=[\"']([^\"']*)[\"']`, 'i').exec(htmlString);\n                return attrMatch ? attrMatch[1] : null;\n              }\n            };\n          }\n        }\n        \n        // Handle meta tags (common in paper metadata)\n        if (selector.includes('meta[')) {\n          const nameMatch = /meta\\[name=[\"']([^\"']*)[\"']\\]/.exec(selector);\n          if (nameMatch) {\n            const metaName = nameMatch[1];\n            const match = new RegExp(`<meta[^>]*name=[\"']${metaName}[\"'][^>]*content=[\"']([^\"']*)[\"'][^>]*>`, 'i').exec(htmlString);\n            if (match) {\n              return {\n                content: match[1],\n                getAttribute: (_attr: string) => null\n              };\n            }\n          }\n          \n          const propertyMatch = /meta\\[property=[\"']([^\"']*)[\"']\\]/.exec(selector);\n          if (propertyMatch) {\n            const propName = propertyMatch[1];\n            const match = new RegExp(`<meta[^>]*property=[\"']${propName}[\"'][^>]*content=[\"']([^\"']*)[\"'][^>]*>`, 'i').exec(htmlString);\n            if (match) {\n              return {\n                content: match[1],\n                getAttribute: (_attr: string) => null\n              };\n            }\n          }\n        }\n        \n        // Handle tag selectors\n        const tagMatch = /^([a-zA-Z0-9]+)/.exec(selector);\n        if (tagMatch) {\n          const tagName = tagMatch[1].toLowerCase();\n          const match = new RegExp(`<${tagName}[^>]*>(.*?)</${tagName}>`, 'is').exec(htmlString);\n          if (match) {\n            return {\n              textContent: match[1].replace(/<[^>]*>/g, ''),\n              getAttribute: (attr: string) => {\n                const attrMatch = new RegExp(`<${tagName}[^>]*${attr}=[\"']([^\"']*)[\"'][^>]*>`, 'i').exec(htmlString);\n                return attrMatch ? attrMatch[1] : null;\n              }\n            };\n          }\n        }\n        \n        // Default to null if not found\n        return null;\n      } catch (error) {\n        logger.error(`Error in service worker DOM querySelector: ${error}`);\n        return null;\n      }\n    },\n    \n    // Simplified querySelectorAll that uses regex\n    querySelectorAll(selector: string): LightDOMElement[] {\n      try {\n        const results: LightDOMElement[] = [];\n        \n        // Handle class selectors\n        if (selector.startsWith('.')) {\n          const className = selector.substring(1);\n          const regex = new RegExp(`class=[\"'][^\"']*${className}[^\"']*[\"'][^>]*>(.*?)<`, 'gis');\n          let match: RegExpExecArray | null;\n          while ((match = regex.exec(htmlString)) !== null) {\n            const capturedText = match[0];\n            results.push({\n              textContent: match[1].replace(/<[^>]*>/g, ''),\n              getAttribute: (attr: string) => {\n                const attrMatch = new RegExp(`class=[\"'][^\"']*${className}[^\"']*[\"'][^>]*${attr}=[\"']([^\"']*)[\"']`, 'i').exec(capturedText);\n                return attrMatch ? attrMatch[1] : null;\n              }\n            });\n          }\n          return results;\n        }\n        \n        // Handle meta tag selectors\n        if (selector.includes('meta[')) {\n          const nameMatch = /meta\\[name=[\"']([^\"']*)[\"']\\]/.exec(selector);\n          if (nameMatch) {\n            const metaName = nameMatch[1];\n            const regex = new RegExp(`<meta[^>]*name=[\"']${metaName}[\"'][^>]*content=[\"']([^\"']*)[\"'][^>]*>`, 'gi');\n            let match: RegExpExecArray | null;\n            while ((match = regex.exec(htmlString)) !== null) {\n              results.push({\n                content: match[1],\n                getAttribute: (_attr: string) => null\n              });\n            }\n            return results;\n          }\n        }\n        \n        // Handle tag selectors\n        const tagMatch = /^([a-zA-Z0-9]+)/.exec(selector);\n        if (tagMatch) {\n          const tagName = tagMatch[1].toLowerCase();\n          const regex = new RegExp(`<${tagName}[^>]*>(.*?)</${tagName}>`, 'gis');\n          let match: RegExpExecArray | null;\n          while ((match = regex.exec(htmlString)) !== null) {\n            const capturedText = match[0];\n            results.push({\n              textContent: match[1].replace(/<[^>]*>/g, ''),\n              innerHTML: match[1],\n              getAttribute: (attr: string) => {\n                const attrMatch = new RegExp(`<${tagName}[^>]*${attr}=[\"']([^\"']*)[\"'][^>]*>`, 'i').exec(capturedText);\n                return attrMatch ? attrMatch[1] : null;\n              }\n            });\n          }\n          return results;\n        }\n        \n        return results;\n      } catch (error) {\n        logger.error(`Error in service worker DOM querySelectorAll: ${error}`);\n        return [];\n      }\n    },\n    \n    // For convenience\n    getElementById(id: string): LightDOMElement | null {\n      return this.querySelector(`#${id}`);\n    },\n    \n    getElementsByClassName(className: string): LightDOMElement[] {\n      return this.querySelectorAll(`.${className}`);\n    },\n    \n    getElementsByTagName(tagName: string): LightDOMElement[] {\n      return this.querySelectorAll(tagName);\n    }\n  };\n  \n  return dom;\n}\n\n/**\n * Extract common metadata for papers from HTML\n * This is specialized for academic paper pages\n * \n * @param htmlString HTML source of the page\n * @returns Paper metadata object\n */\nexport function extractPaperMetadata(htmlString: string): Record<string, any> {\n  const dom = createServiceWorkerDOM(htmlString);\n  const metadata: Record<string, any> = {};\n  \n  try {\n    // Helper to get meta content\n    const getMetaContent = (name: string): string | undefined => {\n      const element = dom.querySelector(`meta[name=\"${name}\"]`) || \n                     dom.querySelector(`meta[property=\"${name}\"]`);\n      return element ? element.content : undefined;\n    };\n    \n    // Extract common paper metadata\n    metadata.title = getMetaContent('citation_title') || \n                    getMetaContent('og:title') || \n                    dom.querySelector('h1')?.textContent;\n    \n    metadata.authors = getMetaContent('citation_author') || \n                      getMetaContent('citation_authors') || \n                      getMetaContent('author');\n    \n    metadata.abstract = getMetaContent('description') || \n                       getMetaContent('og:description') || \n                       getMetaContent('citation_abstract');\n    \n    metadata.doi = getMetaContent('citation_doi');\n    \n    metadata.published_date = getMetaContent('citation_publication_date') ||\n                             getMetaContent('citation_date');\n    \n    metadata.url = getMetaContent('og:url');\n  } catch (error) {\n    logger.error(`Error extracting paper metadata: ${error}`);\n  }\n  \n  return metadata;\n}\n\n/**\n * A simple XML parser that works in service worker context\n * Replicates some of the DOM API for XML files\n */\nexport function parseXMLInServiceWorker(xmlText: string) {\n  return {\n    getTagContent(tag: string, content?: string): string {\n      const searchText = content || xmlText;\n      const regex = new RegExp(`<${tag}[^>]*>(.*?)</${tag}>`, 's');\n      const match = searchText.match(regex);\n      return match ? match[1].trim() : '';\n    },\n    \n    getAll(tag: string): string[] {\n      const result: string[] = [];\n      const regex = new RegExp(`<${tag}[^>]*>(.*?)</${tag}>`, 'gs');\n      let match;\n      while ((match = regex.exec(xmlText)) !== null) {\n        result.push(match[1].trim());\n      }\n      return result;\n    },\n    \n    getAttribute(tag: string, attr: string): string[] {\n      const result: string[] = [];\n      const regex = new RegExp(`<${tag}[^>]*${attr}=[\"']([^\"']+)[\"']`, 'g');\n      let match;\n      while ((match = regex.exec(xmlText)) !== null) {\n        result.push(match[1]);\n      }\n      return result;\n    }\n  };\n}\n","// extension/papers/plugins/sources/arxiv_plugin.ts\n\nimport { SourcePlugin } from '../source_plugin';\nimport { UnifiedPaperData } from '../../types';\nimport { loguru } from '../../../utils/logger';\nimport { parseXML } from '../../../utils/worker_safe_parser';\nimport { pluginRegistry } from '../registry';\nimport { createServiceWorkerDOM } from '../../../utils/service_worker_parser';\n\nconst logger = loguru.getLogger('ArXivPlugin');\n\nexport const arxivPlugin: SourcePlugin = {\n  id: 'arxiv',\n  name: 'arXiv',\n  description: 'Support for arXiv papers',\n  version: '1.0.0',\n  \n  urlPatterns: [\n    /arxiv\\.org\\/abs\\/([0-9.]+)(v[0-9]+)?/,\n    /arxiv\\.org\\/pdf\\/([0-9.]+)(v[0-9]+)?\\.pdf/,\n    /arxiv\\.org\\/[a-z]+\\/([0-9.]+)(v[0-9]+)?/\n  ],\n  \n  extractId(url: string): string | null {\n    for (const pattern of this.urlPatterns) {\n      const match = url.match(pattern);\n      if (match) {\n        // Include version if available\n        return match[1] + (match[2] || '');\n      }\n    }\n    return null;\n  },\n  \n  async extractMetadata(document: any, url: string): Promise<Partial<UnifiedPaperData>> {\n    logger.info(`Extracting metadata from ${url}`);\n    \n    try {\n      // Check if we're in a service worker context (document is not a real DOM)\n      const isServiceWorker = typeof document !== 'object' || \n                             !document.querySelector || \n                             typeof document.querySelector !== 'function';\n      \n      if (isServiceWorker) {\n        // Use our service worker DOM utility instead of bespoke string processing\n        logger.info('Service worker context detected, using service worker DOM parser');\n        const htmlContent = typeof document === 'string' \n          ? document \n          : (document.innerHTML || document.outerHTML || '');\n        \n        // Create a lightweight DOM-like object we can query\n        const swDOM = createServiceWorkerDOM(htmlContent);\n        \n        // Now we can use querySelector-like methods\n        let title = swDOM.querySelector('.title')?.textContent?.trim();\n        if (title?.startsWith('Title:')) {\n          title = title.substring(6).trim();\n        }\n        \n        // Extract authors - properly type the elements from service worker DOM\n        let authors = '';\n        const authorElements = swDOM.querySelectorAll('.authors a');\n        if (authorElements.length > 0) {\n          // Convert to string array with proper typing\n          const authorTexts: string[] = [];\n          authorElements.forEach((el: any) => {\n            const text = el.textContent?.trim();\n            if (text) authorTexts.push(text);\n          });\n          authors = authorTexts.join(', ');\n        }\n        \n        // Extract abstract\n        let abstract = swDOM.querySelector('.abstract')?.textContent?.trim();\n        if (abstract?.startsWith('Abstract:')) {\n          abstract = abstract.substring(9).trim();\n        }\n        \n        // Extract categories\n        const categories: string[] = [];\n        const categoryElements = swDOM.querySelectorAll('.subjects .tag');\n        categoryElements.forEach((el: any) => {\n          const text = el.textContent?.trim();\n          if (text) categories.push(text);\n        });\n        \n        return {\n          title: title || '',\n          authors: authors || '',\n          abstract: abstract || '',\n          source_specific_metadata: {\n            arxiv_tags: categories,\n            published_date: '' // Will be filled by API if available\n          }\n        };\n      }\n      \n      // Browser context - use real DOM methods\n      const getMetaContent = (selector: string): string | undefined => {\n        const element = document.querySelector(selector);\n        return element && 'content' in element ? \n          (element as HTMLMetaElement).content : undefined;\n      };\n      \n      // Try to extract title and authors\n      let title = document.querySelector('.title')?.textContent?.trim();\n      if (title?.startsWith('Title:')) {\n        title = title.substring(6).trim();\n      }\n      \n      // Extract authors using forEach instead of map to avoid type issues\n      let authors = '';\n      const authorElements = document.querySelectorAll('.authors a');\n      if (authorElements.length > 0) {\n        const authorTexts: string[] = [];\n        authorElements.forEach((el: Element) => {\n          const text = el.textContent?.trim();\n          if (text) authorTexts.push(text);\n        });\n        authors = authorTexts.join(', ');\n      }\n      \n      // Extract abstract\n      let abstract = document.querySelector('.abstract')?.textContent?.trim();\n      if (abstract?.startsWith('Abstract:')) {\n        abstract = abstract.substring(9).trim();\n      }\n      \n      // Extract categories\n      const categories: string[] = [];\n      const categoryElements = document.querySelectorAll('.subjects .tag');\n      categoryElements.forEach((el: Element) => {\n        const text = el.textContent?.trim();\n        if (text) categories.push(text);\n      });\n      \n      return {\n        title: title || '',\n        authors: authors || '',\n        abstract: abstract || '',\n        source_specific_metadata: {\n          arxiv_tags: categories,\n          published_date: '' // Will be filled by API if available\n        }\n      };\n    } catch (error) {\n      logger.error('Error extracting metadata from arXiv page', error);\n      return {};\n    }\n  },\n  \n  hasApi: true,\n  \n  async fetchApiData(id: string): Promise<Partial<UnifiedPaperData>> {\n    logger.info(`Fetching API data for arXiv:${id}`);\n    \n    try {\n      const apiUrl = `https://export.arxiv.org/api/query?id_list=${id}`;\n      \n      // Use self.fetch (available in service worker) instead of window.fetch\n      const response = await self.fetch(apiUrl);\n      \n      if (!response.ok) {\n        throw new Error(`API error: ${response.status}`);\n      }\n      \n      const text = await response.text();\n      \n      // Use the worker-safe XML parser\n      const parser = parseXML(text);\n      \n      // Extract entry data\n      const entryContent = parser.getEntry();\n      \n      // Extract title\n      const title = parser.getTagContent('title');\n      \n      // Extract authors using the author parser\n      const authorsList = parser.getAuthor();\n      const authors = authorsList.join(', ');\n      \n      // Extract summary\n      const abstract = parser.getTagContent('summary');\n      \n      // Extract categories using the categories parser\n      const categories = parser.getCategories();\n      \n      // Extract published date\n      const published = parser.getPublishedDate();\n      \n      return {\n        title,\n        authors,\n        abstract,\n        source_specific_metadata: {\n          arxiv_tags: categories,\n          published_date: published\n        }\n      };\n    } catch (error) {\n      logger.error('Error fetching arXiv API data', error);\n      return {};\n    }\n  },\n  \n  color: '#B31B1B',\n  icon: 'üìù',\n  \n  formatId(id: string): string {\n    return `arxiv.${id}`;\n  }\n};\n\n// Register the plugin\npluginRegistry.register(arxivPlugin);\n\n// Export the plugin for direct import by the loader\nexport default arxivPlugin;\n","// extension/papers/plugins/sources/semantic_scholar_plugin.ts\n\nimport { SourcePlugin } from '../source_plugin';\nimport { UnifiedPaperData } from '../../types';\nimport { loguru } from '../../../utils/logger';\n\nconst logger = loguru.getLogger('SemanticScholarPlugin');\n\nexport const semanticScholarPlugin: SourcePlugin = {\n  id: 'semanticscholar',\n  name: 'Semantic Scholar',\n  description: 'Support for Semantic Scholar papers',\n  version: '1.0.0',\n  \n  urlPatterns: [\n    /semanticscholar\\.org\\/paper\\/([a-f0-9]+)/,\n    /s2-research\\.org\\/papers\\/([a-f0-9]+)/\n  ],\n  \n  extractId(url: string): string | null {\n    for (const pattern of this.urlPatterns) {\n      const match = url.match(pattern);\n      if (match) {\n        return match[1];\n      }\n    }\n    return null;\n  },\n  \n  async extractMetadata(document: Document, url: string): Promise<Partial<UnifiedPaperData>> {\n    logger.info(`Extracting metadata from ${url}`);\n    \n    try {\n      const getMetaContent = (selector: string): string | undefined => {\n        const element = document.querySelector(selector);\n        return element && 'content' in element ? \n          (element as HTMLMetaElement).content : undefined;\n      };\n      \n      // Extract from meta tags\n      const title = getMetaContent('meta[name=\"citation_title\"]') || \n                   getMetaContent('meta[property=\"og:title\"]') ||\n                   document.title;\n      \n      // Try to get authors - S2 has specific author elements\n      let authors = '';\n      const authorElements = document.querySelectorAll('[data-test-id=\"author-list\"] a');\n      if (authorElements.length > 0) {\n        authors = Array.from(authorElements)\n          .map(el => el.textContent?.trim())\n          .filter(Boolean)\n          .join(', ');\n      } else {\n        authors = getMetaContent('meta[name=\"citation_author\"]') || '';\n      }\n      \n      // Get abstract\n      let abstract = getMetaContent('meta[name=\"description\"]') || \n                    getMetaContent('meta[property=\"og:description\"]');\n      \n      if (!abstract) {\n        const abstractEl = document.querySelector('[data-test-id=\"abstract-text\"]') ||\n                          document.querySelector('.abstract');\n        abstract = abstractEl?.textContent?.trim();\n      }\n      \n      // Extract citation count if available\n      let citations: number | undefined;\n      const citationEl = document.querySelector('[data-test-id=\"citation-count\"]');\n      if (citationEl) {\n        const citText = citationEl.textContent;\n        if (citText) {\n          const match = citText.match(/(\\d+)/);\n          if (match) {\n            citations = parseInt(match[1], 10);\n          }\n        }\n      }\n      \n      // Extract DOI if available\n      const doi = getMetaContent('meta[name=\"citation_doi\"]');\n      const published_date = getMetaContent('meta[name=\"citation_publication_date\"]');\n      \n      return {\n        title: title || '',\n        authors: authors || '',\n        abstract: abstract || '',\n        source_specific_metadata: {\n          citations,\n          published_date: published_date || ''\n        },\n        identifiers: doi ? { doi } : undefined\n      };\n    } catch (error) {\n      logger.error('Error extracting metadata from Semantic Scholar page', error);\n      return {};\n    }\n  },\n  \n  hasApi: true,\n  \n  async fetchApiData(id: string): Promise<Partial<UnifiedPaperData>> {\n    logger.info(`Fetching API data for S2:${id}`);\n    \n    try {\n      const apiUrl = `https://api.semanticscholar.org/v1/paper/${id}`;\n      // Use self.fetch for service worker environment\n      const response = await self.fetch(apiUrl);\n      \n      if (!response.ok) {\n        throw new Error(`API error: ${response.status}`);\n      }\n      \n      const data = await response.json();\n      \n      // Extract fields from API response\n      const authors = data.authors ? \n        data.authors.map((author: any) => author.name).join(', ') : '';\n      \n      // Create the paper data object\n      const paperData: Partial<UnifiedPaperData> = {\n        title: data.title || '',\n        authors,\n        abstract: data.abstract || '',\n        source_specific_metadata: {\n          citations: data.citations,\n          published_date: data.year ? `${data.year}` : undefined,\n        },\n        identifiers: {}\n      };\n      \n      // Add identifiers\n      if (data.doi) {\n        paperData.identifiers!.doi = data.doi;\n      }\n      \n      if (data.arxivId) {\n        paperData.identifiers!.arxiv = data.arxivId;\n      }\n      \n      return paperData;\n    } catch (error) {\n      logger.error('Error fetching Semantic Scholar API data', error);\n      return {};\n    }\n  },\n  \n  color: '#2e7d32',\n  icon: 'üìä',\n  \n  formatId(id: string): string {\n    return `s2.${id}`;\n  }\n};\n\n// Register the plugin\nimport { pluginRegistry } from '../registry';\npluginRegistry.register(semanticScholarPlugin);\n","// extension/papers/plugins/sources/openreview_plugin.ts\n// Fixed version of openreview_plugin.ts with corrected title fallback logic\n\nimport { SourcePlugin } from '../source_plugin';\nimport { UnifiedPaperData } from '../../types';\nimport { loguru } from '../../../utils/logger';\nimport { pluginRegistry } from '../registry';\nimport { createServiceWorkerDOM } from '../../../utils/service_worker_parser';\n\nconst logger = loguru.getLogger('OpenReviewPlugin');\n\n// Types for OpenReview API responses\ninterface OpenReviewNote {\n  id: string;\n  forum: string;\n  content: Record<string, any>;\n  invitation: string;\n  readers: string[];\n  signatures: string[];\n  writers: string[];\n  cdate: number;\n  pdate?: number;\n  mdate?: number;\n  venue?: string;\n  venueid?: string;\n}\n\ninterface OpenReviewRating {\n  rating: string | null;\n  confidence: string | null;\n}\n\nexport const openreviewPlugin: SourcePlugin = {\n  id: 'openreview',\n  name: 'OpenReview',\n  description: 'Support for OpenReview papers',\n  version: '1.2.0',\n  \n  urlPatterns: [\n    /openreview\\.net\\/forum\\?id=([a-zA-Z0-9_\\-]+)/,\n    /openreview\\.net\\/pdf\\?id=([a-zA-Z0-9_\\-]+)/\n  ],\n  \n  extractId(url: string): string | null {\n    for (const pattern of this.urlPatterns) {\n      const match = url.match(pattern);\n      if (match) {\n        return match[1];\n      }\n    }\n    return null;\n  },\n  \n  async extractMetadata(document: any, url: string): Promise<Partial<UnifiedPaperData>> {\n    logger.info(`Extracting metadata from OpenReview page: ${url}`);\n    \n    try {\n      // Extract paper ID from URL\n      const paperId = this.extractId(url);\n      if (!paperId) {\n        logger.warning(`Could not extract paper ID from URL: ${url}`);\n        return { title: 'Unknown OpenReview Paper', url };\n      }\n      \n      // Check if we're in a service worker context (document is not a real DOM)\n      const isServiceWorker = typeof document !== 'object' || \n                             !document.querySelector || \n                             typeof document.querySelector !== 'function';\n      \n      if (isServiceWorker) {\n        // Use our service worker DOM utility instead of bespoke string processing\n        logger.info('Service worker context detected, using service worker DOM parser');\n        const htmlContent = typeof document === 'string' \n          ? document \n          : (document.innerHTML || document.outerHTML || '');\n        \n        // Create a lightweight DOM-like object we can query\n        const swDOM = createServiceWorkerDOM(htmlContent);\n        \n        // Now we can use querySelector-like methods to extract metadata from head tags\n        // These are more reliable than trying to parse the body content\n        const getMetaContent = (name: string): string | undefined => {\n          const element = swDOM.querySelector(`meta[name=\"${name}\"]`);\n          return element ? element.getAttribute('content') : undefined;\n        };\n        \n        // Get all citation_author meta tags\n        const authorElements = swDOM.querySelectorAll('meta[name=\"citation_author\"]');\n        let authors = '';\n        if (authorElements.length > 0) {\n          const authorTexts: string[] = [];\n          authorElements.forEach((el: any) => {\n            const content = el.getAttribute('content');\n            if (content) authorTexts.push(content);\n          });\n          authors = authorTexts.join(', ');\n        }\n        \n        // Extract title from meta tags first\n        let metaTitle = getMetaContent('citation_title');\n        \n        // If not found in meta tags, try to get from title element\n        let titleElement = swDOM.querySelector('title');\n        let docTitle = titleElement?.textContent || '';\n        \n        // Clean up title from title element (remove \" | OpenReview\" suffix)\n        if (docTitle) {\n          docTitle = docTitle.replace(' | OpenReview', '').trim();\n        }\n        \n        // Use meta title or document title\n        let title = metaTitle || docTitle || '';\n        \n        const abstract = getMetaContent('citation_abstract');\n        const publicationDate = getMetaContent('citation_online_date');\n        const conferenceTitle = getMetaContent('citation_conference_title');\n        const pdfUrl = getMetaContent('citation_pdf_url');\n        \n        // Additional metadata extraction from body content \n        // using more robust pattern matching\n        let domTitle = '';\n        let domAuthors = '';\n        let domAbstract = '';\n        let keywords = '';\n        let tldr = '';\n        let decision = '';\n        let venue = '';\n        \n        // Try to extract venue information from metadata section\n        const venueElements = swDOM.querySelectorAll('.forum-meta .item');\n        if (venueElements.length > 0) {\n          venueElements.forEach((el: any) => {\n            const text = el.textContent?.trim();\n            if (text && text.includes('Submitted to')) {\n              venue = text.replace('Submitted to', '').trim();\n            }\n          });\n        }\n        \n        // Extract keywords, abstract, etc. from content fields\n        const contentFields = swDOM.querySelectorAll('.note-content-field');\n        contentFields.forEach((el: any) => {\n          const fieldName = el.textContent?.trim();\n          if (!fieldName) return;\n          \n          const valueEl = el.parentElement?.querySelector('.note-content-value');\n          const value = valueEl?.textContent?.trim();\n          if (!value) return;\n          \n          if (fieldName.includes('Keywords')) {\n            keywords = value;\n          } else if (fieldName.includes('Abstract') && !abstract) {\n            domAbstract = value;\n          } else if (fieldName.includes('TL;DR') || fieldName.includes('TLDR')) {\n            tldr = value;\n          } else if (fieldName.includes('Decision')) {\n            decision = value;\n          }\n        });\n        \n        // Fallback title extraction from h1/h2 elements if meta tags failed\n        if (!title) {\n          const h1 = swDOM.querySelector('h1');\n          if (h1 && h1.textContent) {\n            domTitle = h1.textContent.trim();\n          } else {\n            const h2 = swDOM.querySelector('h2.citation_title');\n            if (h2 && h2.textContent) {\n              domTitle = h2.textContent.trim();\n            } else {\n              const h2Alt = swDOM.querySelector('.forum-title h2');\n              if (h2Alt && h2Alt.textContent) {\n                domTitle = h2Alt.textContent.trim();\n              }\n            }\n          }\n        }\n        \n        // Fallback author extraction from specific elements if meta tags failed\n        if (!authors) {\n          const authorDiv = swDOM.querySelector('.forum-authors h3');\n          if (authorDiv && authorDiv.textContent) {\n            domAuthors = authorDiv.textContent.trim();\n          }\n        }\n        \n        // Construct the source-specific metadata with more complete information\n        const sourceSpecificMetadata: Record<string, any> = {\n          forum_id: paperId,\n          conference: conferenceTitle || venue || '',\n          pdf_url: pdfUrl || '',\n          publication_date: publicationDate || '',\n          keywords: keywords || '',\n          tldr: tldr || ''\n        };\n        \n        // Add decision if available\n        if (decision) {\n          sourceSpecificMetadata.review_info = {\n            decision: decision\n          };\n        }\n        \n        // Filter out empty values\n        Object.keys(sourceSpecificMetadata).forEach(key => {\n          if (\n            sourceSpecificMetadata[key] === '' || \n            sourceSpecificMetadata[key] === null || \n            sourceSpecificMetadata[key] === undefined ||\n            (Array.isArray(sourceSpecificMetadata[key]) && sourceSpecificMetadata[key].length === 0) ||\n            (typeof sourceSpecificMetadata[key] === 'object' && Object.keys(sourceSpecificMetadata[key]).length === 0)\n          ) {\n            delete sourceSpecificMetadata[key];\n          }\n        });\n        \n        // Fixed title fallback: properly use the available title information\n        const finalTitle = title || domTitle || `OpenReview Paper: ${paperId}`;\n        \n        return {\n          title: finalTitle,\n          authors: authors || domAuthors || '',\n          abstract: abstract || domAbstract || '',\n          url: url,\n          source_specific_metadata: sourceSpecificMetadata\n        };\n      }\n      \n      // Browser context - use real DOM methods\n      // First priority: Extract from meta tags (most reliable)\n      const getMetaContent = (name: string): string | undefined => {\n        const element = document.querySelector(`meta[name=\"${name}\"]`);\n        return element ? element.getAttribute('content') || undefined : undefined;\n      };\n      \n      // Get all citation_author meta tags\n      const authorElements = document.querySelectorAll('meta[name=\"citation_author\"]');\n      let authors = '';\n      if (authorElements.length > 0) {\n        const authorTexts: string[] = [];\n        authorElements.forEach((el: Element) => {\n          const content = el.getAttribute('content');\n          if (content) authorTexts.push(content);\n        });\n        authors = authorTexts.join(', ');\n      }\n      \n      // Extract title, abstract, and other metadata from meta tags\n      // FIXED: Explicitly store meta title separately\n      const metaTitle = getMetaContent('citation_title');\n      const docTitle = document.title.replace(' | OpenReview', '').trim();\n      // Use meta title first, fallback to document title\n      let title = metaTitle || docTitle || '';\n      \n      const abstract = getMetaContent('citation_abstract');\n      const publicationDate = getMetaContent('citation_online_date');\n      const conferenceTitle = getMetaContent('citation_conference_title');\n      const pdfUrl = getMetaContent('citation_pdf_url');\n      \n      // Secondary approach: Extract from DOM structure if meta tags are incomplete\n      const extractFromDOM = () => {\n        const getContentFieldValue = (fieldName: string): string | null => {\n          // Find the field element that contains the field name\n          const fields = Array.from(document.querySelectorAll('.note-content-field, .note_content_field'));\n          for (const field of fields) {\n            const fieldElement = field as Element;\n            if (fieldElement.textContent?.includes(fieldName)) {\n              // Get its sibling or parent's next element which contains the value\n              const valueEl = fieldElement.nextElementSibling || \n                             fieldElement.parentElement?.querySelector('.note-content-value, .note_content_value');\n              \n              if (valueEl && valueEl.textContent) {\n                return valueEl.textContent.trim();\n              }\n            }\n          }\n          return null;\n        };\n        \n        // Extract the submission title if not found in meta\n        let domTitle = '';\n        const titleEl = document.querySelector('.note_content_title, .note-content-title, .forum-title h2');\n        if (titleEl && titleEl.textContent) {\n          domTitle = titleEl.textContent.trim();\n        }\n        \n        // Extract authors if not found in meta\n        let domAuthors = '';\n        const authorEl = document.querySelector('.signatures, .author, .authors, .forum-authors h3');\n        if (authorEl && authorEl.textContent) {\n          domAuthors = authorEl.textContent.trim();\n        }\n        \n        // Extract abstract if not found in meta\n        const domAbstract = getContentFieldValue('Abstract') || '';\n        \n        // Extract keywords\n        const keywords = getContentFieldValue('Keywords') || '';\n        \n        // Extract TL;DR summary\n        const tldr = getContentFieldValue('TL;DR') || getContentFieldValue('TLDR') || '';\n        \n        // Extract venue information\n        let venue = '';\n        const venueItems = document.querySelectorAll('.forum-meta .item');\n        for (const item of venueItems) {\n          const text = item.textContent?.trim();\n          if (text && text.includes('Submitted to')) {\n            venue = text.replace('Submitted to', '').trim();\n            break;\n          }\n        }\n        \n        return {\n          domTitle,\n          domAuthors,\n          domAbstract,\n          keywords,\n          tldr,\n          venue\n        };\n      };\n      \n      // Extract review information\n      const extractReviewInfo = () => {\n        // Check if there are reviews on the page\n        const reviewElements = document.querySelectorAll('.reply-container, .note-reply');\n        const reviewCount = reviewElements.length;\n        \n        // Try to determine decision based on common decision elements\n        let decision = '';\n        const decisionEl = document.querySelector(\n          '.decision, .meta-review, .metareview, [id*=\"decision\"], [class*=\"decision\"]'\n        );\n        if (decisionEl && decisionEl.textContent) {\n          decision = decisionEl.textContent.trim();\n        }\n        \n        // Extract ratings if available\n        const ratings: Array<{type: string, value: string}> = [];\n        const ratingElements = document.querySelectorAll('.rating, .score, .evaluation');\n        \n        ratingElements.forEach((el: Element) => {\n          const ratingText = el.textContent?.trim();\n          if (ratingText) {\n            const match = ratingText.match(/(.+):\\s*(\\d+)/);\n            if (match) {\n              ratings.push({ type: match[1].trim(), value: match[2].trim() });\n            } else {\n              ratings.push({ type: 'rating', value: ratingText });\n            }\n          }\n        });\n        \n        return {\n          reviewCount,\n          decision,\n          ratings\n        };\n      };\n      \n      // Get additional DOM-based data\n      const domData = extractFromDOM();\n      const reviewInfo = extractReviewInfo();\n      \n      // Construct the source-specific metadata\n      const sourceSpecificMetadata: Record<string, any> = {\n        forum_id: paperId,\n        conference: conferenceTitle || domData.venue || '',\n        pdf_url: pdfUrl || '',\n        publication_date: publicationDate || '',\n        tldr: domData.tldr || '',\n        keywords: domData.keywords || '',\n        review_info: {\n          review_count: reviewInfo.reviewCount,\n          decision: reviewInfo.decision,\n          ratings: reviewInfo.ratings\n        }\n      };\n      \n      // Filter out empty values\n      Object.keys(sourceSpecificMetadata).forEach(key => {\n        if (\n          sourceSpecificMetadata[key] === '' || \n          sourceSpecificMetadata[key] === null || \n          sourceSpecificMetadata[key] === undefined ||\n          (Array.isArray(sourceSpecificMetadata[key]) && sourceSpecificMetadata[key].length === 0) ||\n          (typeof sourceSpecificMetadata[key] === 'object' && Object.keys(sourceSpecificMetadata[key]).length === 0)\n        ) {\n          delete sourceSpecificMetadata[key];\n        }\n      });\n      \n      // FIXED: properly use the available title information with clear fallback chain\n      const finalTitle = title || domData.domTitle || `OpenReview Paper: ${paperId}`;\n      \n      return {\n        title: finalTitle,\n        authors: authors || domData.domAuthors || '',\n        abstract: abstract || domData.domAbstract || '',\n        url: url,\n        source_specific_metadata: sourceSpecificMetadata\n      };\n    } catch (error) {\n      logger.error('Error extracting metadata from OpenReview page', error);\n      return {\n        title: `OpenReview Paper: ${this.extractId(url) || 'Unknown'}`,\n        url: url\n      };\n    }\n  },\n  \n  hasApi: true,\n  \n  async fetchApiData(id: string): Promise<Partial<UnifiedPaperData>> {\n    logger.info(`Fetching OpenReview API data for ID: ${id}`);\n    \n    try {\n      // First try the direct PDF url\n      const pdfUrl = `https://openreview.net/pdf?id=${id}`;\n      \n      // API attempts - we'll try multiple approaches\n      let note: OpenReviewNote | null = null;\n      let reviewsData: any = null;\n      \n      // Try approach 1: Forum endpoint\n      logger.info(`Trying forum endpoint for ID: ${id}`);\n      const forumApiUrl = `https://api.openreview.net/notes?forum=${id}`;\n      const forumResponse = await fetch(forumApiUrl);\n      \n      if (forumResponse.ok) {\n        const data = await forumResponse.json();\n        reviewsData = data; // Store this for review extraction later\n        \n        // Check if we got valid data\n        if (data.notes && data.notes.length > 0) {\n          // Find the main paper (should be the note with ID matching the forum ID)\n          const mainNote = data.notes.find((n: any) => n.id === id || n.forum === id);\n          \n          if (mainNote) {\n            note = mainNote as OpenReviewNote;\n          } else {\n            // If we can't find the main note, just use the first one\n            note = data.notes[0] as OpenReviewNote;\n          }\n        } else {\n          logger.warning(`No notes found in forum for ID: ${id}`);\n        }\n      }\n      \n      // Try approach 2: Direct ID endpoint if forum approach failed\n      if (!note) {\n        logger.info(`Forum approach failed, trying direct ID endpoint for: ${id}`);\n        const notesApiUrl = `https://api.openreview.net/notes?id=${id}`;\n        \n        const notesResponse = await fetch(notesApiUrl);\n        if (notesResponse.ok) {\n          const data = await notesResponse.json();\n          \n          // Check if we got valid data\n          if (data.notes && data.notes.length > 0) {\n            note = data.notes[0] as OpenReviewNote;\n          } else {\n            logger.warning(`No note found for ID: ${id}`);\n          }\n        } else {\n          logger.warning(`API error for notes endpoint: ${notesResponse.status}`);\n        }\n      }\n      \n      // Fallback with minimal data if both API approaches failed\n      if (!note) {\n        // Construct minimal metadata with the URL and ID\n        return {\n          title: `OpenReview Paper: ${id}`,\n          url: `https://openreview.net/forum?id=${id}`,\n          source_specific_metadata: {\n            forum_id: id,\n            pdf_url: pdfUrl\n          }\n        };\n      }\n      \n      // Process the note data we found\n      const content = note.content || {};\n      \n      // Extract basic metadata\n      // Handle different content structures - newer OpenReview notes have value objects\n      const getContentValue = (field: string): any => {\n        if (!content[field]) return '';\n        return typeof content[field] === 'object' && 'value' in content[field] \n          ? content[field].value \n          : content[field];\n      };\n      \n      const title = getContentValue('title') || '';\n      \n      // Handle authors which could be in different formats\n      let authors = '';\n      const authorsData = getContentValue('authors');\n      if (Array.isArray(authorsData)) {\n        authors = authorsData.join(', ');\n      } else if (typeof authorsData === 'string') {\n        authors = authorsData;\n      }\n      \n      const abstract = getContentValue('abstract') || '';\n      const keywords = getContentValue('keywords') || '';\n      const tldr = getContentValue('TL;DR') || getContentValue('TLDR') || '';\n      \n      // Construct source-specific metadata\n      const sourceSpecificMetadata: Record<string, any> = {\n        forum_id: id,\n        venue: getContentValue('venue') || note.venue || '',\n        venueid: getContentValue('venueid') || note.venueid || '',\n        pdf_url: pdfUrl,\n        keywords: Array.isArray(keywords) ? keywords.join(', ') : keywords,\n        tldr: tldr,\n        creation_date: note.cdate ? new Date(note.cdate).toISOString() : '',\n        publication_date: note.pdate ? new Date(note.pdate).toISOString() : ''\n      };\n      \n      // Extract review information if we have review data\n      if (reviewsData && reviewsData.notes && reviewsData.notes.length > 1) {\n        // Filter out the main note to get just the replies\n        const replies = reviewsData.notes.filter((n: OpenReviewNote) => n.id !== id && n.id !== note?.id);\n        \n        if (replies.length > 0) {\n          // Find review notes based on invitation patterns\n          const reviews = replies.filter((n: OpenReviewNote) => \n            n.invitation.includes('/Review') || \n            n.invitation.includes('/review') || \n            n.invitation.includes('/evaluation')\n          );\n          \n          // Find meta-review/decision notes\n          const decisions = replies.filter((n: OpenReviewNote) => \n            n.invitation.includes('/Decision') || \n            n.invitation.includes('/decision') || \n            n.invitation.includes('/Meta_Review') || \n            n.invitation.includes('/meta-review')\n          );\n          \n          // Create review info object\n          sourceSpecificMetadata.review_info = {\n            reviews_count: reviews.length,\n            decisions_count: decisions.length,\n            total_replies: replies.length\n          };\n          \n          // Extract ratings if available\n          if (reviews.length > 0) {\n            const ratings = reviews\n              .filter((r: OpenReviewNote) => {\n                const content = r.content || {};\n                return content.rating || content.score || content.confidence || \n                      (content.rating && content.rating.value) || \n                      (content.score && content.score.value);\n              })\n              .map((r: OpenReviewNote) => {\n                const content = r.content || {};\n                const getRatingValue = (field: string) => {\n                  if (!content[field]) return null;\n                  return typeof content[field] === 'object' && 'value' in content[field]\n                    ? content[field].value\n                    : content[field];\n                };\n                \n                return {\n                  rating: getRatingValue('rating') || getRatingValue('score') || null,\n                  confidence: getRatingValue('confidence') || null\n                } as OpenReviewRating;\n              });\n              \n            if (ratings.length > 0) {\n              sourceSpecificMetadata.review_info.ratings = ratings;\n            }\n          }\n          \n          // Extract decision text if available\n          if (decisions.length > 0) {\n            const decisionContent = decisions[0].content || {};\n            const getDecisionValue = (field: string) => {\n              if (!decisionContent[field]) return null;\n              return typeof decisionContent[field] === 'object' && 'value' in decisionContent[field]\n                ? decisionContent[field].value\n                : decisionContent[field];\n            };\n            \n            const decision = getDecisionValue('decision') || \n                            getDecisionValue('recommendation') || \n                            getDecisionValue('metareview') || '';\n                            \n            if (decision) {\n              sourceSpecificMetadata.review_info.decision = decision;\n            }\n          }\n        }\n      }\n      \n      // Filter out empty values\n      Object.keys(sourceSpecificMetadata).forEach(key => {\n        if (\n          sourceSpecificMetadata[key] === '' || \n          sourceSpecificMetadata[key] === null || \n          sourceSpecificMetadata[key] === undefined ||\n          (Array.isArray(sourceSpecificMetadata[key]) && sourceSpecificMetadata[key].length === 0) ||\n          (typeof sourceSpecificMetadata[key] === 'object' && \n            Object.keys(sourceSpecificMetadata[key]).filter(k => sourceSpecificMetadata[key][k] !== null).length === 0)\n        ) {\n          delete sourceSpecificMetadata[key];\n        }\n      });\n      \n      return {\n        title,\n        authors,\n        abstract,\n        source_specific_metadata: sourceSpecificMetadata,\n        url: `https://openreview.net/forum?id=${id}`\n      };\n    } catch (error) {\n      logger.error(`Error fetching OpenReview API data: ${error}`);\n      // Return minimal data on error\n      return {\n        title: `OpenReview Paper: ${id}`,\n        url: `https://openreview.net/forum?id=${id}`,\n        source_specific_metadata: {\n          forum_id: id,\n          pdf_url: `https://openreview.net/pdf?id=${id}`\n        }\n      };\n    }\n  },\n  \n  color: '#6d4c41',\n  icon: 'üìã',\n  \n  formatId(id: string): string {\n    return `openreview.${id}`;\n  }\n};\n\n// Register the plugin\npluginRegistry.register(openreviewPlugin);\n\n// Export the plugin for direct import by the loader\nexport default openreviewPlugin;\n","// extension/papers/plugins/loader.ts\n// Improved plugin loader with better initialization handling\n\nimport { loguru } from '../../utils/logger';\nimport { pluginRegistry } from './registry';\n\n// Import plugins directly (static imports only)\n// This is the key change - we need to use static imports only in service workers\nimport { arxivPlugin } from './sources/arxiv_plugin';\nimport { semanticScholarPlugin } from './sources/semantic_scholar_plugin';\nimport { openreviewPlugin } from './sources/openreview_plugin';\n\nconst logger = loguru.getLogger('PluginLoader');\n\n// Track plugin initialization state\nlet pluginsInitialized = false;\nlet initializationPromise: Promise<void> | null = null;\n\n/**\n * Register core plugins manually instead of dynamic imports\n * Service workers don't support dynamic imports\n */\nfunction registerCorePlugins(): void {\n  try {\n    // Clear existing plugins to avoid duplicates in case of retries\n    const existingPlugins = pluginRegistry.getAll();\n    if (existingPlugins.length > 0) {\n      logger.info(`Found ${existingPlugins.length} plugins already registered`);\n      return; // Already registered\n    }\n    \n    // Register each plugin manually - static imports\n    pluginRegistry.register(arxivPlugin);\n    pluginRegistry.register(semanticScholarPlugin);\n    pluginRegistry.register(openreviewPlugin);\n    \n    const pluginCount = pluginRegistry.getAll().length;\n    logger.info(`Registered ${pluginCount} core plugins manually`);\n  } catch (error) {\n    logger.error('Error registering core plugins:', error);\n    throw error;\n  }\n}\n\n/**\n * Load all built-in source plugins with improved error handling\n */\nasync function loadBuiltinPlugins(): Promise<void> {\n  logger.info('Loading built-in plugins');\n  \n  try {\n    // Register the core plugins directly - no dynamic imports\n    registerCorePlugins();\n    \n    // Check if plugins were registered successfully\n    const pluginCount = pluginRegistry.getAll().length;\n    \n    if (pluginCount === 0) {\n      logger.warning('No plugins were registered. Attempting emergency direct registration.');\n      \n      // Emergency fallback - try direct plugin registration again\n      try {\n        // These are the same plugins, but we try again in case of registration issues\n        pluginRegistry.register(arxivPlugin);\n        pluginRegistry.register(semanticScholarPlugin);\n        pluginRegistry.register(openreviewPlugin);\n        \n        // Check if emergency registration worked\n        const emergencyCount = pluginRegistry.getAll().length;\n        if (emergencyCount > 0) {\n          logger.info(`Emergency plugin registration successful: ${emergencyCount} plugins registered`);\n        } else {\n          throw new Error('Failed to register any plugins even with emergency registration');\n        }\n      } catch (emergencyError) {\n        logger.error('Emergency plugin registration failed:', emergencyError);\n        throw emergencyError;\n      }\n    } else {\n      logger.info(`${pluginCount} plugins are registered`);\n    }\n  } catch (error) {\n    logger.error('Error loading plugins', error);\n    // Log detailed error information for debugging\n    if (error instanceof Error) {\n      logger.error(`Plugin loading error: ${error.message}`);\n      if (error.stack) {\n        logger.error(`Stack trace: ${error.stack}`);\n      }\n    }\n    // Rethrow to indicate initialization failure\n    throw error;\n  }\n}\n\n/**\n * Initialize the plugin system with retry capability\n * @param {number} retries Number of retries if initialization fails\n * @returns {Promise<void>}\n */\nexport async function initializePluginSystem(retries = 3): Promise<void> {\n  // If already initialized, return immediately\n  if (pluginsInitialized) {\n    return;\n  }\n  \n  // If initialization is in progress, return the existing promise\n  if (initializationPromise) {\n    return initializationPromise;\n  }\n  \n  // Start initialization\n  logger.info('Initializing plugin system');\n  \n  // Create a new initialization promise\n  initializationPromise = (async () => {\n    let attemptCount = 0;\n    let lastError: Error | null = null;\n    \n    // Try initialization with retries\n    while (attemptCount < retries) {\n      try {\n        await loadBuiltinPlugins();\n        \n        // Log loaded plugins\n        const loadedPlugins = pluginRegistry.getAll();\n        logger.info(`Initialized ${loadedPlugins.length} plugins:`);\n        \n        loadedPlugins.forEach(plugin => {\n          logger.info(`- ${plugin.name} (${plugin.id}) v${plugin.version}`);\n        });\n        \n        // Mark as successful\n        pluginsInitialized = true;\n        return;\n      } catch (error) {\n        attemptCount++;\n        lastError = error instanceof Error ? error : new Error(String(error));\n        logger.warning(`Plugin initialization attempt ${attemptCount} failed: ${lastError.message}`);\n        \n        if (attemptCount < retries) {\n          // Wait before retrying\n          const delay = Math.pow(2, attemptCount) * 500; // Exponential backoff\n          logger.info(`Retrying plugin initialization in ${delay}ms...`);\n          await new Promise(resolve => setTimeout(resolve, delay));\n        }\n      }\n    }\n    \n    // If we get here, all retries failed\n    logger.error(`Plugin initialization failed after ${retries} attempts.`);\n    if (lastError) {\n      throw lastError;\n    } else {\n      throw new Error('Plugin initialization failed for unknown reasons');\n    }\n  })();\n  \n  try {\n    await initializationPromise;\n    return;\n  } catch (error) {\n    // Reset the promise so future calls can try again\n    initializationPromise = null;\n    throw error;\n  }\n}\n\n/**\n * Check if plugins are initialized\n * @returns {boolean} True if plugins are initialized\n */\nexport function arePluginsInitialized(): boolean {\n  return pluginsInitialized;\n}\n\n/**\n * Get current plugin initialization state\n * @returns {Object} Initialization state\n */\nexport function getPluginInitializationState() {\n  return {\n    initialized: pluginsInitialized,\n    initializationInProgress: !!initializationPromise,\n    pluginCount: pluginRegistry.getAll().length\n  };\n}\n\n/**\n * Manually reset plugin initialization state\n * Used primarily for testing and emergency recovery\n */\nexport function resetPluginInitialization(): void {\n  pluginsInitialized = false;\n  initializationPromise = null;\n  logger.warning('Plugin initialization state has been reset');\n}\n","// extension/papers/url_detection_service.ts - Fixed version\n\nimport { pluginRegistry } from './plugins/registry';\nimport { formatPrimaryId } from './source_utils';\nimport { arePluginsInitialized, initializePluginSystem } from './plugins/loader';\nimport { loguru } from '../utils/logger';\n\nconst logger = loguru.getLogger('URLDetectionService');\n\n// Type definition for detected source information\nexport interface DetectedSourceInfo {\n  type: string;          // Source type (e.g., 'arxiv', 'doi')\n  id: string;            // Source-specific ID\n  primary_id: string;    // Universal primary ID \n  url: string;           // Original URL\n  plugin?: any;          // Associated plugin if available\n}\n\nclass URLDetectionService {\n  // Track URLs being processed to prevent duplicates\n  private pendingUrls = new Set<string>();\n  \n  // Debounce configuration\n  private debounceTime = 500; // ms\n  private debounceTimers = new Map<string, NodeJS.Timeout>();\n  \n  // Cache successful detections to avoid repeat processing\n  private detectionCache = new Map<string, DetectedSourceInfo>();\n  private maxCacheSize = 100;\n  \n  constructor() {\n    logger.info('URL Detection Service initialized');\n  }\n  \n  /**\n   * Detect paper source from URL\n   * @param {string} url URL to analyze\n   * @returns {Promise<DetectedSourceInfo|null>} Detected source info or null\n   */\n  async detectSource(url: string): Promise<DetectedSourceInfo | null> {\n    if (!url) {\n      logger.warning('Empty URL provided to detectSource');\n      return null;\n    }\n    \n    // First check cache\n    if (this.detectionCache.has(url)) {\n      logger.info(`Cache hit for ${url}`);\n      return this.detectionCache.get(url) as DetectedSourceInfo;\n    }\n    \n    // Ensure plugins are initialized\n    if (!arePluginsInitialized()) {\n      logger.info('Plugins not initialized, initializing now...');\n      try {\n        await initializePluginSystem();\n      } catch (error) {\n        logger.error('Failed to initialize plugins:', error);\n        return null;\n      }\n    }\n    \n    // Check if URL is already being processed\n    if (this.isUrlPending(url)) {\n      logger.info(`URL already being processed: ${url}`);\n      return null;\n    }\n    \n    try {\n      // Mark URL as pending\n      this.addPendingUrl(url);\n      \n      // Try using the plugin registry's findForUrl method first\n      const result = pluginRegistry.findForUrl(url);\n      if (result) {\n        const sourceInfo: DetectedSourceInfo = {\n          type: result.plugin.id,\n          id: result.id,\n          primary_id: result.plugin.formatId ? \n            result.plugin.formatId(result.id) : \n            formatPrimaryId(result.plugin.id, result.id),\n          url: url,\n          plugin: result.plugin\n        };\n        \n        // Add to cache\n        this.addToCache(url, sourceInfo);\n        \n        logger.info(`Detected source using plugin registry: ${sourceInfo.type}:${sourceInfo.id}`);\n        return sourceInfo;\n      }\n      \n      // Fall back to checking each plugin manually\n      const plugins = pluginRegistry.getAll();\n      \n      for (const plugin of plugins) {\n        for (const pattern of plugin.urlPatterns) {\n          const match = url.match(pattern);\n          if (match) {\n            const id = plugin.extractId(url);\n            if (id) {\n              const sourceInfo: DetectedSourceInfo = {\n                type: plugin.id,\n                id: id,\n                primary_id: plugin.formatId ? \n                  plugin.formatId(id) : \n                  formatPrimaryId(plugin.id, id),\n                url: url,\n                plugin: plugin\n              };\n              \n              // Add to cache\n              this.addToCache(url, sourceInfo);\n              \n              logger.info(`Detected source using manual check: ${sourceInfo.type}:${sourceInfo.id}`);\n              return sourceInfo;\n            }\n          }\n        }\n      }\n      \n      logger.info(`No matching source found for URL: ${url}`);\n      return null;\n    } finally {\n      // Clean up pending URL after a delay to prevent immediate reprocessing\n      this.removePendingUrlWithDelay(url);\n    }\n  }\n  \n  /**\n   * Check if a URL is valid for paper detection\n   * @param {string} url URL to check\n   * @returns {boolean} True if URL is valid\n   */\n  isValidUrl(url: string): boolean {\n    if (!url || typeof url !== 'string') return false;\n    \n    try {\n      // Basic URL validation\n      new URL(url);\n      \n      // Check for common academic domains\n      const commonDomains = [\n        'arxiv.org',\n        'semanticscholar.org',\n        'doi.org',\n        'dl.acm.org',\n        'openreview.net',\n        's2-research.org'\n      ];\n      \n      return commonDomains.some(domain => url.includes(domain));\n    } catch (e) {\n      return false;\n    }\n  }\n  \n  /**\n   * Check if URL is currently being processed\n   * @param {string} url URL to check\n   * @returns {boolean} True if URL is pending\n   */\n  isUrlPending(url: string): boolean {\n    return this.pendingUrls.has(url);\n  }\n  \n  /**\n   * Add URL to pending set\n   * @param {string} url URL to add\n   */\n  addPendingUrl(url: string): void {\n    this.pendingUrls.add(url);\n  }\n  \n  /**\n   * Remove URL from pending set\n   * @param {string} url URL to remove\n   */\n  removePendingUrl(url: string): void {\n    this.pendingUrls.delete(url);\n    \n    // Clear any existing timer\n    if (this.debounceTimers.has(url)) {\n      clearTimeout(this.debounceTimers.get(url));\n      this.debounceTimers.delete(url);\n    }\n  }\n  \n  /**\n   * Remove URL from pending set after a delay\n   * @param {string} url URL to remove\n   * @param {number} delay Delay in ms (default: debounceTime)\n   */\n  removePendingUrlWithDelay(url: string, delay?: number): void {\n    // Clear any existing timer\n    if (this.debounceTimers.has(url)) {\n      clearTimeout(this.debounceTimers.get(url) as NodeJS.Timeout);\n    }\n    \n    // Set new timer\n    const timer = setTimeout(() => {\n      this.pendingUrls.delete(url);\n      this.debounceTimers.delete(url);\n    }, delay || this.debounceTime);\n    \n    this.debounceTimers.set(url, timer);\n  }\n  \n  /**\n   * Add a successful detection to cache\n   * @param {string} url URL \n   * @param {DetectedSourceInfo} info Detection info\n   */\n  private addToCache(url: string, info: DetectedSourceInfo): void {\n    if (!url) {\n      logger.warning('Attempted to cache with empty URL');\n      return;\n    }\n    \n    // Implement LRU cache eviction if needed\n    if (this.detectionCache.size >= this.maxCacheSize) {\n      // Remove oldest entry (first key)\n      const oldestKey = this.detectionCache.keys().next().value;\n      if (oldestKey) {\n        this.detectionCache.delete(oldestKey);\n      }\n    }\n    \n    this.detectionCache.set(url, info);\n  }\n  \n  /**\n   * Clear the detection cache\n   */\n  clearCache(): void {\n    this.detectionCache.clear();\n  }\n  \n  /**\n   * Reset the service state\n   * Used for testing and emergency recovery\n   */\n  reset(): void {\n    // Clear pending URLs\n    this.pendingUrls.clear();\n    \n    // Clear all timers\n    for (const timer of this.debounceTimers.values()) {\n      clearTimeout(timer);\n    }\n    this.debounceTimers.clear();\n    \n    // Clear cache\n    this.clearCache();\n    \n    logger.info('URL Detection Service has been reset');\n  }\n  \n  /**\n   * Get service status information\n   * @returns {Object} Service status\n   */\n  getStatus(): any {\n    return {\n      pendingUrlsCount: this.pendingUrls.size,\n      activeTimersCount: this.debounceTimers.size,\n      cacheSize: this.detectionCache.size,\n      pluginsInitialized: arePluginsInitialized(),\n      pluginCount: pluginRegistry.getAll().length\n    };\n  }\n}\n\n// Export singleton instance\nexport const urlDetectionService = new URLDetectionService();\n","// extension/background_integration.ts - With service worker support\n\nimport { urlDetectionService, DetectedSourceInfo } from './papers/url_detection_service';\nimport { initializePluginSystem, getPluginInitializationState } from './papers/plugins/loader';\nimport { formatPrimaryId } from './papers/source_utils';\nimport { loguru } from './utils/logger';\n\n// Define NavDetails interface for Chrome API types\ninterface NavDetails {\n    tabId: number;\n    url: string;\n    frameId: number;\n    timeStamp: number;\n}\n\nconst logger = loguru.getLogger('BackgroundIntegration');\n\n/**\n * Initialize the enhanced services\n * @returns {Promise<void>}\n */\nexport async function initializeEnhancedServices(): Promise<void> {\n  logger.info('Initializing enhanced services');\n  \n  try {\n    // Initialize plugin system with retry capability\n    await initializePluginSystem(3);\n    \n    const pluginState = getPluginInitializationState();\n    logger.info('Plugin system initialized:', pluginState);\n    \n    // Add this integration module to the extension debug API\n    // Using 'self' for service worker context\n    if (typeof self !== 'undefined' && 'self' in globalThis && '__DEBUG__' in self) {\n      (self as any).__DEBUG__.enhancedServices = {\n        urlDetectionService,\n        getPluginState: getPluginInitializationState,\n        handleUrl: processUrl\n      };\n      \n      logger.info('Debug API extended with enhanced services');\n    }\n  } catch (error) {\n    logger.error('Failed to initialize enhanced services:', error);\n    throw error;\n  }\n}\n\n/**\n * Process a URL using the enhanced detection service\n * @param {string} url URL to process\n * @returns {Promise<DetectedSourceInfo|null>} Detection result\n */\nexport async function processUrl(url: string): Promise<DetectedSourceInfo | null> {\n  if (!urlDetectionService.isValidUrl(url)) {\n    logger.info(`Invalid or unsupported URL: ${url}`);\n    return null;\n  }\n  \n  try {\n    return await urlDetectionService.detectSource(url);\n  } catch (error) {\n    logger.error(`Error processing URL ${url}:`, error);\n    return null;\n  }\n}\n\n/**\n * Process a tab using the enhanced detection service\n * @param {chrome.tabs.Tab} tab Tab to process\n * @returns {Promise<DetectedSourceInfo|null>} Detection result\n */\nexport async function processTab(tab: chrome.tabs.Tab): Promise<DetectedSourceInfo | null> {\n  if (!tab.url) {\n    logger.info('Tab has no URL');\n    return null;\n  }\n  \n  return processUrl(tab.url);\n}\n\n/**\n * Process navigation event using the enhanced detection service\n * @param {NavDetails} details Navigation details\n * @returns {Promise<DetectedSourceInfo|null>} Detection result\n */\nexport async function processNavigation(details: NavDetails): Promise<DetectedSourceInfo | null> {\n  if (!details.url) {\n    logger.info('Navigation event has no URL');\n    return null;\n  }\n  \n  return processUrl(details.url);\n}\n\n/**\n * Extract metadata from a detected source\n * @param {DetectedSourceInfo} sourceInfo Source info\n * @returns {Promise<Object|null>} Extracted metadata or null\n */\nexport async function extractMetadataFromSource(sourceInfo: DetectedSourceInfo): Promise<any | null> {\n  if (!sourceInfo || !sourceInfo.plugin) {\n    logger.info('No valid source info or plugin');\n    return null;\n  }\n  \n  try {\n    // Try to use the plugin's API if available\n    if (sourceInfo.plugin.hasApi && sourceInfo.plugin.fetchApiData) {\n      try {\n        logger.info(`Using ${sourceInfo.plugin.id} plugin API to extract metadata`);\n        const apiData = await sourceInfo.plugin.fetchApiData(sourceInfo.id);\n        \n        if (apiData && Object.keys(apiData).length > 0) {\n          // Ensure required fields are present\n          return {\n            ...apiData,\n            source: sourceInfo.type,\n            sourceId: sourceInfo.id,\n            primary_id: sourceInfo.primary_id,\n            url: sourceInfo.url\n          };\n        }\n      } catch (apiError) {\n        logger.error(`Error using plugin API: ${apiError}`);\n      }\n    }\n    \n    // Fall back to default minimal data\n    return {\n      source: sourceInfo.type,\n      sourceId: sourceInfo.id,\n      primary_id: sourceInfo.primary_id,\n      url: sourceInfo.url,\n      title: `${sourceInfo.type.toUpperCase()} Paper: ${sourceInfo.id}`,\n      timestamp: new Date().toISOString(),\n      rating: 'novote'\n    };\n  } catch (error) {\n    logger.error(`Error extracting metadata: ${error}`);\n    return null;\n  }\n}\n\n/**\n * Process a document with DOM access using the given tab\n * @param {number} tabId Tab ID for DOM access\n * @param {DetectedSourceInfo} sourceInfo Source info\n * @returns {Promise<Object|null>} Extracted metadata or null\n */\nexport async function extractMetadataFromDOM(tabId: number, sourceInfo: DetectedSourceInfo): Promise<any | null> {\n  if (!sourceInfo || !sourceInfo.plugin || !sourceInfo.plugin.extractMetadata) {\n    return null;\n  }\n  \n  try {\n    logger.info(`Attempting DOM extraction for ${sourceInfo.type}`);\n    \n    // Execute script to get HTML document\n    const script = await chrome.scripting.executeScript({\n      target: { tabId },\n      func: () => document.documentElement.outerHTML\n    });\n    \n    if (script && script[0] && script[0].result) {\n      // Create DOM document from HTML for service worker context\n      // Use non-DOM parser for service worker environment\n      try {\n        const htmlString = script[0].result as string;\n        \n        // Since we're in a service worker, we need to use a different approach for metadata extraction\n        // Ask the plugin to extract metadata - must be a service worker safe implementation\n        const metadata = await sourceInfo.plugin.extractMetadata({\n          documentElement: { outerHTML: htmlString }\n        }, sourceInfo.url);\n        \n        if (metadata && Object.keys(metadata).length > 0) {\n          return {\n            ...metadata,\n            source: sourceInfo.type,\n            sourceId: sourceInfo.id,\n            primary_id: sourceInfo.primary_id,\n            url: sourceInfo.url\n          };\n        }\n      } catch (parserError) {\n        logger.error(`Error parsing HTML in service worker: ${parserError}`);\n        // Fall back to direct string content\n        try {\n          // Use a simpler approach - pass the HTML as a string\n          const metadata = await sourceInfo.plugin.extractMetadata(\n            { innerHTML: script[0].result },\n            sourceInfo.url\n          );\n          \n          if (metadata && Object.keys(metadata).length > 0) {\n            return {\n              ...metadata,\n              source: sourceInfo.type,\n              sourceId: sourceInfo.id,\n              primary_id: sourceInfo.primary_id,\n              url: sourceInfo.url\n            };\n          }\n        } catch (fallbackError) {\n          logger.error(`Error with fallback metadata extraction: ${fallbackError}`);\n        }\n      }\n    }\n  } catch (error) {\n    logger.error(`Error extracting metadata from DOM: ${error}`);\n  }\n  \n  return null;\n}\n\n/**\n * Fully process a URL with all enhanced services\n * @param {string} url URL to process\n * @param {number|null} tabId Optional tab ID for DOM access\n * @returns {Promise<Object|null>} Full paper data or null\n */\nexport async function fullyProcessUrl(url: string, tabId: number | null = null): Promise<any | null> {\n  try {\n    // Detect source\n    const sourceInfo = await processUrl(url);\n    \n    if (!sourceInfo) {\n      logger.info(`No source detected for URL: ${url}`);\n      return null;\n    }\n    \n    logger.info(`Detected ${sourceInfo.type} paper: ${sourceInfo.id}`);\n    \n    // Try API metadata extraction first\n    let paperData = await extractMetadataFromSource(sourceInfo);\n    \n    // If API extraction failed or returned minimal data and we have a tab ID,\n    // try DOM extraction as a fallback\n    if (tabId && (!paperData || !paperData.title || paperData.title.includes(sourceInfo.id))) {\n      logger.info('API extraction failed or returned minimal data, trying DOM extraction');\n      const domData = await extractMetadataFromDOM(tabId, sourceInfo);\n      \n      if (domData) {\n        // Merge API and DOM data, with DOM data taking precedence\n        paperData = {\n          ...paperData,\n          ...domData,\n          // Ensure critical fields are preserved\n          source: sourceInfo.type,\n          sourceId: sourceInfo.id,\n          primary_id: sourceInfo.primary_id,\n          url: sourceInfo.url\n        };\n      }\n    }\n    \n    if (paperData) {\n      logger.info(`Successfully processed paper: ${paperData.title || paperData.primary_id}`);\n    }\n    \n    return paperData;\n  } catch (error) {\n    logger.error(`Error fully processing URL ${url}:`, error);\n    return null;\n  }\n}\n","// background.js - Updated with unified approach and plugin handling improvements\n\nimport { GitHubStoreClient } from 'gh-store-client';\nimport { PaperManager } from './papers/manager';\nimport { loadSessionConfig, getConfigurationInMs } from './config/session.js';\nimport { formatPrimaryId } from './papers/source_utils';\nimport { initializePluginSystem } from './papers/plugins/loader';\nimport { pluginRegistry } from './papers/plugins/registry';\nimport { loguru } from './utils/logger';\n\n// Import the new enhanced services\nimport { \n  initializeEnhancedServices, \n  processNavigation,\n  processTab,\n  fullyProcessUrl \n} from './background_integration';\n\nconst logger = loguru.getLogger('Background');\n\n// Global state\nlet githubToken = '';\nlet githubRepo = '';\nlet currentPaperData = null;\nlet currentSession = null;\nlet activityInterval = null;\nlet sessionConfig = null;\nlet paperManager = null;\n\n// Debounce mechanism to avoid multiple creations of the same paper\nconst pendingUrls = new Set();\n\n// Enhanced reading session for modern format\nclass EnhancedReadingSession {\n  constructor(paperData, config) {\n    // Validate required fields\n    if (!paperData.primary_id) {\n      throw new Error('Paper data must include primary_id');\n    }\n    \n    this.paperId = paperData.primary_id;\n    this.paperData = paperData;\n    \n    // Generate unique session ID\n    this.sessionId = `session_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n    \n    // Initialize timing data\n    this.startTime = new Date();\n    this.activeTime = 0;\n    this.idleTime = 0;\n    this.lastActiveTime = new Date();\n    this.isTracking = true;\n    this.config = config;\n    this.endTime = null;\n    this.finalizedData = null;\n  }\n  \n  update() {\n    if (this.isTracking && !this.finalizedData) {\n      const now = new Date();\n      const timeSinceLastActive = now.getTime() - this.lastActiveTime.getTime();\n      \n      if (timeSinceLastActive < this.config.idleThreshold) {\n        this.activeTime += timeSinceLastActive;\n      } else {\n        this.idleTime += timeSinceLastActive;\n      }\n      \n      this.lastActiveTime = now;\n    }\n  }\n  \n  finalize() {\n    if (this.finalizedData) {\n      return this.finalizedData;\n    }\n \n    this.update();\n    this.isTracking = false;\n    this.endTime = new Date();\n    const totalElapsed = this.endTime.getTime() - this.startTime.getTime();\n \n    if (this.activeTime >= this.config.minSessionDuration) {\n      this.finalizedData = {\n        session_id: this.sessionId,\n        duration_seconds: Math.round(this.activeTime / 1000),\n        idle_seconds: Math.round(this.idleTime / 1000),\n        start_time: this.startTime.toISOString(),\n        end_time: this.endTime.toISOString(),\n        total_elapsed_seconds: Math.round(totalElapsed / 1000)\n      };\n      return this.finalizedData;\n    }\n    return null;\n  }\n  \n  getMetadata() {\n    return {\n      sourceType: this.paperData.source,\n      paperId: this.paperId,\n      title: this.paperData.title,\n      sessionId: this.sessionId,\n      startTime: this.startTime.toISOString(),\n      activeSeconds: Math.round(this.activeTime / 1000),\n      idleSeconds: Math.round(this.idleTime / 1000)\n    };\n  }\n}\n\n// Load credentials and configuration when extension starts\nasync function loadCredentials() {\n  const items = await chrome.storage.sync.get(['githubToken', 'githubRepo']);\n  githubToken = items.githubToken || '';\n  githubRepo = items.githubRepo || '';\n  logger.info('Credentials loaded:', { hasToken: !!githubToken, hasRepo: !!githubRepo });\n  \n  // Initialize paper manager if we have credentials\n  if (githubToken && githubRepo) {\n    const githubClient = new GitHubStoreClient(githubToken, githubRepo);\n    paperManager = new PaperManager(githubClient);\n    logger.info('Paper manager initialized');\n  }\n  \n  // Load session configuration\n  sessionConfig = getConfigurationInMs(await loadSessionConfig());\n  logger.info('Session configuration loaded:', sessionConfig);\n  \n  // Initialize debug objects\n  initializeDebugObjects();\n}\n\n// Listen for credential changes\nchrome.storage.onChanged.addListener(async (changes) => {\n  logger.info('Storage changes detected:', Object.keys(changes));\n  if (changes.githubToken) {\n    githubToken = changes.githubToken.newValue;\n  }\n  if (changes.githubRepo) {\n    githubRepo = changes.githubRepo.newValue;\n  }\n  if (changes.sessionConfig) {\n    sessionConfig = getConfigurationInMs(changes.sessionConfig.newValue);\n    logger.info('Session configuration updated:', sessionConfig);\n  }\n  \n  // Reinitialize paper manager if credentials changed\n  if (changes.githubToken || changes.githubRepo) {\n    if (githubToken && githubRepo) {\n      const githubClient = new GitHubStoreClient(githubToken, githubRepo);\n      paperManager = new PaperManager(githubClient);\n      logger.info('Paper manager reinitialized');\n    }\n  }\n});\n\n// Update the initialize function to include the enhanced services\nasync function initialize() {\n  logger.info('Initializing extension');\n  \n  // Load credentials and config\n  await loadCredentials();\n  \n  // Initialize enhanced services (includes plugin system)\n  await initializeEnhancedServices();\n  \n  // Set up listeners for tab changes\n  await setupListeners();\n  \n  logger.info('Extension initialized');\n}\n\n// Initialize extension\ninitialize().catch(error => {\n  logger.error('Initialization failed', error);\n});\n\n// Message passing between background and popup/content scripts\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  logger.info('Message received:', request);\n  \n  if (request.type === 'getCurrentPaper') {\n    logger.info('Popup requested current paper:', currentPaperData);\n    sendResponse(currentPaperData);\n  }\n  else if (request.type === 'updateRating') {\n    logger.info('Rating update requested:', request.rating);\n    handleUpdateRating(request.rating, sendResponse);\n    return true; // Will respond asynchronously\n  }\n  else if (request.type === 'updateAnnotation') {\n    logger.info('Annotation update requested:', request.annotationType, request.data);\n    handleAnnotationUpdate(request.annotationType, request.data)\n      .then(response => sendResponse(response))\n      .catch(error => sendResponse({ success: false, error: error.message }));\n    return true; // Will respond asynchronously\n  }\n  // Add a dedicated handler for track paper requests from content scripts\n  else if (request.type === 'trackPaper') {\n    logger.info('Track paper requested:', request);\n    handleTrackPaper(request)\n      .then(response => sendResponse(response))\n      .catch(error => sendResponse({ success: false, error: error.message }));\n    return true; // Will respond asynchronously\n  }\n  return true;\n});\n\n// Replace the handleTrackPaper function\nasync function handleTrackPaper(request) {\n  if (!paperManager) {\n    throw new Error('Paper manager not initialized');\n  }\n\n  try {\n    // Process the paper URL using enhanced services\n    let paperData;\n    \n    if (request.url) {\n      // If it's a URL, use fullyProcessUrl\n      paperData = await fullyProcessUrl(request.url);\n    } else if (request.source && request.id) {\n      // If it's just source and ID, create basic data\n      const primary_id = formatPrimaryId(request.source, request.id);\n      paperData = {\n        source: request.source,\n        sourceId: request.id,\n        primary_id: primary_id,\n        url: request.url || '',\n        title: request.title || `${request.source.toUpperCase()} Paper: ${request.id}`,\n        timestamp: new Date().toISOString(),\n        rating: 'novote'\n      };\n    } else {\n      throw new Error('Invalid request: missing URL or source/id');\n    }\n    \n    if (!paperData) {\n      throw new Error(`Could not process paper: ${request.url || request.id}`);\n    }\n    \n    // Create GitHub issue for the paper\n    const createdPaper = await createGithubIssue(paperData);\n    \n    return { success: true, paperData: createdPaper };\n  } catch (error) {\n    logger.error(`Error tracking paper: ${error}`);\n    throw error;\n  }\n}\n\nasync function handleUpdateRating(rating, sendResponse) {\n  if (!paperManager) {\n    sendResponse({ success: false, error: 'Paper manager not initialized' });\n    return;\n  }\n\n  if (!currentPaperData) {\n    sendResponse({ success: false, error: 'No current paper' });\n    return;\n  }\n\n  try {\n    // Always use primary_id for rating updates\n    const paperId = currentPaperData.primary_id;\n    await paperManager.updateRating(paperId, rating, currentPaperData);\n    currentPaperData.rating = rating;\n    sendResponse({ success: true });\n  } catch (error) {\n    logger.error('Error updating rating:', error);\n    sendResponse({ success: false, error: error.message });\n  }\n}\n\n// Consolidated setup for all navigation and tab listeners\nasync function setupListeners() {\n  logger.info('Setting up unified event listeners');\n  \n  // Get all supported hosts from plugins\n  const plugins = pluginRegistry.getAll();\n  \n  // Create host patterns from all plugins\n  const hostPatterns = [];\n  \n  for (const plugin of plugins) {\n    // Add all the plugin URL patterns if possible\n    try {\n      // Extract domain patterns from the plugin's URL patterns\n      for (const pattern of plugin.urlPatterns) {\n        const patternStr = pattern.toString();\n        // Extract domain from pattern - this is a simplified approach\n        const match = patternStr.match(/([a-zA-Z0-9.-]+)\\\\?\\.([a-zA-Z]+)/);\n        if (match) {\n          const domain = match[1];\n          const tld = match[2];\n          hostPatterns.push({ hostSuffix: `${domain}.${tld}` });\n        }\n      }\n    } catch (err) {\n      logger.error(`Error processing plugin URL patterns: ${err}`);\n    }\n  }\n  \n  // Add default patterns if we couldn't extract from plugins\n  if (hostPatterns.length === 0) {\n    hostPatterns.push(\n      { hostSuffix: 'arxiv.org' },\n      { hostSuffix: 'semanticscholar.org' },\n      { hostSuffix: 'doi.org' },\n      { hostSuffix: 'dl.acm.org' },\n      { hostSuffix: 'openreview.net' }\n    );\n  }\n  \n  logger.info(`Setting up navigation listener with patterns: ${JSON.stringify(hostPatterns)}`);\n  \n  // CONSOLIDATED LISTENER: Set up a single navigation listener with all hosts\n  chrome.webNavigation.onCompleted.addListener(handleUnifiedNavigation, { \n    url: hostPatterns\n  });\n  \n  // CONSOLIDATED LISTENER: Set up a single tab activation listener\n  chrome.tabs.onActivated.addListener(handleUnifiedTabActivation);\n  \n  // CONSOLIDATED LISTENER: Set up a single tab update listener\n  chrome.tabs.onUpdated.addListener(handleUnifiedTabUpdate);\n  \n  // Window focus changes\n  chrome.windows.onFocusChanged.addListener((windowId) => {\n    if (windowId === chrome.windows.WINDOW_ID_NONE) {\n      endCurrentSession();\n    }\n  });\n  \n  logger.info('All event listeners initialized');\n}\n\n// Helper function to find the appropriate plugin for a URL\nfunction findPluginForUrl(url) {\n  // Try using the plugin registry's dedicated method\n  const result = pluginRegistry.findForUrl(url);\n  if (result) {\n    return {\n      type: result.plugin.id,\n      id: result.id,\n      primary_id: result.plugin.formatId ? \n        result.plugin.formatId(result.id) : \n        formatPrimaryId(result.plugin.id, result.id),\n      plugin: result.plugin\n    };\n  }\n  \n  // Fall back to manual checking of all plugins\n  const plugins = pluginRegistry.getAll();\n  \n  for (const plugin of plugins) {\n    for (const pattern of plugin.urlPatterns) {\n      const match = url.match(pattern);\n      if (match) {\n        const id = plugin.extractId(url);\n        if (id) {\n          return {\n            type: plugin.id,\n            id: id,\n            primary_id: plugin.formatId ? plugin.formatId(id) : formatPrimaryId(plugin.id, id),\n            plugin: plugin\n          };\n        }\n      }\n    }\n  }\n  \n  // No plugin match\n  return null;\n}\n\n// Replace the handleUnifiedNavigation function\nasync function handleUnifiedNavigation(details) {\n  logger.info(`Unified navigation handler: ${details.url}`);\n  \n  try {\n    // Use enhanced detection service\n    const sourceInfo = await processNavigation(details);\n    \n    if (!sourceInfo) {\n      logger.info('Not a recognized paper URL');\n      return;\n    }\n    \n    logger.info(`Detected paper: ${sourceInfo.type}:${sourceInfo.id}`);\n    \n    // Check if tab is active\n    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n    if (tabs.length > 0 && tabs[0].id === details.tabId) {\n      // This is the active tab, handle as tab change\n      await handleTabChangeWithPlugins(tabs[0]);\n    } else {\n      // Process URL but don't start a session\n      const paperData = await fullyProcessUrl(details.url);\n      if (paperData) {\n        logger.info(`Processed paper data: ${paperData.title}`);\n      }\n    }\n  } catch (error) {\n    logger.error(`Error in navigation handler: ${error}`);\n  }\n}\n\nasync function handleUnifiedTabActivation(activeInfo) {\n  logger.info(`Unified tab activation handler: ${activeInfo.tabId}`);\n  const tab = await chrome.tabs.get(activeInfo.tabId);\n  \n  if (!tab.url || pendingUrls.has(tab.url)) {\n    logger.info(`Tab URL empty or already being processed: ${tab.url}`);\n    return;\n  }\n  \n  try {\n    // Mark URL as being processed\n    pendingUrls.add(tab.url);\n    \n    // Delegate to the appropriate handler\n    await handleTabChangeWithPlugins(tab);\n  } catch (error) {\n    logger.error(`Error in tab activation handler: ${error}`);\n  } finally {\n    setTimeout(() => {\n      pendingUrls.delete(tab.url);\n    }, 500);\n  }\n}\n\nasync function handleUnifiedTabUpdate(tabId, changeInfo, tab) {\n  if (changeInfo.status !== 'complete' || !tab.url || pendingUrls.has(tab.url)) {\n    return;\n  }\n  \n  logger.info(`Unified tab update handler: ${tab.url}`);\n  \n  try {\n    // Mark URL as being processed\n    pendingUrls.add(tab.url);\n    \n    // Delegate to the appropriate handler\n    await handleTabChangeWithPlugins(tab);\n  } catch (error) {\n    logger.error(`Error in tab update handler: ${error}`);\n  } finally {\n    setTimeout(() => {\n      pendingUrls.delete(tab.url);\n    }, 500);\n  }\n}\n\n// Replace the processPaperUrl function\nasync function processPaperUrl(url) {\n  logger.info(`Processing paper URL: ${url}`);\n  \n  try {\n    // Use the enhanced services for full processing\n    return await fullyProcessUrl(url);\n  } catch (error) {\n    logger.error(`Error processing paper URL: ${error}`);\n    return null;\n  }\n}\n\n// Replace the handleTabChangeWithPlugins function\nasync function handleTabChangeWithPlugins(tab) {\n  if (!tab.url) return;\n  \n  // Use enhanced detection service\n  const sourceInfo = await processTab(tab);\n  \n  if (!sourceInfo) {\n    logger.info('Not a recognized paper page, ending current session');\n    await endCurrentSession();\n    return;\n  }\n  // End any existing session\n  if (currentSession) {\n    logger.info('Ending existing session before starting new one');\n    await endCurrentSession();\n  }\n\n  // Process the paper URL with full metadata extraction\n  logger.info(`Processing paper URL: ${tab.url}`);\n  const paperData = await fullyProcessUrl(tab.url, tab.id);\n  \n  if (paperData) {\n    logger.info(`Starting new session for: ${paperData.primary_id}`);\n    \n    // Store current paper data\n    currentPaperData = paperData;\n    \n    // Create a new reading session\n    currentSession = new EnhancedReadingSession(paperData, sessionConfig);\n    \n    const metadata = currentSession.getMetadata();\n    logger.info('New session created:', metadata);\n    \n    // Start tracking reading time\n    startActivityTracking();\n    \n    // Create GitHub issue\n    logger.info(`Creating GitHub issue for: ${paperData.primary_id}`);\n    try {\n      await createGithubIssue(paperData);\n    } catch (error) {\n      logger.error(`Error creating GitHub issue: ${error}`);\n    }\n  }\n}\n\n\nasync function endCurrentSession() {\n  if (currentSession && currentPaperData) {\n    logger.info(`Ending session for: ${currentPaperData.primary_id}`);\n    const sessionData = currentSession.finalize();\n    if (sessionData) {\n      logger.info('Creating reading event:', sessionData);\n      await createReadingEvent(currentPaperData, sessionData);\n    }\n    currentSession = null;\n    currentPaperData = null;\n    stopActivityTracking();\n  }\n}\n\nfunction startActivityTracking() {\n  if (!activityInterval) {\n    logger.info('Starting activity tracking');\n    activityInterval = setInterval(() => {\n      if (currentSession) {\n        currentSession.update();\n      }\n    }, sessionConfig.activityUpdateInterval);\n  }\n}\n\nfunction stopActivityTracking() {\n  if (activityInterval) {\n    clearInterval(activityInterval);\n    activityInterval = null;\n  }\n}\n\n// Create reading event function for all sources\nasync function createReadingEvent(paperData, sessionData) {\n  if (!paperManager || !paperData) {\n    logger.error('Missing required data for creating reading event:', {\n      hasPaperManager: !!paperManager,\n      hasPaperData: !!paperData\n    });\n    return;\n  }\n\n  try {\n    // Always use primary_id for storage\n    if (!paperData.primary_id) {\n      logger.error('Paper data missing primary_id. This should not happen.');\n      return;\n    }\n    \n    const paperId = paperData.primary_id;\n    \n    await paperManager.logReadingSession(\n      paperId,\n      sessionData,\n      paperData\n    );\n    \n    logger.info('Reading session logged:', {\n      paperId: paperId,\n      sessionId: sessionData.session_id,\n      activeTime: sessionData.duration_seconds,\n      idleTime: sessionData.idle_seconds,\n      totalTime: sessionData.total_elapsed_seconds\n    });\n    \n  } catch (error) {\n    logger.error('Error logging reading session:', error);\n  }\n}\n\n// GitHub issue creation function\nasync function createGithubIssue(paperData) {\n  if (!paperManager) {\n    logger.error('Paper manager not initialized');\n    return null;\n  }\n\n  // Ensure paper has primary_id\n  if (!paperData.primary_id) {\n    if (paperData.source && paperData.sourceId) {\n      paperData.primary_id = formatPrimaryId(paperData.source, paperData.sourceId);\n    } else {\n      logger.error('Cannot create paper - no valid identifier');\n      return null;\n    }\n  }\n  \n  try {\n    logger.info(`Creating/getting paper issue: ${paperData.primary_id}`);\n    const existingPaper = await paperManager.getOrCreatePaper(paperData);\n    logger.info(`Paper metadata stored/retrieved: ${existingPaper.primary_id}`);\n    return existingPaper;\n  } catch (error) {\n    logger.error(`Error handling paper metadata: ${error}`, error);\n    return null;\n  }\n}\n\nasync function handleAnnotationUpdate(type, data) {\n  if (!paperManager) {\n    throw new Error('Paper manager not initialized');\n  }\n\n  try {\n    // Ensure we have a valid paper ID\n    let paperId = data.paperId;\n    \n    // If we get a legacy ID without the source prefix, try to determine the source from context\n    if (!paperId.includes('.')) {\n      // Try to determine source from data\n      const source = data.source || 'arxiv'; // Default to arxiv if not specified\n      paperId = formatPrimaryId(source, paperId);\n      logger.info(`Converted ID to standardized format: ${paperId}`);\n    }\n    \n    const paperData = data.title ? {\n      title: data.title,\n      source: data.source,\n      primary_id: paperId\n    } : undefined;\n\n    if (type === 'vote') {\n      await paperManager.updateRating(\n        paperId,\n        data.vote,\n        paperData\n      );\n    } else {\n      await paperManager.logAnnotation(\n        paperId,\n        'notes',\n        data.notes,\n        paperData\n      );\n    }\n\n    return { success: true };\n  } catch (error) {\n    logger.error('Error logging interaction:', error);\n    throw error;\n  }\n}\n\n// Initialize debug objects in service worker scope\nfunction initializeDebugObjects() {\n  // Don't use window in service worker context\n  self.__DEBUG__ = {\n    get paperManager() { return paperManager; },\n    getGithubClient: () => paperManager?.client,\n    getCurrentPaper: () => currentPaperData,\n    getCurrentSession: () => currentSession,\n    getConfig: () => sessionConfig\n  };\n\n  logger.info('Debug objects registered, access via __DEBUG__ in service worker console');\n}\n"],"names":["logger","title","authors","authorElements","abstract","categories","categoryElements","getMetaContent","metaTitle","docTitle","publicationDate","conferenceTitle","pdfUrl","sourceSpecificMetadata","finalTitle","content","GitHubStoreClient"],"mappings":"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","x_google_ignoreList":[0]}