{"version":3,"mappings":"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","names":["formatPrimaryId","paperData","processPaperUrl","processUrl","logger","GitHubStoreClient"],"ignoreList":[0],"sources":["../node_modules/gh-store-client/dist/index.mjs","../papers/types.ts","../papers/source_utils.ts","../papers/manager.ts","../config/session.js","../papers/detector.ts","../papers/process_paper_url.ts","../background_multi_source.js","../utils/logger.ts","../papers/plugins/registry.ts","../papers/plugins/loader.ts","../background.js"],"sourcesContent":["var d=class{constructor(e={}){this.cache=new Map,this.maxSize=e.maxSize??1e3,this.ttl=e.ttl??1e3*60*60,this.accessOrder=[]}get(e){let s=this.cache.get(e);if(s){if(Date.now()-s.lastAccessed>this.ttl){this.cache.delete(e),this.removeFromAccessOrder(e);return}return s.lastAccessed=Date.now(),this.updateAccessOrder(e),s.issueNumber}}set(e,s,t){if(this.cache.size>=this.maxSize&&!this.cache.has(e)){let r=this.accessOrder[this.accessOrder.length-1];r&&(this.cache.delete(r),this.removeFromAccessOrder(r))}this.cache.set(e,{issueNumber:s,lastAccessed:Date.now(),createdAt:t.createdAt,updatedAt:t.updatedAt}),this.updateAccessOrder(e)}remove(e){this.cache.delete(e),this.removeFromAccessOrder(e)}clear(){this.cache.clear(),this.accessOrder=[]}getStats(){return{size:this.cache.size,maxSize:this.maxSize,ttl:this.ttl}}shouldRefresh(e,s){let t=this.cache.get(e);return t?s>t.updatedAt:!0}updateAccessOrder(e){this.removeFromAccessOrder(e),this.accessOrder.unshift(e)}removeFromAccessOrder(e){let s=this.accessOrder.indexOf(e);s>-1&&this.accessOrder.splice(s,1)}};var l=\"0.3.2\";var f=class{constructor(e,s,t={}){this.token=e,this.repo=s,this.config={baseLabel:t.baseLabel??\"stored-object\",uidPrefix:t.uidPrefix??\"UID:\",reactions:{processed:t.reactions?.processed??\"+1\",initialState:t.reactions?.initialState??\"rocket\"}},this.cache=new d(t.cache)}async fetchFromGitHub(e,s={}){let t=new URL(`https://api.github.com/repos/${this.repo}${e}`);s.params&&(Object.entries(s.params).forEach(([i,a])=>{t.searchParams.append(i,a)}),delete s.params);let r=await fetch(t.toString(),{...s,headers:{Authorization:`token ${this.token}`,Accept:\"application/vnd.github.v3+json\",...s.headers}});if(!r.ok)throw new Error(`GitHub API error: ${r.status}`);return r.json()}createCommentPayload(e,s){let t={_data:e,_meta:{client_version:l,timestamp:new Date().toISOString(),update_mode:\"append\"}};return s&&(t.type=s),t}async getObject(e){let s=this.cache.get(e),t;if(s)try{t=await this.fetchFromGitHub(`/issues/${s}`),this._verifyIssueLabels(t,e)||(this.cache.remove(e),t=void 0)}catch{this.cache.remove(e)}if(!t){let c=await this.fetchFromGitHub(\"/issues\",{method:\"GET\",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(\",\"),state:\"closed\"}});if(!c||c.length===0)throw new Error(`No object found with ID: ${e}`);t=c[0]}if(!t?.body)throw new Error(`Invalid issue data received for ID: ${e}`);let r=JSON.parse(t.body),i=new Date(t.created_at),a=new Date(t.updated_at);return this.cache.set(e,t.number,{createdAt:i,updatedAt:a}),{meta:{objectId:e,label:`${this.config.uidPrefix}${e}`,createdAt:i,updatedAt:a,version:await this._getVersion(t.number)},data:r}}async createObject(e,s){let t=`${this.config.uidPrefix}${e}`,r=await this.fetchFromGitHub(\"/issues\",{method:\"POST\",body:JSON.stringify({title:`Stored Object: ${e}`,body:JSON.stringify(s,null,2),labels:[this.config.baseLabel,t]})});this.cache.set(e,r.number,{createdAt:new Date(r.created_at),updatedAt:new Date(r.updated_at)});let i=this.createCommentPayload(s,\"initial_state\"),a=await this.fetchFromGitHub(`/issues/${r.number}/comments`,{method:\"POST\",body:JSON.stringify({body:JSON.stringify(i,null,2)})});return await this.fetchFromGitHub(`/issues/comments/${a.id}/reactions`,{method:\"POST\",body:JSON.stringify({content:this.config.reactions.processed})}),await this.fetchFromGitHub(`/issues/comments/${a.id}/reactions`,{method:\"POST\",body:JSON.stringify({content:this.config.reactions.initialState})}),await this.fetchFromGitHub(`/issues/${r.number}`,{method:\"PATCH\",body:JSON.stringify({state:\"closed\"})}),{meta:{objectId:e,label:t,createdAt:new Date(r.created_at),updatedAt:new Date(r.updated_at),version:1},data:s}}_verifyIssueLabels(e,s){let t=new Set([this.config.baseLabel,`${this.config.uidPrefix}${s}`]);return e.labels.some(r=>t.has(r.name))}async updateObject(e,s){let t=await this.fetchFromGitHub(\"/issues\",{method:\"GET\",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(\",\"),state:\"all\"}});if(!t||t.length===0)throw new Error(`No object found with ID: ${e}`);let r=t[0],i=this.createCommentPayload(s);return await this.fetchFromGitHub(`/issues/${r.number}/comments`,{method:\"POST\",body:JSON.stringify({body:JSON.stringify(i,null,2)})}),await this.fetchFromGitHub(`/issues/${r.number}`,{method:\"PATCH\",body:JSON.stringify({state:\"open\"})}),this.getObject(e)}async listAll(){let e=await this.fetchFromGitHub(\"/issues\",{method:\"GET\",params:{labels:this.config.baseLabel,state:\"closed\"}}),s={};for(let t of e)if(!t.labels.some(r=>r.name===\"archived\"))try{let r=this._getObjectIdFromLabels(t),i=JSON.parse(t.body),a={objectId:r,label:r,createdAt:new Date(t.created_at),updatedAt:new Date(t.updated_at),version:await this._getVersion(t.number)};s[r]={meta:a,data:i}}catch{continue}return s}async listUpdatedSince(e){let s=await this.fetchFromGitHub(\"/issues\",{method:\"GET\",params:{labels:this.config.baseLabel,state:\"closed\",since:e.toISOString()}}),t={};for(let r of s)if(!r.labels.some(i=>i.name===\"archived\"))try{let i=this._getObjectIdFromLabels(r),a=JSON.parse(r.body),n=new Date(r.updated_at);if(n>e){let c={objectId:i,label:i,createdAt:new Date(r.created_at),updatedAt:n,version:await this._getVersion(r.number)};t[i]={meta:c,data:a}}}catch{continue}return t}async getObjectHistory(e){let s=await this.fetchFromGitHub(\"/issues\",{method:\"GET\",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(\",\"),state:\"all\"}});if(!s||s.length===0)throw new Error(`No object found with ID: ${e}`);let t=s[0],r=await this.fetchFromGitHub(`/issues/${t.number}/comments`),i=[];for(let a of r)try{let n=JSON.parse(a.body),c=\"update\",m,b={client_version:\"legacy\",timestamp:a.created_at,update_mode:\"append\"};typeof n==\"object\"?\"_data\"in n?(c=n.type||\"update\",m=n._data,b=n._meta||b):\"type\"in n&&n.type===\"initial_state\"?(c=\"initial_state\",m=n.data):m=n:m=n,i.push({timestamp:a.created_at,type:c,data:m,commentId:a.id})}catch{continue}return i}async _getVersion(e){return(await this.fetchFromGitHub(`/issues/${e}/comments`)).length+1}_getObjectIdFromLabels(e){for(let s of e.labels)if(s.name!==this.config.baseLabel&&s.name.startsWith(this.config.uidPrefix))return s.name.slice(this.config.uidPrefix.length);throw new Error(`No UID label found with prefix ${this.config.uidPrefix}`)}};var u={baseLabel:\"stored-object\",uidPrefix:\"UID:\",reactions:{processed:\"+1\",initialState:\"rocket\"},retries:{maxAttempts:3,backoffFactor:2},rateLimit:{maxRequestsPerHour:1e3}};function _(o){return{...u,...o,reactions:{...u.reactions,...o.reactions},retries:{...u.retries,...o.retries},rateLimit:{...u.rateLimit,...o.rateLimit}}}function v(o){return/^gh[ps]_[a-zA-Z0-9]{36}$/.test(o)}function P(o){return/^[\\w-]+\\/[\\w-]+$/.test(o)}var h=class extends Error{constructor(e){super(e),this.name=\"ConfigError\"}},g=class extends h{constructor(e=\"Invalid GitHub token format\"){super(e),this.name=\"TokenError\"}},p=class extends h{constructor(e=\"Invalid repository format. Use owner/repo\"){super(e),this.name=\"RepoError\"}};export{h as ConfigError,u as DEFAULT_CONFIG,f as GitHubStoreClient,p as RepoError,g as TokenError,_ as mergeConfig,P as validateRepo,v as validateToken};\n//# sourceMappingURL=index.mjs.map","// extension/papers/types.ts\nimport type { Json } from 'gh-store-client';\n\n/**\n * Paper metadata with multi-source support\n */\nexport type PaperMetadata = {\n  // Legacy fields (for backward compatibility)\n  arxivId?: string;\n  arxiv_tags?: string[];\n  \n  // Multi-source fields\n  primary_id?: string;  // {source}:{id} format\n  source?: string;      // Source type (arxiv, doi, semanticscholar, etc.)\n  sourceId?: string;    // Original ID from the source\n  \n  // Common fields\n  url: string;\n  title: string;\n  authors: string;\n  abstract: string;\n  timestamp: string;\n  published_date: string;\n  rating: string;\n  \n  // Source-specific identifiers\n  identifiers?: {\n    original: string;\n    url: string;\n    // Fix for TS2411: Using string index signature\n    [key: string]: string;\n  };\n}\n\n/**\n * Reading session data\n */\nexport type ReadingSessionData = {\n  session_id: string;\n  duration_seconds: number;\n  idle_seconds: number;\n  start_time: string;\n  end_time: string;\n  total_elapsed_seconds: number;\n}\n\n/**\n * Interaction record\n */\nexport type Interaction = {\n  type: string;\n  timestamp: string;\n  data: Json;\n}\n\n/**\n * Interaction log\n */\nexport type InteractionLog = {\n  paper_id: string;\n  legacy_id?: string; // For backward compatibility\n  interactions: Interaction[];\n}\n\n/**\n * Type guard for reading session data\n */\nexport const isReadingSession = (data: unknown): data is ReadingSessionData => {\n  const session = data as ReadingSessionData;\n  return (\n    typeof session === 'object' &&\n    session !== null &&\n    typeof session.session_id === 'string' &&\n    typeof session.duration_seconds === 'number' &&\n    typeof session.idle_seconds === 'number' &&\n    typeof session.start_time === 'string' &&\n    typeof session.end_time === 'string' &&\n    typeof session.total_elapsed_seconds === 'number'\n  );\n};\n\n/**\n * Type guard for interaction log\n */\nexport const isInteractionLog = (data: unknown): data is InteractionLog => {\n  const log = data as InteractionLog;\n  return (\n    typeof log === 'object' &&\n    log !== null &&\n    typeof log.paper_id === 'string' &&\n    Array.isArray(log.interactions)\n  );\n};\n\n/**\n * Paper source information\n */\nexport type SourceInfo = {\n  type: string;\n  id: string;\n  primary_id: string;\n  url: string;\n}\n\n/**\n * Extended reading session with multi-source support\n */\nexport class MultiSourceReadingSession {\n  // In legacy version, this was arxivId\n  paperId: string;\n  sessionId: string;\n  startTime: Date;\n  activeTime: number;\n  idleTime: number;\n  lastActiveTime: Date;\n  isTracking: boolean;\n  config: any;\n  endTime: Date | null;\n  finalizedData: ReadingSessionData | null;\n  \n  constructor(paperId: string, config: any) {\n    this.paperId = paperId;\n    this.sessionId = `session_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n    this.startTime = new Date();\n    this.activeTime = 0;\n    this.idleTime = 0;\n    this.lastActiveTime = new Date();\n    this.isTracking = true;\n    this.config = config;\n    this.endTime = null;\n    this.finalizedData = null;\n  }\n  \n  // Rest of the methods remain the same as ReadingSession\n  update() {\n    if (this.isTracking && !this.finalizedData) {\n      const now = new Date();\n      const timeSinceLastActive = now.getTime() - this.lastActiveTime.getTime();\n      \n      if (timeSinceLastActive < this.config.idleThreshold) {\n        this.activeTime += timeSinceLastActive;\n      } else {\n        this.idleTime += timeSinceLastActive;\n      }\n      \n      this.lastActiveTime = now;\n    }\n  }\n  \n  finalize() {\n    if (this.finalizedData) {\n      return this.finalizedData;\n    }\n \n    this.update();\n    this.isTracking = false;\n    this.endTime = new Date();\n    const totalElapsed = this.endTime.getTime() - this.startTime.getTime();\n \n    if (this.activeTime >= this.config.minSessionDuration) {\n      this.finalizedData = {\n        session_id: this.sessionId,\n        duration_seconds: Math.round(this.activeTime / 1000),\n        idle_seconds: Math.round(this.idleTime / 1000),\n        start_time: this.startTime.toISOString(),\n        end_time: this.endTime.toISOString(),\n        total_elapsed_seconds: Math.round(totalElapsed / 1000)\n      };\n      return this.finalizedData;\n    }\n    return null;\n  }\n  \n  end() {\n    return this.finalize();\n  }\n  \n  getMetadata() {\n    return {\n      sessionId: this.sessionId,\n      startTime: this.startTime.toISOString(),\n      activeSeconds: Math.round(this.activeTime / 1000),\n      idleSeconds: Math.round(this.idleTime / 1000)\n    };\n  }\n}\n\n// extension/papers/types.ts\n\nexport interface UnifiedPaperData {\n  // Core fields required for all sources\n  primary_id: string;  // Standardized ID format: {source}.{id}\n  source: string;      // Source identifier (arxiv, doi, semanticscholar, etc.)\n  sourceId: string;    // Original ID from the source\n  url: string;         // Paper URL\n  title: string;       // Paper title\n  authors: string;     // Author list as string\n  abstract: string;    // Paper abstract\n  timestamp: string;   // When the paper was first tracked\n  rating: string;      // User rating (thumbsup, thumbsdown, novote)\n  \n  // Legacy support fields\n  arxivId?: string;            // For backward compatibility\n  published_date?: string;     // Publication date\n  arxiv_tags?: string[];       // ArXiv categories\n  \n  // Source-specific fields\n  // Fix for TS2411: Using string index signature\n  // doi?: string;                // DOI string for DOI and ACM sources\n  identifiers?: {              // Cross-reference identifiers\n    // original: string;          // Original ID from the source\n    // url: string;               // Canonical URL\n    // arxiv?: string;            // ArXiv ID\n    // doi?: string;              // DOI reference\n    // s2?: string;               // Semantic Scholar ID\n    // acm?: string;              // ACM ID\n    // openreview?: string;       // OpenReview ID\n    [key: string]: string;     // Other identifier types\n };\n \n // // Metadata fields\n // citations?: number;          // Citation count\n // journal?: string;            // Journal name\n // conference?: string;         // Conference name\n // volume?: string;             // Journal volume\n // issue?: string;              // Journal issue\n // pages?: string;              // Page numbers\n // publisher?: string;          // Publisher name\n \n // Custom source-specific fields\n // conferenceInfo?: {           // Enhanced conference information\n //   name: string;              // Conference name\n //   year: number;              // Year\n //   location: string;          // Location\n //   abbreviation?: string;     // Conference abbreviation (e.g., \"ICLR\")\n // };\n \n // Allow for extension with string indexing\n // Fix for TS2411: Using string index signature\n source_specific_metadata?: {\n  [key: string]: any;\n };\n}\n","// extension/papers/source_utils.ts\n// Utilities for supporting multiple paper sources while maintaining compatibility\n\nimport { SourceInfo } from './types';\n\n// Source type definitions\ninterface SourceTypeDefinition {\n  prefix: string;\n  url_patterns: RegExp[];\n  id_extractors: ((match: RegExpMatchArray) => string)[];\n  id_format?: RegExp;\n}\n\nconst SOURCE_TYPES: Record<string, SourceTypeDefinition> = {\n  'arxiv': {\n    prefix: 'arxiv',\n    url_patterns: [\n      /arxiv\\.org\\/(abs|pdf|html)\\/([0-9.]+)/,\n      /arxiv\\.org\\/abs\\/([0-9.]+)(v[0-9]+)?/\n    ],\n    id_extractors: [\n      (match) => match[2],\n      (match) => match[1] + (match[2] || '')\n    ],\n    id_format: /[0-9]{4}\\.[0-9]{4,5}(v[0-9]+)?/\n  },\n  'semanticscholar': {\n    prefix: 's2',\n    url_patterns: [\n      /semanticscholar\\.org\\/paper\\/([a-f0-9]+)/,\n      /s2-research\\.org\\/papers\\/([a-f0-9]+)/\n    ],\n    id_extractors: [\n      (match) => match[1],\n      (match) => match[1]\n    ],\n    id_format: /[a-f0-9]{40}/\n  },\n  'doi': {\n    prefix: 'doi',\n    url_patterns: [\n      /doi\\.org\\/(10\\.[0-9.]+\\/[a-zA-Z0-9._\\-/:()\\[\\]]+)/\n    ],\n    id_extractors: [\n      (match) => match[1]\n    ],\n    id_format: /10\\.[0-9.]+\\/[a-zA-Z0-9._\\-/:()\\[\\]]+/\n  },\n  'acm': {\n    prefix: 'doi',  // ACM uses DOIs\n    url_patterns: [\n      /dl\\.acm\\.org\\/doi\\/(10\\.[0-9.]+\\/[a-zA-Z0-9._\\-/:()\\[\\]]+)/\n    ],\n    id_extractors: [\n      (match) => match[1]\n    ],\n    id_format: /10\\.[0-9.]+\\/[a-zA-Z0-9._\\-/:()\\[\\]]+/\n  },\n  'openreview': {\n    prefix: 'openreview',\n    url_patterns: [\n      /openreview\\.net\\/forum\\?id=([a-zA-Z0-9_\\-]+)/,\n      // Add support for PDF links on OpenReview\n      /openreview\\.net\\/pdf\\?id=([a-zA-Z0-9_\\-]+)/\n    ],\n    id_extractors: [\n      (match) => match[1],\n      (match) => match[1]\n    ],\n    id_format: /[a-zA-Z0-9_\\-]+/\n  }\n};\n\n/**\n * Format a source-specific ID into a universal primary ID format\n * \n * @param {string} source - Source type (e.g. 'arxiv', 'doi')\n * @param {string} id - Original source-specific identifier\n * @returns {string} Formatted primary ID\n */\nexport function formatPrimaryId(source: string, id: string): string {\n  // Use source-specific prefixes\n  const sourcePrefix = SOURCE_TYPES[source]?.prefix || 'generic';\n  \n  // Sanitize the ID by replacing problematic characters\n  const safeId = id\n    .replace(/\\//g, '_')\n    .replace(/:/g, '.')\n    .replace(/\\s/g, '_')\n    .replace(/\\\\/g, '_');\n  \n  return `${sourcePrefix}.${safeId}`;\n}\n\n/**\n * Parse a primary ID into its source type and original source ID\n * \n * @param {string} prefixedId - The primary ID in the format \"{source_prefix}.{id}\"\n * @returns {Object} Object with source type and source ID\n */\nexport function parseId(prefixedId: string): { type: string; id: string } {\n  // Split at the first dot\n  const [prefix, ...idParts] = prefixedId.split('.');\n  const id = idParts.join('.'); // Rejoin in case ID contains periods\n  \n  // Map prefix to source type\n  const prefixToSource: Record<string, string> = {\n    'arxiv': 'arxiv',\n    's2': 'semanticscholar',\n    'doi': 'doi',\n    'openreview': 'openreview'\n  };\n  \n  return {\n    type: prefixToSource[prefix] || 'generic',\n    id: prefix === 'doi' ? id.replace(/_/g, '/') : id\n  };\n}\n\n/**\n * Get a legacy-compatible ID (for backward compatibility)\n * \n * @param {string} primaryId - The primary ID (can be prefixed or legacy)\n * @returns {string} Legacy-compatible ID\n */\nexport function getLegacyId(primaryId: string): string {\n  // If there's no prefix, assume it's already a legacy ID\n  if (!primaryId.includes('.')) {\n    return primaryId;\n  }\n  \n  const { type, id } = parseId(primaryId);\n  \n  // For arXiv, return just the ID (backward compatible)\n  if (type === 'arxiv') {\n    return id;\n  }\n  \n  // For other sources, use the full prefixed ID to avoid collisions with arXiv IDs\n  return primaryId;\n}\n\n/**\n * Detect paper source and ID from URL\n * \n * @param {string} url - URL to detect source from\n * @returns {SourceInfo|null} Source information or null if not detected\n */\nexport function detectSourceFromUrl(url: string): SourceInfo | null {\n  // Check each source type\n  for (const [sourceType, definition] of Object.entries(SOURCE_TYPES)) {\n    for (let i = 0; i < definition.url_patterns.length; i++) {\n      const match = url.match(definition.url_patterns[i]);\n      if (match) {\n        const id = definition.id_extractors[i](match);\n        return {\n          type: sourceType,\n          id: id,\n          primary_id: formatPrimaryId(sourceType, id),\n          url: url\n        };\n      }\n    }\n  }\n  \n  return null;\n}\n\n/**\n * Checks if a string is in the new prefixed format\n * \n * @param {string} id - ID to check\n * @returns {boolean} True if the ID is in the new format\n */\nexport function isNewFormat(id: string): boolean {\n  // Check if it has a valid prefix\n  const validPrefixes = Object.values(SOURCE_TYPES).map(def => `${def.prefix}.`);\n  validPrefixes.push('generic.'); // Add generic prefix\n  \n  return validPrefixes.some(prefix => id.startsWith(prefix));\n}\n\n/**\n * Gets a display label for a source type\n * \n * @param {string} sourceType - Source type\n * @returns {string} Human-readable label\n */\nexport function getSourceLabel(sourceType: string): string {\n  const labels: Record<string, string> = {\n    'arxiv': 'arXiv',\n    'semanticscholar': 'Semantic Scholar',\n    'doi': 'DOI',\n    'acm': 'ACM Digital Library',\n    'openreview': 'OpenReview'\n  };\n  \n  return labels[sourceType] || sourceType.charAt(0).toUpperCase() + sourceType.slice(1);\n}\n\n/**\n * Validate if an ID matches the expected format for its source\n * \n * @param {string} sourceType - Source type\n * @param {string} id - Source ID\n * @returns {boolean} Whether the ID is valid\n */\nexport function validateSourceId(sourceType: string, id: string): boolean {\n  const definition = SOURCE_TYPES[sourceType];\n  if (!definition || !definition.id_format) {\n    return true; // If no format is defined, assume valid\n  }\n  \n  return definition.id_format.test(id);\n}\n\n/**\n * Get canonical URL for a paper\n * \n * @param {string} sourceType - Source type\n * @param {string} id - Source ID\n * @returns {string} Canonical URL\n */\nexport function getCanonicalUrl(sourceType: string, id: string): string {\n  switch (sourceType) {\n    case 'arxiv':\n      return `https://arxiv.org/abs/${id}`;\n    case 'semanticscholar':\n      return `https://www.semanticscholar.org/paper/${id}`;\n    case 'doi':\n      return `https://doi.org/${id}`;\n    case 'acm':\n      return `https://dl.acm.org/doi/${id}`;\n    case 'openreview':\n      return `https://openreview.net/forum?id=${id}`;\n    default:\n      return id.startsWith('10.') ? `https://doi.org/${id}` : \"\";\n  }\n}\n","// extension/papers/manager.ts\nimport { GitHubStoreClient } from 'gh-store-client';\nimport type { Json } from 'gh-store-client';\nimport { \n  type PaperMetadata, \n  type InteractionLog, \n  type Interaction,\n  type ReadingSessionData,\n  isInteractionLog\n} from './types';\nimport { formatPrimaryId, getLegacyId, isNewFormat } from './source_utils';\n\n/**\n * Checks if data is an interaction log\n * @param data - Data to check\n * @returns Whether data is an interaction log\n */\nconst isInteractionLogJs = (data: any): boolean => {\n  return typeof data === \"object\" && \n         data !== null && \n         typeof data.paper_id === \"string\" && \n         Array.isArray(data.interactions);\n};\n\nexport class PaperManager {\n  constructor(private client: GitHubStoreClient) {}\n\n  /**\n   * Get or create a paper record\n   * Enhanced to support multiple sources with backward compatibility\n   */\n  async getOrCreatePaper(paperData: any): Promise<any> {\n    // Determine the object ID to use with backward compatibility\n    let objectId: string;\n    let useNewFormat = false;\n    \n    // Enhanced to handle both legacy and new format\n    if (paperData.primary_id) {\n      // New format with source prefix\n      objectId = `paper:${paperData.primary_id}`;\n      useNewFormat = true;\n    } else if (paperData.source && paperData.sourceId) {\n      // New source fields but without primary_id\n      const primary_id = formatPrimaryId(paperData.source, paperData.sourceId);\n      paperData.primary_id = primary_id;\n      objectId = `paper:${primary_id}`;\n      useNewFormat = true;\n    } else if (paperData.arxivId) {\n      // Legacy arXiv ID format\n      objectId = `paper:${paperData.arxivId}`;\n      \n      // For legacy compatibility, don't add new fields yet\n      useNewFormat = false;\n    } else {\n      throw new Error(\"Invalid paper data: missing ID information\");\n    }\n    \n    try {\n      // Try to get the paper\n      const obj = await this.client.getObject(objectId);\n      const data = obj.data as Record<string, any>;\n      \n      // Return object, potentially enhancing it with new format fields\n      if (!useNewFormat || data.primary_id) {\n        return data;\n      }\n      \n      // Add new format fields to legacy data if needed\n      if (data.arxivId && !data.primary_id) {\n        const enhancedData = {\n          ...data,\n          source: 'arxiv',\n          sourceId: data.arxivId,\n          primary_id: formatPrimaryId('arxiv', data.arxivId)\n        };\n        \n        // Update the object with enhanced data\n        await this.client.updateObject(objectId, enhancedData);\n        return enhancedData;\n      }\n      \n      return data;\n    } catch (error) {\n      if (error instanceof Error && error.message.includes(\"No object found\")) {\n        // Create new paper with appropriate fields\n        let defaultPaperData: Record<string, any>;\n        \n        if (useNewFormat) {\n          // New multi-source format\n          defaultPaperData = {\n            primary_id: paperData.primary_id,\n            source: paperData.source,\n            sourceId: paperData.sourceId,\n            url: paperData.url || '',\n            title: paperData.title || paperData.sourceId,\n            authors: paperData.authors || '',\n            abstract: paperData.abstract || '',\n            timestamp: new Date().toISOString(),\n            rating: 'novote'\n          };\n          \n          // For arXiv, maintain backward compatibility\n          if (paperData.source === 'arxiv') {\n            defaultPaperData.arxivId = paperData.sourceId;\n            defaultPaperData.arxiv_tags = paperData.arxiv_tags || [];\n            defaultPaperData.published_date = paperData.published_date || '';\n          } else {\n            // For other sources, add source-specific identifiers\n            defaultPaperData.identifiers = {\n              original: paperData.sourceId,\n              url: paperData.url\n            };\n            \n            // Add cross-references if available\n            if (paperData.arxivId) {\n              defaultPaperData.identifiers.arxiv = paperData.arxivId;\n            }\n            if (paperData.doi) {\n              defaultPaperData.identifiers.doi = paperData.doi;\n            }\n            if (paperData.s2Id) {\n              defaultPaperData.identifiers.s2 = paperData.s2Id;\n            }\n          }\n        } else {\n          // Legacy format for backward compatibility\n          defaultPaperData = {\n            arxivId: paperData.arxivId,\n            url: paperData.url || `https://arxiv.org/abs/${paperData.arxivId}`,\n            title: paperData.title || paperData.arxivId,\n            authors: paperData.authors || '',\n            abstract: paperData.abstract || '',\n            timestamp: new Date().toISOString(),\n            rating: 'novote',\n            published_date: paperData.published_date || '',\n            arxiv_tags: paperData.arxiv_tags || []\n          };\n        }\n\n        await this.client.createObject(objectId, defaultPaperData);\n        return defaultPaperData;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Get or create an interaction log\n   * Enhanced with backward compatibility for legacy arXiv IDs\n   */\n  private async getOrCreateInteractionLog(paperId: string): Promise<InteractionLog> {\n    // For backward compatibility, use legacy ID format for storage\n    const legacyId = getLegacyId(paperId);\n    const objectId = `interactions:${legacyId}`;\n    \n    try {\n      const obj = await this.client.getObject(objectId);\n      const data = obj.data as unknown;\n      \n      // Use TypeScript type guard if available, otherwise JS version\n      if (typeof isInteractionLog === 'function' ? \n          isInteractionLog(data) : \n          isInteractionLogJs(data)) {\n        return data as InteractionLog;\n      }\n      \n      throw new Error('Invalid interaction log format');\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('No object found')) {\n        // Create new log\n        const newLog: InteractionLog = {\n          paper_id: paperId,  // Store the full ID including prefix if present\n          interactions: []\n        };\n        \n        // For backward compatibility, also add legacy_id if different\n        if (paperId !== legacyId) {\n          (newLog as any).legacy_id = legacyId;\n        }\n        \n        await this.client.createObject(objectId, newLog);\n        return newLog;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Log a reading session for a paper\n   * Enhanced to work with both legacy and new IDs\n   */\n  async logReadingSession(\n    paperId: string,\n    session: ReadingSessionData,\n    paperData?: any\n  ): Promise<void> {\n    // For backward compatibility\n    let primaryId = paperId;\n    let enhancedPaperData: Record<string, any> = paperData || {};\n    \n    // Handle legacy arXiv IDs\n    if (!isNewFormat(paperId) && !enhancedPaperData.primary_id) {\n      primaryId = formatPrimaryId('arxiv', paperId);\n      enhancedPaperData = {\n        ...enhancedPaperData,\n        source: 'arxiv',\n        sourceId: paperId,\n        primary_id: primaryId,\n        arxivId: paperId\n      };\n    }\n\n    // Ensure paper exists with proper data\n    if (Object.keys(enhancedPaperData).length > 0) {\n      await this.getOrCreatePaper(enhancedPaperData);\n    }\n\n    // Log the session as interaction\n    await this.addInteraction(paperId, {\n      type: \"reading_session\",\n      timestamp: new Date().toISOString(),\n      data: session\n    });\n  }\n\n  /**\n   * Log an annotation for a paper\n   * Enhanced to work with both legacy and new IDs\n   */\n  async logAnnotation(\n    paperId: string,\n    key: string,\n    value: Json,\n    paperData?: any\n  ): Promise<void> {\n    // For backward compatibility\n    let primaryId = paperId;\n    let enhancedPaperData: Record<string, any> = paperData || {};\n    \n    // Handle legacy arXiv IDs\n    if (!isNewFormat(paperId) && !enhancedPaperData.primary_id) {\n      primaryId = formatPrimaryId('arxiv', paperId);\n      enhancedPaperData = {\n        ...enhancedPaperData,\n        source: 'arxiv',\n        sourceId: paperId,\n        primary_id: primaryId,\n        arxivId: paperId\n      };\n    }\n\n    // Ensure paper exists with proper data\n    if (Object.keys(enhancedPaperData).length > 0) {\n      await this.getOrCreatePaper(enhancedPaperData);\n    }\n\n    // Log the annotation as interaction\n    await this.addInteraction(paperId, {\n      type: \"annotation\",\n      timestamp: new Date().toISOString(),\n      data: { key, value }\n    });\n  }\n\n  /**\n   * Update a paper's rating\n   * Enhanced to work with both legacy and new IDs\n   */\n  async updateRating(\n    paperId: string,\n    rating: string,\n    paperData?: any\n  ): Promise<void> {\n    // For backward compatibility\n    let primaryId = paperId;\n    let enhancedPaperData: Record<string, any> = paperData || {};\n    \n    // Handle legacy arXiv IDs\n    if (!isNewFormat(paperId) && !enhancedPaperData.primary_id) {\n      primaryId = formatPrimaryId('arxiv', paperId);\n      enhancedPaperData = {\n        ...enhancedPaperData,\n        source: 'arxiv',\n        sourceId: paperId,\n        primary_id: primaryId,\n        arxivId: paperId\n      };\n    }\n\n    // Get existing paper data\n    const paper = await this.getOrCreatePaper(enhancedPaperData);\n\n    // Update rating\n    const objectId = isNewFormat(primaryId) ? \n      `paper:${primaryId}` : \n      `paper:${paperId}`; // For backward compatibility\n      \n    await this.client.updateObject(objectId, { \n      ...paper,\n      rating \n    });\n\n    // Log rating change\n    await this.addInteraction(paperId, {\n      type: \"rating\",\n      timestamp: new Date().toISOString(),\n      data: { rating }\n    });\n  }\n\n  /**\n   * Add an interaction to a paper's log\n   * Enhanced with backward compatibility\n   */\n  private async addInteraction(paperId: string, interaction: Interaction): Promise<void> {\n    const log = await this.getOrCreateInteractionLog(paperId);\n    log.interactions.push(interaction);\n    \n    // Use legacy ID for storage key to maintain backward compatibility\n    const legacyId = getLegacyId(paperId);\n    await this.client.updateObject(`interactions:${legacyId}`, log);\n  }\n\n  // Rest of the methods (getInteractions, getPaperReadingTime, etc.) can remain unchanged\n  // as they'll work with the enhanced getOrCreateInteractionLog method\n\n  async getInteractions(\n    paperId: string,\n    options: {\n      type?: string;\n      startTime?: Date;\n      endTime?: Date;\n    } = {}\n  ): Promise<Interaction[]> {\n    try {\n      const log = await this.getOrCreateInteractionLog(paperId);\n      let interactions = log.interactions;\n\n      if (options.type) {\n        interactions = interactions.filter((i: Interaction) => i.type === options.type);\n      }\n\n      if (options.startTime || options.endTime) {\n        interactions = interactions.filter((i: Interaction) => {\n          const time = new Date(i.timestamp);\n          if (options.startTime && time < options.startTime) return false;\n          if (options.endTime && time > options.endTime) return false;\n          return true;\n        });\n      }\n\n      return interactions;\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('No object found')) {\n        return [];\n      }\n      throw error;\n    }\n  }\n    \n  async getPaperReadingTime(paperId: string): Promise<number> {\n    const interactions = await this.getInteractions(paperId, { type: 'reading_session' });\n    return interactions.reduce((total, i) => {\n      console.log('Calculating from interaction:', i);\n      \n      const data = i.data;\n      if (typeof data === 'object' && data !== null && 'duration_seconds' in data) {\n        return total + (data.duration_seconds as number);\n      }\n      return total;\n    }, 0);\n  }\n\n  async getPaperHistory(paperId: string): Promise<Json[]> {\n    // Use legacy ID for backward compatibility\n    const objectId = `paper:${getLegacyId(paperId)}`;\n    return this.client.getObjectHistory(objectId);\n  }\n}\n","// extension/config/session.js\n\n// Default configuration values\nconst DEFAULT_CONFIG = {\n    idleThresholdMinutes: 5,\n    minSessionDurationSeconds: 30,\n    // Adding more granular control\n    requireContinuousActivity: true,  // If true, resets timer on idle\n    logPartialSessions: false,        // If true, logs sessions even if under minimum duration\n    activityUpdateIntervalSeconds: 1  // How often to update active time\n};\n\n// Load session configuration from storage\nasync function loadSessionConfig() {\n    const items = await chrome.storage.sync.get('sessionConfig');\n    return { ...DEFAULT_CONFIG, ...items.sessionConfig };\n}\n\n// Save session configuration to storage\nasync function saveSessionConfig(config) {\n    await chrome.storage.sync.set({\n        sessionConfig: {\n            idleThresholdMinutes: Number(config.idleThresholdMinutes),\n            minSessionDurationSeconds: Number(config.minSessionDurationSeconds),\n            requireContinuousActivity: Boolean(config.requireContinuousActivity),\n            logPartialSessions: Boolean(config.logPartialSessions),\n            activityUpdateIntervalSeconds: Number(config.activityUpdateIntervalSeconds)\n        }\n    });\n}\n\n// Convert configuration to milliseconds for internal use\nfunction getConfigurationInMs(config) {\n    return {\n        idleThreshold: config.idleThresholdMinutes * 60 * 1000,\n        minSessionDuration: config.minSessionDurationSeconds * 1000,\n        activityUpdateInterval: config.activityUpdateIntervalSeconds * 1000,\n        requireContinuousActivity: config.requireContinuousActivity,\n        logPartialSessions: config.logPartialSessions\n    };\n}\n\nexport { loadSessionConfig, saveSessionConfig, getConfigurationInMs, DEFAULT_CONFIG };","// extension/papers/detector.ts\n// Detector for academic paper URLs from multiple sources\n\nimport { formatPrimaryId, detectSourceFromUrl } from './source_utils';\nimport { SourceInfo } from './types';\n\n/**\n * Multi-source paper URL detector\n */\nexport class MultiSourceDetector {\n  /**\n   * Detect paper source and metadata from URL\n   * \n   * @param {string} url - URL to analyze\n   * @returns {SourceInfo|null} Paper source information or null if not detected\n   */\n  static detect(url: string): SourceInfo | null {\n    return detectSourceFromUrl(url);\n  }\n  \n  /**\n   * Process a URL to extract paper data\n   * This is an enhanced version of the original processArxivUrl function\n   * \n   * @param {string} url - URL to process\n   * @param {Function} existingProcessArxivUrl - The original arXiv processing function\n   * @returns {Promise<any|null>} Paper data or null if not detected/processed\n   */\n  static async processUrl(\n    url: string, \n    existingProcessArxivUrl?: (url: string) => Promise<any>\n  ): Promise<any | null> {\n    // First try to detect the source from URL\n    const sourceInfo = this.detect(url);\n    \n    if (!sourceInfo) {\n      // Fall back to the original arXiv processor if source not detected\n      return existingProcessArxivUrl ? existingProcessArxivUrl(url) : null;\n    }\n    \n    // ArXiv URLs should still use the original processor for full compatibility\n    if (sourceInfo.type === 'arxiv' && existingProcessArxivUrl) {\n      const paperData = await existingProcessArxivUrl(url);\n      \n      // Add new fields for multi-source support without breaking compatibility\n      if (paperData) {\n        paperData.source = 'arxiv';\n        paperData.sourceId = paperData.arxivId;\n        paperData.primary_id = formatPrimaryId('arxiv', paperData.arxivId);\n      }\n      \n      return paperData;\n    }\n    \n    // For non-arXiv sources, extract basic metadata\n    // This is a minimal implementation to get started\n    const { type, id, primary_id } = sourceInfo;\n    \n    const paperData: Record<string, any> = {\n      source: type,\n      sourceId: id,\n      primary_id: primary_id,\n      url: url,\n      title: `${type.toUpperCase()} Paper: ${id}`, // Generic title as placeholder\n      authors: '',\n      abstract: '',\n      timestamp: new Date().toISOString(),\n      rating: 'novote'\n    };\n    \n    // Try to extract metadata from page if tab is available\n    try {\n      // This functionality is implemented in process_paper_url.ts\n      // Will be added as part of the integration\n    } catch (error) {\n      console.error('Error extracting metadata:', error);\n    }\n    \n    return paperData;\n  }\n}\n","// extension/papers/process_paper_url.ts\n// Process paper URLs from multiple sources\n\nimport { MultiSourceDetector } from './detector';\nimport { SourceInfo } from './types';\n\n/**\n * Metadata extracted from a paper page\n */\ninterface PageMetadata {\n  title?: string;\n  authors?: string;\n  abstract?: string;\n  published_date?: string;\n  doi?: string;\n  url?: string;\n  citations?: number;\n}\n\n/**\n * Extract metadata from the current tab's page\n * \n * @param {number} tabId - Tab ID to extract metadata from\n * @returns {Promise<PageMetadata|null>} Extracted metadata or null\n */\nasync function extractMetadataFromPage(tabId: number): Promise<PageMetadata | null> {\n  try {\n    // Use chrome.scripting.executeScript instead of the deprecated chrome.tabs.executeScript\n    const results = await chrome.scripting.executeScript({\n      target: { tabId: tabId },\n      func: () => {\n        try {\n          // Helper function to safely get content from meta tags\n          const getMetaContent = (selector: string): string | undefined => {\n            const element = document.querySelector(selector);\n            return element && 'content' in element ? \n              (element as HTMLMetaElement).content : undefined;\n          };\n\n          // Try to extract from common meta tags first\n          const metadata: {\n            title?: string;\n            authors?: string;\n            abstract?: string;\n            published_date?: string;\n            doi?: string;\n            url?: string;\n            citations?: number | null;\n          } = {\n            title: getMetaContent('meta[name=\"citation_title\"]') ||\n                   getMetaContent('meta[property=\"og:title\"]') ||\n                   document.title,\n            authors: getMetaContent('meta[name=\"citation_author\"]') ||\n                     getMetaContent('meta[name=\"citation_authors\"]') ||\n                     getMetaContent('meta[name=\"author\"]'),\n            abstract: getMetaContent('meta[name=\"description\"]') ||\n                      getMetaContent('meta[property=\"og:description\"]') ||\n                      getMetaContent('meta[name=\"citation_abstract\"]'),\n            published_date: getMetaContent('meta[name=\"citation_publication_date\"]') ||\n                            getMetaContent('meta[name=\"citation_date\"]'),\n            doi: getMetaContent('meta[name=\"citation_doi\"]'),\n            url: getMetaContent('meta[property=\"og:url\"]') || window.location.href,\n            citations: null\n          };\n          \n          // Source-specific extraction fallbacks\n          if (!metadata.title) {\n            const h1 = document.querySelector('h1');\n            if (h1 && h1.textContent) metadata.title = h1.textContent.trim();\n          }\n          \n          if (!metadata.abstract) {\n            // Try common abstract containers\n            const abstractEl = document.querySelector('.abstract') || \n                              document.querySelector('#abstract') ||\n                              document.querySelector('[class*=\"abstract\"]') ||\n                              document.querySelector('[id*=\"abstract\"]');\n            if (abstractEl && abstractEl.textContent) metadata.abstract = abstractEl.textContent.trim();\n          }\n          \n          // DOI-specific extraction\n          if (!metadata.doi && window.location.href.includes('doi.org')) {\n            const match = window.location.href.match(/doi\\.org\\/(10\\.[0-9.]+\\/[^\\s&/?#]+[^\\s&/?#.:])/);\n            if (match) metadata.doi = match[1];\n          }\n          \n          // ACM-specific extraction\n          if (window.location.href.includes('dl.acm.org')) {\n            // Try to get citation count\n            const citationEl = document.querySelector('.citation-metrics');\n            if (citationEl && citationEl.textContent) {\n              const citText = citationEl.textContent;\n              const citMatch = citText.match(/(\\d+)\\s+citations/i);\n              if (citMatch) metadata.citations = parseInt(citMatch[1], 10);\n            }\n            \n            // Try to extract DOI from URL or page\n            if (!metadata.doi) {\n              const doiMatch = window.location.href.match(/dl\\.acm\\.org\\/doi\\/(10\\.[0-9.]+\\/[^\\s&/?#]+[^\\s&/?#.:])/);\n              if (doiMatch) metadata.doi = doiMatch[1];\n            }\n          }\n          \n          // Semantic Scholar specific extraction\n          if (window.location.href.includes('semanticscholar.org')) {\n            // Try to get citation count\n            const citationEl = document.querySelector('[data-test-id=\"citation-count\"]');\n            if (citationEl && citationEl.textContent) {\n              const citText = citationEl.textContent;\n              const citMatch = citText.match(/(\\d+)/);\n              if (citMatch) metadata.citations = parseInt(citMatch[1], 10);\n            }\n            \n            // Format authors if found in a specific format\n            const authorElements = document.querySelectorAll('[data-test-id=\"author-list\"] a');\n            if (authorElements.length > 0) {\n              metadata.authors = Array.from(authorElements)\n                .map(el => el.textContent?.trim())\n                .filter(Boolean)\n                .join(', ');\n            }\n          }\n\n          // OpenReview specific extraction\n          if (window.location.href.includes('openreview.net')) {\n            // Try to extract authors\n            const authorElements = document.querySelectorAll('.note_content_field:contains(\"Authors\") + .note_content_value');\n            if (authorElements.length > 0 && authorElements[0].textContent) {\n              metadata.authors = authorElements[0].textContent.trim();\n            }\n\n            // Try to extract abstract\n            const abstractElements = document.querySelectorAll('.note_content_field:contains(\"Abstract\") + .note_content_value');\n            if (abstractElements.length > 0 && abstractElements[0].textContent) {\n              metadata.abstract = abstractElements[0].textContent.trim();\n            }\n          }\n          \n          return metadata;\n        } catch (e) {\n          console.error('Error extracting metadata:', e);\n          return null;\n        }\n      }\n    });\n    \n    if (results && results[0] && results[0].result) {\n      const result = results[0].result as {\n        title?: string;\n        authors?: string;\n        abstract?: string;\n        published_date?: string;\n        doi?: string;\n        url?: string;\n        citations?: number | null;\n      };\n      \n      // Convert to PageMetadata and ensure citations is properly typed\n      const metadata: PageMetadata = {\n        title: result.title,\n        authors: result.authors,\n        abstract: result.abstract,\n        published_date: result.published_date,\n        doi: result.doi,\n        url: result.url,\n        citations: result.citations !== null ? result.citations : undefined\n      };\n      \n      return metadata;\n    }\n  } catch (error) {\n    console.error('Error executing metadata extraction script:', error);\n  }\n  \n  return null;\n}\n\n/**\n * Process a paper URL from any supported source\n * \n * @param {string} url - The URL to process\n * @param {Function} processArxivUrl - The original arXiv processing function\n * @returns {Promise<any|null>} Paper data or null if not detected\n */\nexport async function processPaperUrl(\n  url: string, \n  processArxivUrl?: (url: string) => Promise<any>\n): Promise<any | null> {\n  console.log('Processing URL for multiple sources:', url);\n  \n  // Detect source and ID from URL\n  const sourceInfo: SourceInfo | null = MultiSourceDetector.detect(url);\n  \n  if (!sourceInfo) {\n    console.log('No paper source detected, falling back to arXiv-only processing');\n    // Try the original arXiv processor as fallback\n    return processArxivUrl ? processArxivUrl(url) : null;\n  }\n  \n  const { type: sourceType, id: sourceId, primary_id } = sourceInfo;\n  console.log(`Detected ${sourceType} paper with ID: ${sourceId}`);\n  \n  // For arXiv papers, use the original processor for compatibility\n  if (sourceType === 'arxiv' && processArxivUrl) {\n    const paperData = await processArxivUrl(url);\n    \n    // Add multi-source fields if successful\n    if (paperData) {\n      paperData.source = 'arxiv';\n      paperData.sourceId = paperData.arxivId;\n      paperData.primary_id = primary_id;\n    }\n    \n    return paperData;\n  }\n  \n  // For other sources, create a basic paper data object\n  let paperData: any = {\n    source: sourceType,\n    sourceId: sourceId,\n    primary_id: primary_id,\n    url: url,\n    timestamp: new Date().toISOString(),\n    rating: 'novote'\n  };\n  \n  // Try to extract metadata from the page - but handle the case where this fails\n  try {\n    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n    if (tabs.length > 0 && tabs[0].id) {\n      const metadata = await extractMetadataFromPage(tabs[0].id);\n      \n      if (metadata) {\n        paperData.title = metadata.title || `${sourceType.toUpperCase()} Paper: ${sourceId}`;\n        paperData.authors = metadata.authors || '';\n        paperData.abstract = metadata.abstract || '';\n        paperData.published_date = metadata.published_date || '';\n        \n        // Add source-specific data\n        if (metadata.doi) {\n          paperData.doi = metadata.doi;\n        }\n        \n        if (metadata.citations !== undefined) {\n          paperData.citations = metadata.citations;\n        }\n      } else {\n        // Default title if metadata extraction fails\n        paperData.title = `${sourceType.toUpperCase()} Paper: ${sourceId}`;\n      }\n    } else {\n      paperData.title = `${sourceType.toUpperCase()} Paper: ${sourceId}`;\n    }\n  } catch (error) {\n    console.error('Error extracting metadata:', error);\n    // If there's any error in metadata extraction, use a default title\n    paperData.title = `${sourceType.toUpperCase()} Paper: ${sourceId}`;\n  }\n  \n  // Add source-specific identifiers\n  paperData.identifiers = {\n    original: sourceId,\n    url: url\n  };\n  \n  if (sourceType === 'doi' || sourceType === 'acm') {\n    paperData.doi = sourceId;\n    paperData.identifiers.doi = sourceId;\n  } else if (sourceType === 'semanticscholar') {\n    paperData.s2Id = sourceId;\n    paperData.identifiers.s2 = sourceId;\n  }\n  \n  console.log('Processed paper data:', paperData);\n  return paperData;\n}\n\n/**\n * Fetch additional metadata for source types that have APIs\n * This is an optional enhancement that can fetch richer metadata\n * \n * @param {string} sourceType - Source type (e.g., 'arxiv', 'doi')\n * @param {string} sourceId - Source-specific ID\n * @returns {Promise<any|null>} Additional metadata or null if unavailable\n */\nexport async function fetchAdditionalMetadata(\n  sourceType: string,\n  sourceId: string\n): Promise<any | null> {\n  try {\n    // Source-specific API calls\n    if (sourceType === 'semanticscholar') {\n      // Semantic Scholar API\n      const response = await fetch(`https://api.semanticscholar.org/v1/paper/${sourceId}`);\n      if (response.ok) {\n        return await response.json();\n      }\n    } else if (sourceType === 'doi') {\n      // CrossRef API for DOIs\n      const response = await fetch(`https://api.crossref.org/works/${encodeURIComponent(sourceId)}`);\n      if (response.ok) {\n        const data = await response.json();\n        return data.message;\n      }\n    }\n  } catch (error) {\n    console.error(`Error fetching additional metadata for ${sourceType}:${sourceId}:`, error);\n  }\n  \n  return null;\n}\n\n/**\n * Enhance paper data with additional metadata from APIs\n * \n * @param {any} paperData - Basic paper data\n * @returns {Promise<any>} Enhanced paper data\n */\nexport async function enhancePaperData(paperData: any): Promise<any> {\n  if (!paperData.source || !paperData.sourceId) {\n    return paperData;\n  }\n  \n  try {\n    const additionalData = await fetchAdditionalMetadata(\n      paperData.source,\n      paperData.sourceId\n    );\n    \n    if (additionalData) {\n      // Source-specific data enhancement\n      if (paperData.source === 'semanticscholar') {\n        // Update with S2 data\n        if (!paperData.title && additionalData.title) {\n          paperData.title = additionalData.title;\n        }\n        \n        if (!paperData.abstract && additionalData.abstract) {\n          paperData.abstract = additionalData.abstract;\n        }\n        \n        if (!paperData.authors && additionalData.authors) {\n          paperData.authors = additionalData.authors\n            .map((author: any) => author.name)\n            .join(', ');\n        }\n        \n        // Add identifiers\n        if (additionalData.doi) {\n          paperData.doi = additionalData.doi;\n          paperData.identifiers.doi = additionalData.doi;\n        }\n        \n        if (additionalData.arxivId) {\n          paperData.arxivId = additionalData.arxivId;\n          paperData.identifiers.arxiv = additionalData.arxivId;\n        }\n        \n        // Add citation count\n        if (additionalData.citationCount) {\n          paperData.citations = additionalData.citationCount;\n        }\n      } else if (paperData.source === 'doi') {\n        // Update with CrossRef data\n        if (!paperData.title && additionalData.title) {\n          paperData.title = additionalData.title;\n        }\n        \n        if (!paperData.authors && additionalData.author) {\n          paperData.authors = additionalData.author\n            .map((author: any) => {\n              if (author.given && author.family) {\n                return `${author.given} ${author.family}`;\n              }\n              return author.name || '';\n            })\n            .filter(Boolean)\n            .join(', ');\n        }\n        \n        // Add publication date\n        if (!paperData.published_date && additionalData.created) {\n          const date = new Date(additionalData.created['date-time']);\n          paperData.published_date = date.toISOString().split('T')[0];\n        }\n      }\n    }\n  } catch (error) {\n    console.error('Error enhancing paper data:', error);\n  }\n  \n  return paperData;\n}\n","// extension/background_multi_source.js\n// Extension to support multiple paper sources\n\nimport { MultiSourceDetector } from './papers/detector';\nimport { processPaperUrl as processUrl, enhancePaperData } from './papers/process_paper_url';\n\n/**\n * Context for external functions provided by the background script\n */\nlet externalContext = {\n  createGithubIssue: null,\n  endCurrentSession: null,\n  ReadingSession: null,\n  sessionConfig: null,\n  startActivityTracking: null,\n  setCurrentPaperData: null,\n  processArxivUrl: null\n};\n\n/**\n * Extracts metadata from the current page if possible\n * \n * @param {number} tabId - ID of the current tab\n * @returns {Promise<Object|null>} - Extracted metadata or null\n */\nasync function extractMetadataFromPage(tabId) {\n  try {\n    const result = await chrome.scripting.executeScript({\n      target: { tabId: tabId },\n      func: () => {\n        try {\n          // Helper function to safely get content from meta tags\n          const getMetaContent = (selector) => {\n            const element = document.querySelector(selector);\n            return element && 'content' in element ? \n              element.content : undefined;\n          };\n\n          // Try to extract from common meta tags first\n          const metadata = {\n            title: getMetaContent('meta[name=\"citation_title\"]') ||\n                   getMetaContent('meta[property=\"og:title\"]') ||\n                   document.title,\n            authors: getMetaContent('meta[name=\"citation_author\"]') ||\n                     getMetaContent('meta[name=\"citation_authors\"]') ||\n                     getMetaContent('meta[name=\"author\"]'),\n            abstract: getMetaContent('meta[name=\"description\"]') ||\n                      getMetaContent('meta[property=\"og:description\"]') ||\n                      getMetaContent('meta[name=\"citation_abstract\"]'),\n            published_date: getMetaContent('meta[name=\"citation_publication_date\"]') ||\n                            getMetaContent('meta[name=\"citation_date\"]'),\n            doi: getMetaContent('meta[name=\"citation_doi\"]')\n          };\n          \n          // If metadata not found in meta tags, try common page elements\n          if (!metadata.title) {\n            const h1 = document.querySelector('h1');\n            if (h1 && h1.textContent) metadata.title = h1.textContent.trim();\n          }\n          \n          if (!metadata.abstract) {\n            const abstractEl = document.querySelector('.abstract') || \n                              document.querySelector('#abstract') ||\n                              document.querySelector('[class*=\"abstract\"]');\n            if (abstractEl && abstractEl.textContent) metadata.abstract = abstractEl.textContent.trim();\n          }\n          \n          return metadata;\n        } catch (e) {\n          console.error('Error extracting metadata:', e);\n          return null;\n        }\n      }\n    });\n    \n    if (result && result[0] && result[0].result) {\n      return result[0].result;\n    }\n  } catch (error) {\n    console.error('Error executing script:', error);\n  }\n  \n  return null;\n}\n\n/**\n * Enhanced version of processArxivUrl that supports multiple sources\n * \n * @param {string} url - URL to process\n * @returns {Promise<Object|null>} - Paper data or null\n */\nasync function processPaperUrl(url) {\n  console.log('Multi-source processing for URL:', url);\n  \n  // Use detector to identify paper source\n  const sourceInfo = MultiSourceDetector.detect(url);\n  \n  // If not a recognized paper URL, exit\n  if (!sourceInfo) {\n    console.log('No recognized paper source detected in URL');\n    \n    // Try legacy arXiv detection as fallback\n    if (externalContext.processArxivUrl) {\n      return externalContext.processArxivUrl(url);\n    }\n    return null;\n  }\n  \n  console.log('Detected paper source:', sourceInfo);\n  \n  const { type: sourceType, id: sourceId, primary_id } = sourceInfo;\n  \n  // For arXiv, use the existing well-tested processor if available\n  if (sourceType === 'arxiv' && externalContext.processArxivUrl) {\n    const paperData = await externalContext.processArxivUrl(url);\n    \n    // Enhance with multi-source fields if successful\n    if (paperData) {\n      paperData.source = 'arxiv';\n      paperData.sourceId = paperData.arxivId;\n      paperData.primary_id = primary_id;\n    }\n    \n    return paperData;\n  }\n  \n  // Delegate to the TypeScript implementation in papers/process_paper_url.ts\n  try {\n    const paperData = await processUrl(url, externalContext.processArxivUrl);\n    \n    // Store in GitHub if available\n    if (paperData && externalContext.createGithubIssue) {\n      try {\n        await externalContext.createGithubIssue(paperData);\n      } catch (e) {\n        console.error('Error storing paper data in GitHub:', e);\n      }\n    }\n    \n    return paperData;\n  } catch (error) {\n    console.error('Error processing paper URL:', error);\n    \n    // Create basic paper data as fallback\n    return {\n      source: sourceType,\n      sourceId: sourceId,\n      primary_id: primary_id,\n      url: url,\n      title: `${sourceType.toUpperCase()} Paper: ${sourceId}`,\n      timestamp: new Date().toISOString(),\n      rating: 'novote'\n    };\n  }\n}\n\n/**\n * Setup listener for new paper sources\n */\nfunction setupMultiSourceListener() {\n  // Create a new listener for additional paper sources\n  chrome.webNavigation.onCompleted.addListener(async (details) => {\n    console.log('Multi-source navigation detected:', details.url);\n    \n    // Skip arXiv URLs which are handled by the original listener\n    if (details.url.includes('arxiv.org')) {\n      return;\n    }\n    \n    // Process other paper URLs\n    const paperData = await processPaperUrl(details.url);\n    if (paperData) {\n      console.log('Paper data extracted:', paperData);\n      \n      // Create or update paper in GitHub storage\n      if (externalContext.createGithubIssue) {\n        await externalContext.createGithubIssue(paperData);\n      } else {\n        console.error('createGithubIssue function not available');\n      }\n    }\n  }, {\n    url: [\n      { hostSuffix: 'semanticscholar.org' },\n      { hostSuffix: 'doi.org' },\n      { hostSuffix: 'dl.acm.org' },\n      { hostSuffix: 'openreview.net' }\n    ]\n  });\n  \n  console.log('Multi-source paper detection enabled');\n}\n\n/**\n * Enhanced tab change handler for multiple sources\n * \n * @param {Object} tab - Current tab data\n * @param {Function} originalHandler - Original handler for legacy support\n */\nasync function enhancedHandleTabChange(tab, originalHandler) {\n  const url = tab?.url || '';\n  \n  // Use detector to identify paper source\n  const sourceInfo = MultiSourceDetector.detect(url);\n  const isPaperUrl = !!sourceInfo;\n  \n  console.log('Tab change detected:', { isPaperUrl, url, sourceInfo });\n  \n  if (!isPaperUrl) {\n    console.log('Not a recognized paper page, ending current session');\n    \n    // End current session if available\n    if (externalContext.endCurrentSession) {\n      await externalContext.endCurrentSession();\n    }\n    return;\n  }\n  \n  // For arXiv papers, use the original handler for full compatibility\n  if (sourceInfo.type === 'arxiv' && originalHandler) {\n    return originalHandler(tab);\n  }\n  \n  // For other sources, end any existing session\n  if (externalContext.endCurrentSession) {\n    await externalContext.endCurrentSession();\n  }\n  \n  console.log('Processing paper URL for new session');\n  const paperData = await processPaperUrl(url);\n  \n  if (paperData) {\n    // Use appropriate ID based on availability\n    const trackingId = paperData.arxivId || paperData.sourceId;\n    \n    console.log('Starting new session for:', trackingId);\n    \n    if (externalContext.ReadingSession && externalContext.sessionConfig) {\n      // Create a new session\n      const currentSession = new externalContext.ReadingSession(trackingId, externalContext.sessionConfig);\n      const metadata = currentSession.getMetadata();\n      console.log('New session created:', metadata);\n      \n      // Set the current paper data\n      if (externalContext.setCurrentPaperData) {\n        externalContext.setCurrentPaperData(paperData);\n      }\n      \n      // Start tracking activity\n      if (externalContext.startActivityTracking) {\n        externalContext.startActivityTracking();\n      }\n      \n      // Return the paper data\n      return paperData;\n    }\n  }\n  \n  return null;\n}\n\n/**\n * Initialize the multi-source support\n * \n * @param {Object} context - External functions from background script\n */\nexport function initMultiSourceSupport(context = {}) {\n  // Store external context\n  externalContext = {\n    ...externalContext,\n    ...context\n  };\n  \n  // Setup listener for additional paper sources\n  setupMultiSourceListener();\n  \n  console.log('Multi-source paper support initialized with context:', \n    Object.keys(externalContext).filter(k => !!externalContext[k]));\n  \n  // Return overrides that can be applied to the main module\n  return {\n    processPaperUrl,\n    enhancedHandleTabChange\n  };\n}\n","// extension/utils/logger.ts\n\n/**\n * Simple logger utility inspired by loguru\n */\nclass Logger {\n  private name: string;\n  \n  constructor(name: string) {\n    this.name = name;\n  }\n  \n  info(message: string, ...args: any[]): void {\n    console.log(`[INFO] ${this.name}: ${message}`, ...args);\n  }\n  \n  warning(message: string, ...args: any[]): void {\n    console.warn(`[WARNING] ${this.name}: ${message}`, ...args);\n  }\n  \n  error(message: string, ...args: any[]): void {\n    console.error(`[ERROR] ${this.name}: ${message}`, ...args);\n  }\n  \n  debug(message: string, ...args: any[]): void {\n    console.debug(`[DEBUG] ${this.name}: ${message}`, ...args);\n  }\n}\n\nexport const loguru = {\n  getLogger: (name: string) => new Logger(name)\n};\n","// extension/papers/plugins/registry.ts\n\nimport { SourcePlugin } from './source_plugin';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('PluginRegistry');\n\nclass PluginRegistry {\n  private plugins: Map<string, SourcePlugin> = new Map();\n  \n  register(plugin: SourcePlugin): void {\n    if (this.plugins.has(plugin.id)) {\n      logger.warning(`Plugin with ID ${plugin.id} already registered, overwriting`);\n    }\n    this.plugins.set(plugin.id, plugin);\n    logger.info(`Registered plugin: ${plugin.name} (${plugin.id})`);\n  }\n  \n  getAll(): SourcePlugin[] {\n    return Array.from(this.plugins.values());\n  }\n  \n  get(id: string): SourcePlugin | undefined {\n    return this.plugins.get(id);\n  }\n  \n  findForUrl(url: string): { plugin: SourcePlugin; id: string } | null {\n    for (const plugin of this.plugins.values()) {\n      for (const pattern of plugin.urlPatterns) {\n        if (pattern.test(url)) {\n          const id = plugin.extractId(url);\n          if (id) {\n            return { plugin, id };\n          }\n        }\n      }\n    }\n    return null;\n  }\n}\n\n// Export singleton instance\nexport const pluginRegistry = new PluginRegistry();\n","// extension/papers/plugins/loader.ts\n\nimport { loguru } from '../../utils/logger';\nimport { pluginRegistry } from './registry';\n\nconst logger = loguru.getLogger('PluginLoader');\n\n/**\n * Load all built-in source plugins\n */\nexport async function loadBuiltinPlugins(): Promise<void> {\n  logger.info('Loading built-in plugins');\n  \n  try {\n    // Import all plugins\n    // In a real implementation, we might do this dynamically\n    await Promise.all([\n      import('./sources/arxiv_plugin'),\n      import('./sources/semantic_scholar_plugin'),\n      // Add more plugins here as they're implemented\n    ]);\n    \n    logger.info(`Loaded ${pluginRegistry.getAll().length} plugins`);\n  } catch (error) {\n    logger.error('Error loading plugins', error);\n  }\n}\n\n/**\n * Initialize the plugin system\n */\nexport async function initializePluginSystem(): Promise<void> {\n  logger.info('Initializing plugin system');\n  \n  await loadBuiltinPlugins();\n  \n  // Log loaded plugins\n  const plugins = pluginRegistry.getAll();\n  logger.info(`Initialized ${plugins.length} plugins:`);\n  \n  plugins.forEach(plugin => {\n    logger.info(`- ${plugin.name} (${plugin.id}) v${plugin.version}`);\n  });\n}\n","// background.js\nimport { GitHubStoreClient } from 'gh-store-client';\nimport { PaperManager } from './papers/manager';\nimport { loadSessionConfig, getConfigurationInMs } from './config/session.js';\nimport { ReadingSessionData } from './papers/types';\n// Added imports for multi-source support\nimport { MultiSourceDetector } from './papers/detector';\nimport { getLegacyId } from './papers/source_utils';\nimport { initMultiSourceSupport } from './background_multi_source';\nimport { initializePluginSystem } from './papers/plugins/loader';\nimport { loguru } from './utils/logger';\n\nconst logger = loguru.getLogger('Background');\n\nlet githubToken = '';\nlet githubRepo = '';\nlet currentPaperData = null;\nlet currentSession = null;\nlet activityInterval = null;\nlet sessionConfig = null;\nlet paperManager = null;\n\n// Store references to functions that will be enhanced\nlet originalHandleTabChange = null;\nlet originalProcessArxivUrl = null;\nlet enhancedTabChangeHandler = null;\nlet enhancedProcessPaperUrl = null;\n\nclass ReadingSession {\n    constructor(arxivId, config) {\n       this.arxivId = arxivId;\n       this.sessionId = `session_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n       this.startTime = new Date();\n       this.activeTime = 0;\n       this.idleTime = 0;\n       this.lastActiveTime = new Date();\n       this.isTracking = true;\n       this.config = config;\n       this.endTime = null;\n       this.finalizedData = null;\n    }\n    \n    update() {\n       if (this.isTracking && !this.finalizedData) {\n           const now = new Date();\n           const timeSinceLastActive = now.getTime() - this.lastActiveTime.getTime();\n           \n           if (timeSinceLastActive < this.config.idleThreshold) {\n               this.activeTime += timeSinceLastActive;\n           } else {\n               this.idleTime += timeSinceLastActive;\n           }\n           \n           this.lastActiveTime = now;\n       }\n    }\n    \n    finalize() {\n       if (this.finalizedData) {\n           return this.finalizedData;\n       }\n    \n       this.update();\n       this.isTracking = false;\n       this.endTime = new Date();\n       const totalElapsed = this.endTime.getTime() - this.startTime.getTime();\n    \n       if (this.activeTime >= this.config.minSessionDuration) {\n           this.finalizedData = {\n               session_id: this.sessionId,\n               duration_seconds: Math.round(this.activeTime / 1000),\n               idle_seconds: Math.round(this.idleTime / 1000),\n               start_time: this.startTime.toISOString(),\n               end_time: this.endTime.toISOString(),\n               total_elapsed_seconds: Math.round(totalElapsed / 1000)\n           };\n           return this.finalizedData;\n       }\n       return null;\n    }\n    \n    end() {\n       return this.finalize();\n    }\n    \n    getMetadata() {\n       return {\n           sessionId: this.sessionId,\n           startTime: this.startTime.toISOString(),\n           activeSeconds: Math.round(this.activeTime / 1000),\n           idleSeconds: Math.round(this.idleTime / 1000)\n       };\n    }\n}\n\n// Enhanced reading session that works with all paper sources\nclass EnhancedReadingSession {\n  constructor(paperData, config) {\n    // Use primary_id as the canonical identifier\n    this.paperId = paperData.primary_id;\n    this.paperData = paperData;\n    \n    // Generate unique session ID\n    this.sessionId = `session_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n    \n    // Initialize timing data\n    this.startTime = new Date();\n    this.activeTime = 0;\n    this.idleTime = 0;\n    this.lastActiveTime = new Date();\n    this.isTracking = true;\n    this.config = config;\n    this.endTime = null;\n    this.finalizedData = null;\n  }\n  \n  update() {\n    if (this.isTracking && !this.finalizedData) {\n      const now = new Date();\n      const timeSinceLastActive = now.getTime() - this.lastActiveTime.getTime();\n      \n      if (timeSinceLastActive < this.config.idleThreshold) {\n        this.activeTime += timeSinceLastActive;\n      } else {\n        this.idleTime += timeSinceLastActive;\n      }\n      \n      this.lastActiveTime = now;\n    }\n  }\n  \n  finalize() {\n    if (this.finalizedData) {\n      return this.finalizedData;\n    }\n \n    this.update();\n    this.isTracking = false;\n    this.endTime = new Date();\n    const totalElapsed = this.endTime.getTime() - this.startTime.getTime();\n \n    if (this.activeTime >= this.config.minSessionDuration) {\n      this.finalizedData = {\n        session_id: this.sessionId,\n        duration_seconds: Math.round(this.activeTime / 1000),\n        idle_seconds: Math.round(this.idleTime / 1000),\n        start_time: this.startTime.toISOString(),\n        end_time: this.endTime.toISOString(),\n        total_elapsed_seconds: Math.round(totalElapsed / 1000)\n      };\n      return this.finalizedData;\n    }\n    return null;\n  }\n  \n  getMetadata() {\n    return {\n      sourceType: this.paperData.source,\n      paperId: this.paperId,\n      title: this.paperData.title,\n      sessionId: this.sessionId,\n      startTime: this.startTime.toISOString(),\n      activeSeconds: Math.round(this.activeTime / 1000),\n      idleSeconds: Math.round(this.idleTime / 1000)\n    };\n  }\n}\n\n// Load credentials and configuration when extension starts\nasync function loadCredentials() {\n    const items = await chrome.storage.sync.get(['githubToken', 'githubRepo']);\n    githubToken = items.githubToken || '';\n    githubRepo = items.githubRepo || '';\n    console.log('Credentials loaded:', { hasToken: !!githubToken, hasRepo: !!githubRepo });\n    \n    // Initialize paper manager if we have credentials\n    if (githubToken && githubRepo) {\n        const githubClient = new GitHubStoreClient(githubToken, githubRepo);\n        paperManager = new PaperManager(githubClient);\n        console.log('Paper manager initialized');\n    }\n    \n    // Load session configuration\n    sessionConfig = getConfigurationInMs(await loadSessionConfig());\n    console.log('Session configuration loaded:', sessionConfig);\n\n    // Initialize multi-source support\n    enhancedInitialization();\n    \n    // Initialize debug objects after everything is loaded\n    initializeDebugObjects();\n}\n\n// Initialize multi-source support\nfunction enhancedInitialization() {\n    // Save original functions for compatibility\n    originalHandleTabChange = handleTabChange;\n    originalProcessArxivUrl = processArxivUrl;\n    \n    // Initialize multi-source support with explicit context binding\n    const { processPaperUrl, enhancedHandleTabChange } = initMultiSourceSupport({\n        createGithubIssue,       // Pass createGithubIssue function to background_multi_source\n        endCurrentSession,       // Pass endCurrentSession function\n        ReadingSession,          // Pass ReadingSession class\n        sessionConfig,           // Pass sessionConfig\n        startActivityTracking,   // Pass startActivityTracking function\n        setCurrentPaperData,     // New helper function to set current paper data\n        processArxivUrl          // Pass the original arXiv processor\n    });\n    \n    // Store enhanced functions\n    enhancedTabChangeHandler = enhancedHandleTabChange;\n    enhancedProcessPaperUrl = processPaperUrl;\n    \n    // Debug information\n    console.log('Multi-source paper support initialized');\n}\n\n// Helper function to set current paper data\nfunction setCurrentPaperData(data) {\n    currentPaperData = data;\n    return currentPaperData;\n}\n\n// Listen for credential changes\nchrome.storage.onChanged.addListener(async (changes) => {\n    console.log('Storage changes detected:', Object.keys(changes));\n    if (changes.githubToken) {\n        githubToken = changes.githubToken.newValue;\n    }\n    if (changes.githubRepo) {\n        githubRepo = changes.githubRepo.newValue;\n    }\n    if (changes.sessionConfig) {\n        sessionConfig = getConfigurationInMs(changes.sessionConfig.newValue);\n        console.log('Session configuration updated:', sessionConfig);\n    }\n    \n    // Reinitialize paper manager if credentials changed\n    if (changes.githubToken || changes.githubRepo) {\n        if (githubToken && githubRepo) {\n            const githubClient = new GitHubStoreClient(githubToken, githubRepo);\n            paperManager = new PaperManager(githubClient);\n            console.log('Paper manager reinitialized');\n        }\n    }\n});\n\n// Initialize the extension\nasync function initialize() {\n  logger.info('Initializing extension');\n  \n  // Load credentials and config\n  await loadCredentials();\n  \n  // Initialize plugin system\n  await initializePluginSystem();\n  \n  // Set up listeners for tab changes\n  await setupListeners();\n  \n  logger.info('Extension initialized');\n}\n\n// Initialize credentials\ninitialize().catch(error => {\n  logger.error('Initialization failed', error);\n});\n\n// Message passing between background and popup\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n    console.log('Message received:', request);\n    \n    if (request.type === 'getCurrentPaper') {\n        console.log('Popup requested current paper:', currentPaperData);\n        sendResponse(currentPaperData);\n    }\n    else if (request.type === 'updateRating') {\n        console.log('Rating update requested:', request.rating);\n        handleUpdateRating(request.rating, sendResponse);\n        return true; // Will respond asynchronously\n    }\n    else if (request.type === 'updateAnnotation') {\n        console.log('Annotation update requested:', request.annotationType, request.data);\n        handleAnnotationUpdate(request.annotationType, request.data)\n            .then(response => sendResponse(response))\n            .catch(error => sendResponse({ success: false, error: error.message }));\n        return true; // Will respond asynchronously\n    }\n    return true;\n});\n\nasync function handleUpdateRating(rating, sendResponse) {\n    if (!paperManager) {\n        sendResponse({ success: false, error: 'Paper manager not initialized' });\n        return;\n    }\n\n    if (!currentPaperData) {\n        sendResponse({ success: false, error: 'No current paper' });\n        return;\n    }\n\n    try {\n        const paperId = currentPaperData.arxivId || currentPaperData.sourceId;\n        await paperManager.updateRating(paperId, rating, currentPaperData);\n        currentPaperData.rating = rating;\n        sendResponse({ success: true });\n    } catch (error) {\n        console.error('Error updating rating:', error);\n        sendResponse({ success: false, error: error.message });\n    }\n}\n\n// Set up event listeners using plugin system\nasync function setupListeners() {\n  // Get all supported hosts from plugins\n  const { pluginRegistry } = await import('./papers/plugins/registry');\n  const plugins = pluginRegistry.getAll();\n  \n  // Create host patterns from all plugins\n  const hostPatterns = [];\n  \n  for (const plugin of plugins) {\n    // Extract domain from first pattern as a simple approach\n    // A more robust approach would parse all patterns\n    const pattern = plugin.urlPatterns[0].toString();\n    const match = pattern.match(/([a-zA-Z0-9.-]+)\\\\\\.org/);\n    if (match) {\n      hostPatterns.push({ hostSuffix: `${match[1]}.org` });\n    }\n  }\n  \n  // Set up navigation listener with all hosts\n  chrome.webNavigation.onCompleted.addListener(async (details) => {\n    logger.info(`Navigation detected: ${details.url}`);\n    \n    // Get tab info\n    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n    if (tabs.length > 0 && tabs[0].id === details.tabId) {\n      // Use enhanced handler with plugin system\n      handleTabChangeWithPlugins(tabs[0]);\n    }\n  }, { url: hostPatterns });\n  \n  // Also listen for tab activation\n  chrome.tabs.onActivated.addListener(async (activeInfo) => {\n    const tab = await chrome.tabs.get(activeInfo.tabId);\n    handleTabChangeWithPlugins(tab);\n  });\n  \n  // Listen for tab updates\n  chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n    if (changeInfo.status === 'complete') {\n      handleTabChangeWithPlugins(tab);\n    }\n  });\n}\n\n// Handle tab changes with plugin system\nasync function handleTabChangeWithPlugins(tab) {\n  if (!tab.url) return;\n  \n  // Check if this is a paper URL using the plugin system\n  const sourceInfo = MultiSourceDetector.detect(tab.url);\n  \n  if (!sourceInfo) {\n    logger.info('Not a recognized paper page, ending current session');\n    await endCurrentSession();\n    return;\n  }\n  \n  // End any existing session\n  if (currentSession) {\n    logger.info('Ending existing session before starting new one');\n    await endCurrentSession();\n  }\n  \n  // Process the paper URL\n  logger.info(`Processing paper URL: ${tab.url}`);\n  const paperData = await MultiSourceDetector.processUrl(tab.url, processArxivUrl);\n  \n  if (paperData) {\n    logger.info(`Starting new session for: ${paperData.primary_id}`);\n    \n    // Store current paper data\n    currentPaperData = paperData;\n    \n    // Create a new reading session\n    currentSession = new EnhancedReadingSession(paperData, sessionConfig);\n    \n    const metadata = currentSession.getMetadata();\n    logger.info('New session created:', metadata);\n    \n    // Start tracking reading time\n    startActivityTracking();\n    \n    // Create or update paper in GitHub\n    await createGithubIssue(paperData);\n  }\n}\n\n// Tab and window management\nchrome.tabs.onActivated.addListener(async (activeInfo) => {\n    const tab = await chrome.tabs.get(activeInfo.tabId);\n    // Use enhanced tab change handler if available, otherwise fall back to original\n    if (enhancedTabChangeHandler) {\n        enhancedTabChangeHandler(tab, originalHandleTabChange);\n    } else {\n        handleTabChange(tab);\n    }\n});\n\nchrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n    if (changeInfo.status === 'complete') {\n        // Use enhanced tab change handler if available, otherwise fall back to original\n        if (enhancedTabChangeHandler) {\n            enhancedTabChangeHandler(tab, originalHandleTabChange);\n        } else {\n            handleTabChange(tab);\n        }\n    }\n});\n\nchrome.windows.onFocusChanged.addListener((windowId) => {\n    if (windowId === chrome.windows.WINDOW_ID_NONE) {\n        endCurrentSession();\n    }\n});\n\n// Listen for URL changes - now handling both arXiv and other sources\nchrome.webNavigation.onCompleted.addListener(async (details) => {\n    console.log('Navigation detected:', details.url);\n    \n    // Check if this is a paper URL using the multi-source detector\n    const sourceInfo = MultiSourceDetector.detect(details.url);\n    \n    if (sourceInfo) {\n        console.log(`${sourceInfo.type.toUpperCase()} URL detected, processing...`);\n        \n        // Use appropriate processor based on source\n        let paperData;\n        if (sourceInfo.type === 'arxiv' && originalProcessArxivUrl) {\n            // Use original processor for arXiv\n            paperData = await originalProcessArxivUrl(details.url);\n            \n            // Add multi-source fields\n            if (paperData) {\n                paperData.source = 'arxiv';\n                paperData.sourceId = paperData.arxivId;\n                paperData.primary_id = sourceInfo.primary_id;\n            }\n        } else if (enhancedProcessPaperUrl) {\n            // Use enhanced processor for other sources\n            paperData = await enhancedProcessPaperUrl(details.url);\n        }\n        \n        if (paperData) {\n            console.log('Paper data extracted:', paperData);\n            await createGithubIssue(paperData);\n        } else {\n            console.log('Failed to extract paper data');\n        }\n    }\n}, {\n    url: [\n        { hostSuffix: 'arxiv.org' },\n        { hostSuffix: 'semanticscholar.org' },\n        { hostSuffix: 'doi.org' },\n        { hostSuffix: 'dl.acm.org' },\n        { hostSuffix: 'openreview.net' }\n    ]\n});\n\n// Original handleTabChange function\nasync function handleTabChange(tab) {\n    const isArxiv = tab.url?.includes('arxiv.org/');\n    console.log('Tab change detected:', { isArxiv, url: tab.url });\n    \n    if (!isArxiv) {\n        console.log('Not an arXiv page, ending current session');\n        await endCurrentSession();\n        return;\n    }\n\n    if (currentSession) {\n        console.log('Ending existing session before starting new one');\n        await endCurrentSession();\n    }\n\n    console.log('Processing arXiv URL for new session');\n    currentPaperData = await processArxivUrl(tab.url);\n    if (currentPaperData) {\n        console.log('Starting new session for:', currentPaperData.arxivId);\n        currentSession = new ReadingSession(currentPaperData.arxivId, sessionConfig);\n        const metadata = currentSession.getMetadata();\n        console.log('New session created:', metadata);\n        startActivityTracking();\n    }\n}\n\nasync function endCurrentSession() {\n    if (currentSession && currentPaperData) {\n        console.log('Ending session for:', currentPaperData.arxivId || currentPaperData.sourceId);\n        const sessionData = currentSession.finalize();\n        if (sessionData) {\n            console.log('Creating reading event:', sessionData);\n            await enhancedCreateReadingEvent(currentPaperData, sessionData);\n        }\n        currentSession = null;\n        currentPaperData = null;\n        stopActivityTracking();\n    }\n}\n\nfunction startActivityTracking() {\n    if (!activityInterval) {\n        console.log('Starting activity tracking');\n        activityInterval = setInterval(() => {\n            if (currentSession) {\n                currentSession.update();\n            }\n        }, sessionConfig.activityUpdateInterval);\n    }\n}\n\nfunction stopActivityTracking() {\n    if (activityInterval) {\n        clearInterval(activityInterval);\n        activityInterval = null;\n    }\n}\n\n// Original createReadingEvent function\nasync function createReadingEvent(paperData, sessionData) {\n    if (!paperManager || !paperData) {\n        console.error('Missing required data for creating reading event:', {\n            hasPaperManager: !!paperManager,\n            hasPaperData: !!paperData\n        });\n        return;\n    }\n\n    try {\n        await paperManager.logReadingSession(\n            paperData.arxivId,\n            sessionData,\n            paperData\n        );\n        console.log('Reading session logged:', {\n            arxivId: paperData.arxivId,\n            sessionId: sessionData.session_id,\n            activeTime: sessionData.duration_seconds,\n            idleTime: sessionData.idle_seconds,\n            totalTime: sessionData.total_elapsed_seconds\n        });\n        \n    } catch (error) {\n        console.error('Error logging reading session:', error);\n    }\n}\n\n// Enhanced createReadingEvent function for multi-source support\nasync function enhancedCreateReadingEvent(paperData, sessionData) {\n    if (!paperManager || !paperData) {\n        console.error('Missing required data for creating reading event:', {\n            hasPaperManager: !!paperManager,\n            hasPaperData: !!paperData\n        });\n        return;\n    }\n\n    try {\n        // Use primary_id for storage\n        const paperId = paperData.primary_id || \n                    (paperData.source && paperData.sourceId ? \n                      formatPrimaryId(paperData.source, paperData.sourceId) : \n                      (paperData.arxivId || null));\n        \n        if (!paperId) {\n            console.error('No valid paper ID found for logging');\n            return;\n        }\n        \n        await paperManager.logReadingSession(\n            paperId,\n            sessionData,\n            paperData\n        );\n        \n        console.log('Reading session logged:', {\n            paperId: paperId,\n            sessionId: sessionData.session_id,\n            activeTime: sessionData.duration_seconds,\n            idleTime: sessionData.idle_seconds,\n            totalTime: sessionData.total_elapsed_seconds\n        });\n        \n    } catch (error) {\n        console.error('Error logging reading session:', error);\n    }\n}\n\nasync function createGithubIssue(paperData) {\n    if (!paperManager) {\n        console.error('Paper manager not initialized');\n        return null;\n    }\n\n    try {\n        const existingPaper = await paperManager.getOrCreatePaper(paperData);\n        console.log('Paper metadata stored/retrieved:', \n            existingPaper.arxivId || existingPaper.sourceId || existingPaper.primary_id);\n        return existingPaper;\n    } catch (error) {\n        console.error('Error handling paper metadata:', error);\n        return null;\n    }\n}\n\nasync function handleAnnotationUpdate(type, data) {\n    if (!paperManager) {\n        throw new Error('Paper manager not initialized');\n    }\n\n    try {\n        const paperData = data.title ? {\n            title: data.title,\n            source: data.source\n        } : undefined;\n\n        if (type === 'vote') {\n            await paperManager.updateRating(\n                data.paperId,\n                data.vote,\n                paperData\n            );\n        } else {\n            await paperManager.logAnnotation(\n                data.paperId,\n                'notes',\n                data.notes,\n                paperData\n            );\n        }\n\n        return { success: true };\n    } catch (error) {\n        console.error('Error logging interaction:', error);\n        throw error;\n    }\n}\n\nasync function parseXMLText(xmlText) {\n    console.log('Parsing XML response...');\n    try {\n        const getTagContent = (tag, text) => {\n            const entryRegex = /<entry>([\\s\\S]*?)<\\/entry>/;\n            const entryMatch = text.match(entryRegex);\n            \n            if (entryMatch) {\n                const entryContent = entryMatch[1];\n                const regex = new RegExp(`<${tag}[^>]*>(.*?)</${tag}>`, 's');\n                const match = entryContent.match(regex);\n                return match ? match[1].trim() : '';\n            }\n            return '';\n        };\n        \n        const getAuthors = (text) => {\n            const authors = [];\n            const regex = /<author>[^]*?<name>([^]*?)<\\/name>[^]*?<\\/author>/g;\n            let match;\n            while (match = regex.exec(text)) {\n                authors.push(match[1].trim());\n            }\n            return authors;\n        };\n\n        const getCategories = (text) => {\n            const categories = new Set();\n            \n            const primaryMatch = text.match(/<arxiv:primary_category[^>]*term=\"([^\"]+)\"/);\n            if (primaryMatch) {\n                categories.add(primaryMatch[1]);\n            }\n            \n            const categoryRegex = /<category[^>]*term=\"([^\"]+)\"/g;\n            let match;\n            while (match = categoryRegex.exec(text)) {\n                categories.add(match[1]);\n            }\n            \n            return Array.from(categories);\n        };\n\n        const getPublishedDate = (text) => {\n            const match = text.match(/<published>([^<]+)<\\/published>/);\n            return match ? match[1].trim() : null;\n        };\n\n        const parsed = {\n            title: getTagContent('title', xmlText),\n            summary: getTagContent('summary', xmlText),\n            authors: getAuthors(xmlText),\n            published_date: getPublishedDate(xmlText),\n            arxiv_tags: getCategories(xmlText)\n        };\n        \n        console.log('Parsed XML:', parsed);\n        return parsed;\n    } catch (error) {\n        console.error('Error parsing XML:', error);\n        return null;\n    }\n}\n\nasync function processArxivUrl(url) {\n    console.log('Processing URL:', url);\n    \n    let arxivId = null;\n    const match = url.match(/arxiv\\.org\\/(abs|pdf|html)\\/([0-9.]+)/);\n    if (match) {\n        arxivId = match[2];\n    }\n    \n    if (!arxivId) {\n        console.log('No arXiv ID found in URL');\n        return null;\n    }\n    \n    console.log('Found arXiv ID:', arxivId);\n    \n    try {\n        const apiUrl = `https://export.arxiv.org/api/query?id_list=${arxivId}`;\n        console.log('Fetching from arXiv API:', apiUrl);\n        \n        const response = await fetch(apiUrl);\n        console.log('API response status:', response.status);\n        \n        if (!response.ok) {\n            throw new Error(`ArXiv API error: ${response.status}`);\n        }\n        \n        const text = await response.text();\n        const parsed = await parseXMLText(text);\n        \n        if (!parsed) {\n            console.log('Failed to parse API response');\n            return null;\n        }\n        \n        const paperData = {\n            arxivId,\n            url,\n            title: parsed.title,\n            authors: parsed.authors.join(\", \"),\n            abstract: parsed.summary,\n            timestamp: new Date().toISOString(),\n            rating: 'novote',\n            published_date: parsed.published_date,\n            arxiv_tags: parsed.arxiv_tags\n        };\n        \n        console.log('Paper data processed:', paperData);\n        return paperData;\n    } catch (error) {\n        console.error('Error processing arXiv URL:', error);\n        return null;\n    }\n}\n\n// Initialize debug objects in service worker scope\nfunction initializeDebugObjects() {\n    // Don't use window in service worker context\n    self.__DEBUG__ = {\n        get paperManager() { return paperManager; },\n        getGithubClient: () => paperManager?.client,\n        getCurrentPaper: () => currentPaperData,\n        getCurrentSession: () => currentSession,\n        getConfig: () => sessionConfig\n    };\n\n    console.log('Debug objects registered, access via __DEBUG__ in service worker console');\n}\n"],"file":"background.bundle.js"}