{"version":3,"mappings":"AAAA,IAAI,CAAC,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,CAAE,EAAC,CAAC,IAAI,CAAC,KAAK,CAAC,GAAI,IAAG,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,OAAO,CAAE,IAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,WAAW,CAAC,GAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAI,EAAC,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAO,EAAC,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,CAAE,EAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAI,EAAC,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAG,MAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC,CAAC,EAAC,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,CAAE,EAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,EAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC,EAAC,CAAC,KAAK,CAAE,EAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAE,EAAC,IAAI,CAAC,WAAW,CAAC,CAAE,GAAC,QAAQ,CAAE,EAAC,MAAM,EAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,MAAO,EAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,IAAE,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC,EAAC,qBAAqB,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAE,GAAE,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,EAAC,CAAC,CAAC,GAAI,EAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAE,EAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,EAAE,CAAe,eAAC,SAAS,CAAC,CAAC,CAAC,SAAS,EAAE,CAAM,MAAC,SAAS,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,EAAE,SAAS,EAAE,CAAI,IAAC,YAAY,CAAC,CAAC,CAAC,SAAS,EAAE,YAAY,EAAE,CAAQ,QAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,EAAC,CAAC,MAAM,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,GAAI,EAAC,CAAC,IAAI,GAAG,CAAC,CAAC,6BAA6B,CAAE,KAAI,CAAC,IAAI,CAAC,CAAE,EAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAG,GAAC,CAAC,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,EAAC,CAAC,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAG,GAAC,CAAC,OAAO,CAAC,CAAC,aAAa,CAAC,CAAC,KAAM,GAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,CAAgC,gCAAC,CAAG,GAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,GAAI,MAAK,CAAC,CAAC,kBAAkB,CAAE,EAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAO,EAAC,CAAC,IAAI,CAAE,EAAC,oBAAoB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAI,EAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,SAAS,CAAC,GAAI,KAAI,CAAE,EAAC,WAAW,EAAE,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,CAAC,MAAO,EAAC,CAAG,GAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAM,UAAS,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAG,EAAC,CAAC,GAAG,CAAC,CAAC,CAAC,KAAM,KAAI,CAAC,eAAe,CAAC,CAAC,CAAQ,SAAE,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAG,MAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,EAAC,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,EAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAI,EAAC,CAAC,MAAM,IAAI,CAAC,eAAe,CAAC,CAAS,SAAC,CAAC,MAAM,CAAC,CAAK,KAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAE,KAAI,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAG,EAAC,CAAC,EAAE,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,MAAM,GAAI,MAAK,CAAC,CAAC,EAAyB,yBAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAC,EAAG,EAAC,CAAC,EAAE,IAAI,CAAC,KAAM,KAAI,KAAK,CAAC,CAAC,oCAAoC,CAAE,EAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAI,KAAI,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,GAAI,KAAI,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAE,KAAI,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,KAAM,aAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAE,KAAI,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAM,KAAI,CAAC,eAAe,CAAC,CAAS,SAAC,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,KAAK,CAAC,CAAC,MAAe,WAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,GAAI,EAAC,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,eAAe,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC,MAAM,CAAC,CAAS,SAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAO,OAAM,IAAI,CAAC,eAAe,CAAC,CAAC,CAAiB,kBAAE,CAAC,CAAC,EAAE,CAAC,CAAU,UAAC,CAAC,CAAC,MAAM,CAAC,CAAM,MAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,eAAe,CAAC,CAAC,iBAAiB,CAAE,EAAC,CAAC,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC,CAAM,MAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,KAAM,KAAI,CAAC,eAAe,CAAC,CAAC,CAAQ,SAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,SAAS,CAAC,GAAI,KAAI,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,SAAS,CAAC,GAAI,KAAI,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,kBAAkB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,GAAI,IAAG,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAE,KAAI,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,KAAM,KAAI,CAAC,eAAe,CAAC,CAAS,SAAC,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAE,KAAI,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAG,GAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAG,EAAC,CAAC,EAAE,CAAC,CAAC,MAAM,CAAG,GAAC,CAAC,MAAM,GAAI,MAAK,CAAC,CAAC,EAAyB,yBAAE,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC,CAAC,CAAC,OAAO,MAAM,IAAI,CAAC,eAAe,CAAC,CAAC,QAAQ,CAAE,EAAC,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,MAAM,CAAC,CAAM,MAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,eAAe,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAO,OAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,KAAK,CAAC,CAAM,MAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,MAAM,OAAO,CAAE,EAAC,GAAI,EAAC,CAAC,MAAM,IAAI,CAAC,eAAe,CAAC,CAAS,SAAC,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,GAAI,EAAC,CAAI,IAAC,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,GAAG,CAAU,UAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,sBAAsB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,SAAS,CAAC,GAAI,KAAI,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,MAAM,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,EAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,KAAM,iBAAgB,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,KAAM,KAAI,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,CAAQ,QAAC,KAAK,CAAC,CAAC,CAAC,WAAW,CAAE,EAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,GAAI,EAAC,IAAI,CAAC,CAAC,EAAG,EAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,GAAG,UAAU,CAAC,CAAC,GAAG,CAAC,GAAI,EAAC,CAAC,IAAI,CAAC,sBAAsB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,EAAG,EAAC,CAAC,CAAC,CAAC,CAAC,GAAI,EAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,OAAO,CAAC,KAAM,KAAI,CAAC,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,EAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,MAAO,EAAC,CAAC,KAAM,iBAAgB,CAAC,CAAC,CAAC,CAAC,GAAI,EAAC,CAAC,MAAM,IAAI,CAAC,eAAe,CAAC,CAAS,SAAC,CAAC,MAAM,CAAC,CAAK,KAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAE,KAAI,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAE,EAAC,CAAC,MAAM,CAAG,GAAC,CAAC,KAAM,KAAI,KAAK,CAAC,CAAC,yBAAyB,CAAE,EAAC,CAAC,CAAC,CAAC,CAAC,GAAI,EAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,eAAe,CAAC,CAAC,QAAQ,CAAE,EAAC,CAAC,MAAM,CAAC,CAAS,SAAC,CAAC,CAAC,CAAC,CAAC,CAAE,EAAC,GAAI,KAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,UAAU,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,EAAE,CAAQ,QAAC,CAAO,SAAG,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAE,EAAC,CAAE,OAAM,GAAG,CAAC,EAAE,CAAC,CAAC,IAAI,GAAG,CAAe,gBAAE,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,EAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,KAAM,YAAW,CAAC,CAAC,CAAC,CAAC,MAAM,EAAC,MAAM,IAAI,CAAC,eAAe,CAAC,CAAC,QAAQ,CAAE,EAAC,CAAC,SAAS,CAAC,CAAC,CAAE,OAAM,CAAC,CAAC,CAAC,sBAAsB,CAAC,CAAC,CAAC,CAAC,IAAI,GAAI,EAAC,CAAI,IAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAG,MAAI,CAAC,MAAM,CAAC,SAAS,CAAE,EAAC,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,KAAM,KAAI,KAAK,CAAC,CAAC,+BAA+B,EAAE,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;;ACKvoM,MAAM,MAAO;AAAA,CAGX,aAAY,IAAc;AACxB,SAAK,IAAO;AAAA;AACd,EAEA,KAAK,YAAoB,IAAmB;AAC1C,IAAQ,YAAI,UAAU,IAAK,KAAI,KAAK,OAAO,GAAI,IAAG,IAAI;AAAA;AACxD,EAEA,QAAQ,YAAoB,IAAmB;AAC7C,IAAQ,aAAK,aAAa,IAAK,KAAI,KAAK,OAAO,GAAI,IAAG,IAAI;AAAA;AAC5D,EAEA,MAAM,YAAoB,IAAmB;AAC3C,IAAQ,cAAM,WAAW,IAAK,KAAI,KAAK,OAAO,GAAI,IAAG,IAAI;AAAA;AAC3D,EAEA,MAAM,YAAoB,IAAmB;AAC3C,IAAQ,cAAM,WAAW,IAAK,KAAI,KAAK,OAAO,GAAI,IAAG,IAAI;AAAA;AAE7D;AAEO,MAAM,MAAS;AAAA,CACpB,UAAW,GAAC,IAAiB,QAAI,QAAO,IAAI;AAC9C;;AC1BA,MAAMA,QAAA,CAAS,QAAO,WAAU,gBAAgB;AAChD,MAAM,YAAc,QAAO,WAAU,qBAAqB;AAE1D,MAAM,cAAe;AAAA,EAArB;AACE,IAAQ,mCAAyC,GAAI;AAAA;AAAA,CAErD,UAAS,MAA4B;AACnC,gBAAY,KAAK,CAAuB,6BAAO,EAAE,CAAK,WAAO,IAAI,CAAG;AAGpE,MAAI,GAAC,MAAO,OAAM,MAAO,QAAO,GAAO,YAAU;AAC/C,kBAAY,MAAM,CAA4B,gCAAK,SAAU,OAAM,CAAC,CAAE;AACtE;AAAA;AAGF,IAAI,KAAC,MAAM,OAAQ,QAAO,WAAW,CAAK,WAAO,WAAY,YAAW,CAAG;AACzE,kBAAY,OAAQ,UAAU,OAAO,GAAE,CAAsB;AAAA;AAG/D,MAAI,GAAC,MAAO,cAAa,MAAO,QAAO,UAAc,cAAY;AAC/D,kBAAY,KAAM,UAAU,OAAO,GAAE,CAAoC;AACzE;AAAA;AAGF,QAAI,IAAK,SAAQ,GAAI,QAAO,EAAE,CAAG;AAC/B,kBAAY,OAAQ,kBAAkB,OAAO,GAAE,CAAkC;AACjF,MAAAA,MAAA,GAAO,OAAQ,kBAAkB,OAAO,GAAE,CAAkC;AAAA;AAG9E,SAAK,OAAQ,KAAI,MAAO,IAAI,OAAM;AAClC,gBAAY,KAAK,CAAmC,yCAAO,IAAI,CAAK,WAAO,EAAE,CAAG;AAChF,CAAY,oBAAK,CAA+B,+BAAC,CAAC,OAAO,MAAM,cAAc,CAAC,CAAC,MAAO,SAAQ,CAAE;AAChG,IAAAA,QAAA,CAAO,KAAK,CAAsB,4BAAO,IAAI,CAAK,WAAO,EAAE,CAAG;AAAA;AAChE,EAEA,MAAyB;AACvB,gBAAY,IAAK,mCAAkC,IAAK,SAAQ,IAAI,CAAa;AACjF,WAAO,KAAM,MAAK,IAAK,SAAQ,QAAQ;AAAA;AACzC,CAEA,KAAI,EAAsC;AACxC,CAAY,oBAAK,CAA4B,6BAAE,CAAE;AACjD,UAAM,MAAS,QAAK,OAAQ,KAAI,EAAE;AAClC,QAAI,CAAC,MAAQ;AACX,CAAY,yBAAQ,CAA4B,6BAAE,CAAE;AAAA,KAC/C;AACL,kBAAY,KAAK,CAAiB,uBAAO,IAAI,CAAK,WAAO,EAAE,CAAG;AAAA;AAEhE,IAAO;AAAA;AACT,CAEA,YAAW,GAA0D;AACnE,CAAY,oBAAK,CAA2B,6BAAG,CAAE;AAEjD,cAAW,OAAU,SAAK,OAAQ,SAAU;AAC1C,kBAAY,IAAK,+BAA+B,OAAO,GAAE,CAAE;AAE3D,MAAW,sBAAW,OAAO,WAAa;AACxC,oBAAY,IAAK,oBAAoB,QAAQ,UAAU,EAAE;AAEzD,QAAI,YAAQ,IAAK,IAAG,CAAG;AACrB,sBAAY,IAAK,mCAAmC,OAAO,GAAE,CAAE;AAE/D,CAAM,kBAAK,QAAO,WAAU,GAAG;AAC/B,cAAI,EAAI;AACN,CAAY,4BAAK,CAA8B,+BAAE,CAAE;AACnD,YAAO,SAAE,QAAQ,EAAG;AAAA,WACf;AACL,wBAAY,QAAQ,CAA0C;AAAA;AAChE;AACF;AACF;AAGF,CAAY,uBAAQ,CAA4B,8BAAG,CAAE;AACrD,IAAO;AAAA;AAEX;AAGa,qBAAiB,MAAI,cAAe;AACjD,YAAY,KAAK,2CAA2C;;ACtE5C,yBAAgB,QAAgB,EAAoB;AAElE,CAAM,cAAS,gBAAe,KAAI,MAAM;AAGxC,EAAI,cAAU,OAAO,QAAU;AAC7B,IAAO,cAAO,SAAS,EAAE;AAAA;AAI3B,OAAM,QAAS,IACZ,SAAQ,KAAO,KAAG,EAClB,OAAQ,MAAM,IAAG,EACjB,QAAQ,KAAO,KAAG,CAClB,SAAQ,OAAO,GAAG;AAErB,CAAO,UAAG,OAAM,IAAI,MAAM;AAC5B;;ACnBA,MAAMA,QAAA,CAAS,QAAO,WAAU,cAAc;AAK9C,QAAS,kBAAiB,IAAmC;AAC3D,SAAO,MAAO,MAAS,YAChB,aAAS,IACT,UAAO,KAAK,cAAa,CACzB,iBAAM,OAAQ,MAAK,YAAY;AACxC;AAEO,MAAM,YAAa;AAAA,CAKxB,aAAY,MAA2B;AAFvC;AAAA,IAAQ,yCAAoB,GAA0B;AAGpD,SAAK,MAAS;AAAA;AAChB;AAAA;AAAA;AAAA,EAKA,KAAM,kBAAiB,SAA8B;AAEnD,IAAI,KAAC,UAAU,UAAY;AACzB,CAAI,mBAAU,MAAU,cAAU,QAAU;AAC1C,kBAAU,UAAa,mBAAgB,SAAU,SAAQ,UAAU,QAAQ;AAAA,OACtE;AACL,QAAM,UAAI,MAAM,+DAA+D;AAAA;AACjF;AAGF,CAAM,oBAAW,CAAS,kBAAU,UAAU;AAC9C,CAAOA,WAAA,MAAK,CAA8B,qCAAQ,CAAE;AAEpD,IAAI;AAEF,YAAM,GAAM,QAAM,KAAK,QAAO,UAAU,QAAQ;AAChD,WAAM,MAAO,KAAI;AAEjB,CAAOA,aAAA,MAAK,CAAyB,gCAAQ,CAAE;AAC/C,MAAO;AAAA,WACA,OAAO;AACd,QAAI,QAAiB,gBAAS,UAAM,OAAQ,UAAS,iBAAiB,CAAG;AAEvE,cAAM,gBAAwC;AAAA,UAC5C,YAAY,SAAU;AAAA,UACtB,QAAQ,SAAU;AAAA,UAClB,UAAU,SAAU;AAAA,UACpB,IAAK,WAAU,GAAO;AAAA,CACtB,gBAAO,SAAU,OAAS,YAAU;AAAA,UACpC,QAAS,WAAU,OAAW;AAAA,UAC9B,SAAU,WAAU,QAAY;AAAA,CAChC,kBAAW,uBAAI,IAAK,IAAE,WAAY;AAAA,UAClC,MAAQ;AAAA,CACV;AAGA,UAAI,YAAU,wBAA0B;AACtC,2BAAiB,yBAA2B,WAAU;AAAA;AAIxD,yBAAiB,WAAc;AAAA,UAC7B,UAAU,SAAU;AAAA,CACpB,aAAK,UAAU;AAAA,CACjB;AAGA,UAAI,YAAU,GAAK;AACjB,CAAiB,sCAAY,IAAM,WAAU;AAAA;AAG/C,CAAOA,eAAA,MAAK,CAA8B,qCAAQ,CAAE;AACpD,QAAI;AACF,gBAAM,IAAK,QAAO,YAAa,UAAU,iBAAgB;AACzD,CAAOA,iBAAA,MAAK,CAA+B,sCAAQ,CAAE;AACrD,UAAO;AAAA,eACA,aAAa;AACpB,CAAOA,iBAAA,OAAM,CAAgC,0CAAW,CAAE;AAC1D,UAAM;AAAA;AACR;AAEF,CAAOA,aAAA,OAAM,CAA8B,kCAAK,CAAE;AAClD,MAAM;AAAA;AACR;AACF;AAAA;AAAA;AAAA,EAKA,KAAc,2BAA0B,OAA0C;AAChF,CAAM,kBAAW,iBAAgB,QAAO;AAGxC,QAAI,IAAK,eAAc,GAAI,SAAQ,CAAG;AACpC,CAAOA,aAAA,MAAK,CAAqD,4DAAQ,CAAE;AAC3E,CAAO,iBAAK,aAAc,KAAI,QAAQ;AAAA;AAIxC,SAAM,oBAAmB,KAAY;AACnC,MAAI;AACF,cAAM,GAAM,QAAM,KAAK,QAAO,UAAU,QAAQ;AAChD,aAAM,MAAO,KAAI;AAEjB,QAAI,qBAAiB,IAAI,CAAG;AAC1B,UAAO;AAAA;AAGT,QAAM,UAAI,MAAM,gCAAgC;AAAA,aACzC,OAAO;AACd,UAAI,QAAiB,gBAAS,UAAM,OAAQ,UAAS,iBAAiB,CAAG;AAEvE,gBAAM,MAAyB;AAAA,CAC7B,mBAAU;AAAA,YACV,aAAc;AAAC,CACjB;AAEA,CAAOA,iBAAA,MAAK,CAAiC,wCAAQ,CAAE;AACvD,gBAAM,IAAK,QAAO,YAAa,UAAU,OAAM;AAC/C,UAAO;AAAA;AAET,QAAM;AAAA,OACN;AAEA,mBAAW,CAAM;AACf,UAAK,mBAAc,OAAO,QAAQ;AAAA,WACjC,GAAG;AAAA;AACR,KACC;AAGH,CAAK,sBAAc,GAAI,UAAU,gBAAe;AAEhD,IAAO;AAAA;AACT;AAAA;AAAA;AAAA,CAKA,OAAM,kBACJ,OACA,WACA,SACe;AAEf,QAAI,SAAW;AACb,MAAI,KAAC,UAAU,UAAY;AACzB,kBAAU,UAAa;AAAA;AAEzB,MAAM,WAAK,iBAAiB,SAAS;AAAA;AAIvC,IAAM,WAAK,eAAe,OAAS;AAAA,CACjC,SAAM;AAAA,CACN,cAAW,uBAAI,IAAK,IAAE,WAAY;AAAA,MAClC,IAAM;AAAA,KACP;AAAA;AACH;AAAA;AAAA;AAAA,CAKA,OAAM,cACJ,OACA,MACA,OACA,UACe;AAEf,QAAI,SAAW;AACb,MAAI,KAAC,UAAU,UAAY;AACzB,kBAAU,UAAa;AAAA;AAEzB,MAAM,WAAK,iBAAiB,SAAS;AAAA;AAIvC,IAAM,WAAK,eAAe,OAAS;AAAA,CACjC,SAAM;AAAA,CACN,cAAW,uBAAI,IAAK,IAAE,WAAY;AAAA,MAClC,MAAM,CAAE,MAAK,KAAM;AAAA,KACpB;AAAA;AACH;AAAA;AAAA;AAAA,CAKA,OAAM,aACJ,OACA,UACA,SACe;AAEf,IAAM,YAAQ,QAAM,IAAK,kBAAiB,aAAa,CAAE,YAAY,UAAS;AAG9E,CAAM,kBAAW,UAAS,QAAO;AACjC,CAAM,cAAK,MAAO,cAAa,QAAU;AAAA,MACvC,GAAG;AAAA,CACH;AAAA,KACD;AAGD,IAAM,WAAK,eAAe,OAAS;AAAA,CACjC,SAAM;AAAA,CACN,cAAW,uBAAI,IAAK,IAAE,WAAY;AAAA,CAClC,UAAM,GAAE,MAAO;AAAA,KAChB;AAAA;AACH;AAAA;AAAA;AAAA,EAKA,MAAc,cAAe,UAAiB,WAAyC;AACrF,UAAM,GAAM,SAAM,IAAK,2BAA0B,OAAO;AACxD,IAAI,iBAAa,KAAK,WAAW;AAGjC,CAAM,kBAAW,iBAAgB,QAAO;AACxC,UAAM,IAAK,QAAO,YAAa,UAAU,IAAG;AAAA;AAC9C;AAAA;AAAA;AAAA,CAKA,OAAM,gBACJ,OACA,YAII,EACoB;AACxB,IAAI;AACF,YAAM,GAAM,SAAM,IAAK,2BAA0B,OAAO;AACxD,SAAI,cAAe,KAAI;AAEvB,QAAI,UAAQ,IAAM;AAChB,qBAAe,eAAa,MAAO,EAAC,EAAmB,KAAE,UAAS,QAAQ,IAAI;AAAA;AAGhF,CAAI,iBAAQ,SAAa,YAAQ,OAAS;AACxC,CAAe,mCAAa,MAAO,EAAC,CAAmB;AACrD,gBAAM,IAAO,OAAI,IAAK,GAAE,SAAS;AACjC,YAAI,SAAQ,WAAa,OAAO,WAAQ,UAAkB;AAC1D,YAAI,SAAQ,SAAW,OAAO,WAAQ,QAAgB;AACtD,UAAO;AAAA,SACR;AAAA;AAGH,MAAO;AAAA,WACA,OAAO;AACd,QAAI,QAAiB,gBAAS,UAAM,OAAQ,UAAS,iBAAiB,CAAG;AACvE,eAAO,CAAC;AAAA;AAEV,MAAM;AAAA;AACR;AACF;AAAA;AAAA;AAAA,EAKA,KAAM,qBAAoB,OAAkC;AAC1D,IAAM,mBAAe,QAAM,IAAK,iBAAgB,SAAS,CAAE,MAAM,oBAAmB;AACpF,WAAO,YAAa,QAAO,CAAC,MAAO,EAAM;AACvC,WAAM,MAAO,GAAE;AACf,QAAI,SAAO,IAAS,iBAAY,IAAS,aAAQ,sBAAsB,IAAM;AAC3E,cAAO,OAAS,MAAK;AAAA;AAEvB,MAAO;AAAA,OACN,CAAC;AAAA;AACN;AAAA;AAAA;AAAA,EAKA,KAAM,iBAAgB,OAAkC;AACtD,CAAM,kBAAW,UAAS,QAAO;AACjC,CAAO,eAAK,MAAO,kBAAiB,QAAQ;AAAA;AAEhD;;AC3SA;;AAEA;AACA,MAAM,cAAc,CAAG;AACvB,CAAI,uBAAoB,EAAE,CAAC;AAC3B,CAAI,4BAAyB,EAAE,EAAE;AACjC;AACA,CAAI,4BAAyB,EAAE,IAAI;AACnC,CAAI,qBAAkB,EAAE,KAAK;AAC7B,CAAI,gCAA6B,EAAE,CAAC;AACpC,CAAC;;AAED;AACA,eAAe,iBAAiB,CAAG;AACnC,IAAI,KAAM,MAAK,CAAG,QAAM,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,eAAe,CAAC;AAChE,CAAI,UAAO,EAAE,CAAG,gBAAc,EAAE,CAAG,OAAK,CAAC,aAAa,CAAE;AACxD;;AAeA;AACA,QAAS,qBAAoB,CAAC,MAAM,CAAE;AACtC,IAAI,MAAO;AACX,CAAQ,oBAAa,EAAE,MAAM,CAAC,oBAAoB,CAAG,IAAE,GAAG,IAAI;AAC9D,QAAQ,kBAAkB,CAAE,OAAM,CAAC,yBAAyB,GAAG,IAAI;AACnE,QAAQ,sBAAsB,CAAE,OAAM,CAAC,6BAA6B,GAAG,IAAI;AAC3E,QAAQ,yBAAyB,EAAE,MAAM,CAAC,yBAAyB;AACnE,CAAQ,yBAAkB,CAAE,OAAM,CAAC;AACnC,CAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/BA,MAAMA,QAAA,CAAS,QAAO,WAAU,cAAc;AAG9C,GAAI,mBAAqB;AACzB,GAAI,sBAA8C;AAKlD,eAAe,kBAAoC;AACjD,EAAAA,MAAA,GAAO,KAAK,0BAA0B;AAEtC,EAAI;AAGF,CAAM,qBAAc,gBAAe,SAAS;AAE5C,MAAI,cAAgB,KAAG;AACrB,MAAAA,MAAA,GAAO,QAAQ,gEAAgE;AAE/E,MAAI;AACF,kCAAM,OAAO,CAAwB;AACrC,kCAAM,OAAO,CAAmC;AAChD,kCAAM,OAAO,CAA6B;AAG1C,CAAM,4BAAiB,gBAAe,SAAS;AAC/C,UAAI,iBAAiB,GAAG;AACtB,CAAOA,iBAAA,MAAK,CAAwC,qDAAc,CAAqB;AAAA,SAClF;AACL,UAAM,UAAI,MAAM,wDAAwD;AAAA;AAC1E,aACO,gBAAgB;AACvB,QAAOA,QAAA,OAAM,oCAAoC,cAAc;AAC/D,QAAM;AAAA;AACR,KACK;AACL,CAAOA,aAAA,MAAK,CAAG,aAAW,CAA0B;AAAA;AACtD,SACO,OAAO;AACd,IAAOA,QAAA,OAAM,yBAAyB,KAAK;AAE3C,MAAI,QAAiB,gBAAO;AAC1B,MAAAA,MAAA,GAAO,KAAM,yBAAyB,MAAM,QAAO,CAAE;AACrD,QAAI,QAAM,KAAO;AACf,QAAAA,MAAA,GAAO,KAAM,gBAAgB,MAAM,MAAK,CAAE;AAAA;AAC5C;AAGF,IAAM;AAAA;AAEV;AAOsB,sCAAuB,UAAU,CAAkB;AAEvE,MAAI,kBAAoB;AACtB;AAAA;AAIF,MAAI,qBAAuB;AACzB,IAAO;AAAA;AAIT,EAAAA,MAAA,GAAO,KAAK,4BAA4B;AAGxC,2BAAyB,KAAY;AACnC,QAAI,YAAe;AACnB,QAAI,SAA0B;AAG9B,SAAO,eAAe,SAAS;AAC7B,MAAI;AACF,cAAM,kBAAmB;AAGzB,QAAM,sBAAgB,eAAe,MAAO;AAC5C,QAAAA,MAAA,GAAO,IAAK,eAAe,cAAc,OAAM,CAAW;AAE1D,sBAAc,QAAQ,CAAU;AAC9B,CAAOA,iBAAA,MAAK,CAAK,WAAO,IAAI,KAAK,OAAO,EAAE,MAAM,MAAO,QAAO,CAAE;AAAA,SACjE;AAGD,CAAqB;AACrB;AAAA,aACO,OAAO;AACd;AACA,oBAAY,iBAAiB,KAAQ,SAAQ,MAAI,KAAM,QAAO,KAAK,CAAC;AACpE,QAAAA,QAAA,CAAO,QAAQ,CAAiC,4CAAY,CAAY,qBAAU,OAAO,CAAE;AAE3F,UAAI,eAAe,SAAS;AAE1B,eAAM,MAAQ,QAAK,GAAI,GAAG,aAAY,CAAI;AAC1C,CAAOA,iBAAA,MAAK,CAAqC,yCAAK,CAAO;AAC7D,eAAM,KAAI,OAAQ,UAAW,cAAW,SAAS,MAAK,CAAC;AAAA;AACzD;AACF;AAIF,CAAOA,WAAA,OAAM,CAAsC,4CAAO,CAAY;AACtE,QAAI,SAAW;AACb,MAAM;AAAA,KACD;AACL,MAAM,UAAI,MAAM,kDAAkD;AAAA;AACpE,GACC;AAEH,EAAI;AACF,IAAM;AACN;AAAA,SACO,OAAO;AAEd,CAAwB;AACxB,IAAM;AAAA;AAEV;AAMO,SAAS,qBAAiC;AAC/C,EAAO;AACT;AAMO,SAAS,4BAA+B;AAC7C,EAAO;AAAA,CACL,cAAa;AAAA,IACb,0BAA0B,CAAC,CAAC;AAAA,IAC5B,YAAa,eAAe,SAAS;AAAA,CACvC;AACF;;AClJA,MAAMA,QAAA,CAAS,QAAO,WAAU,qBAAqB;AAWrD,MAAM,mBAAoB;AAAA,EAYxB,WAAc;AAVd;AAAA,IAAQ,uCAAkB,GAAY;AAGtC;AAAA,SAAQ,YAAe;AACvB;AAAA,IAAQ,0CAAqB,GAA4B;AAGzD;AAAA,IAAQ,0CAAqB,GAAgC;AAC7D,SAAQ,YAAe;AAGrB,IAAAA,MAAA,GAAO,KAAK,mCAAmC;AAAA;AACjD;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,KAAM,cAAa,GAAiD;AAClE,QAAI,CAAC,GAAK;AACR,MAAAA,MAAA,GAAO,QAAQ,oCAAoC;AACnD,MAAO;AAAA;AAIT,QAAI,IAAK,gBAAe,GAAI,IAAG,CAAG;AAChC,CAAOA,aAAA,MAAK,CAAiB,mBAAG,CAAE;AAClC,CAAO,iBAAK,cAAe,KAAI,GAAG;AAAA;AAIpC,IAAI,KAAC,uBAAyB;AAC5B,MAAAA,MAAA,GAAO,KAAK,8CAA8C;AAC1D,MAAI;AACF,cAAM,sBAAuB;AAAA,aACtB,OAAO;AACd,QAAOA,QAAA,OAAM,iCAAiC,KAAK;AACnD,QAAO;AAAA;AACT;AAIF,IAAI,SAAK,YAAa,IAAG,CAAG;AAC1B,CAAOA,aAAA,MAAK,CAAgC,kCAAG,CAAE;AACjD,MAAO;AAAA;AAGT,IAAI;AAEF,WAAK,cAAc,GAAG;AAGtB,CAAM,kBAAS,gBAAe,YAAW,GAAG;AAC5C,UAAI,MAAQ;AACV,cAAM,UAAiC;AAAA,UACrC,KAAM,QAAO,MAAO;AAAA,UACpB,IAAI,MAAO;AAAA,UACX,UAAY,SAAO,MAAO,YACxB,OAAO,MAAO,UAAS,MAAO,GAAE,IAChC,eAAgB,QAAO,MAAO,KAAI,OAAO,EAAE;AAAA,UAC7C;AAAA,CACA,gBAAQ,OAAO;AAAA,CACjB;AAGA,QAAK,gBAAW,KAAK,UAAU;AAE/B,QAAAA,QAAA,CAAO,KAAK,CAA0C,oDAAW,IAAI,CAAI,cAAW,EAAE,CAAE;AACxF,QAAO;AAAA;AAIT,MAAM,gBAAU,eAAe,MAAO;AAEtC,iBAAW,UAAU,OAAS;AAC5B,QAAW,sBAAW,OAAO,WAAa;AACxC,CAAM,qBAAQ,KAAI,OAAM,OAAO;AAC/B,cAAI,KAAO;AACT,CAAM,oBAAK,QAAO,WAAU,GAAG;AAC/B,gBAAI,EAAI;AACN,oBAAM,UAAiC;AAAA,gBACrC,MAAM,MAAO;AAAA,gBACb;AAAA,CACA,2BAAY,MAAO,UACjB,QAAO,UAAS,EAAE,CAClB,mBAAgB,MAAO,KAAI,EAAE;AAAA,gBAC/B;AAAA,CACA;AAAA,CACF;AAGA,cAAK,gBAAW,KAAK,UAAU;AAE/B,cAAAA,QAAA,CAAO,KAAK,CAAuC,iDAAW,IAAI,CAAI,cAAW,EAAE,CAAE;AACrF,cAAO;AAAA;AACT;AACF;AACF;AAGF,CAAOA,aAAA,MAAK,CAAqC,uCAAG,CAAE;AACtD,MAAO;AAAA,KACP;AAEA,WAAK,0BAA0B,GAAG;AAAA;AACpC;AACF;AAAA;AAAA;AAAA;AAAA;AAAA,CAOA,YAAW,GAAsB;AAC/B,QAAI,CAAC,IAAO,UAAO,IAAQ,aAAiB;AAE5C,IAAI;AAEF,SAAI,KAAI,GAAG;AAGX,YAAM,aAAgB;AAAA,QACpB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,CACA;AAAA,CACF;AAEA,YAAO,eAAc,IAAK,SAAU,OAAI,UAAS,MAAM,CAAC;AAAA,WACjD,GAAG;AACV,MAAO;AAAA;AACT;AACF;AAAA;AAAA;AAAA;AAAA;AAAA,CAOA,cAAa,GAAsB;AACjC,CAAO,eAAK,WAAY,KAAI,GAAG;AAAA;AACjC;AAAA;AAAA;AAAA;AAAA,CAMA,eAAc,GAAmB;AAC/B,IAAK,iBAAY,IAAI,GAAG;AAAA;AAC1B;AAAA;AAAA;AAAA;AAAA,CAMA,kBAAiB,GAAmB;AAClC,IAAK,iBAAY,OAAO,GAAG;AAG3B,QAAI,IAAK,gBAAe,GAAI,IAAG,CAAG;AAChC,mBAAa,IAAK,gBAAe,GAAI,IAAG,CAAC;AACzC,MAAK,oBAAe,OAAO,GAAG;AAAA;AAChC;AACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,0BAA0B,KAAa,KAAsB;AAE3D,QAAI,IAAK,gBAAe,GAAI,IAAG,CAAG;AAChC,mBAAa,IAAK,gBAAe,GAAI,IAAG,CAAmB;AAAA;AAI7D,IAAM,YAAQ,aAAW,CAAM;AAC7B,MAAK,iBAAY,OAAO,GAAG;AAC3B,MAAK,oBAAe,OAAO,GAAG;AAAA,KAChC,EAAG,KAAS,SAAK,YAAY;AAE7B,CAAK,uBAAe,GAAI,KAAK,MAAK;AAAA;AACpC;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,WAAW,KAAa,IAAgC;AAC9D,QAAI,CAAC,GAAK;AACR,MAAAA,MAAA,GAAO,QAAQ,mCAAmC;AAClD;AAAA;AAIF,QAAI,IAAK,gBAAe,IAAQ,SAAK,YAAc;AAEjD,WAAM,WAAY,MAAK,gBAAe,IAAK,GAAE,MAAO;AACpD,UAAI,SAAW;AACb,QAAK,oBAAe,OAAO,SAAS;AAAA;AACtC;AAGF,CAAK,uBAAe,GAAI,KAAK,KAAI;AAAA;AACnC;AAAA;AAAA;AAAA,EAKA,UAAmB;AACjB,SAAK,eAAe,KAAM;AAAA;AAC5B;AAAA;AAAA;AAAA;AAAA,EAMA,KAAc;AAEZ,SAAK,YAAY,KAAM;AAGvB,cAAW,MAAS,SAAK,cAAe,SAAU;AAChD,mBAAa,KAAK;AAAA;AAEpB,SAAK,eAAe,KAAM;AAG1B,SAAK,UAAW;AAEhB,IAAAA,MAAA,GAAO,KAAK,sCAAsC;AAAA;AACpD;AAAA;AAAA;AAAA;AAAA,EAMA,SAAiB;AACf,IAAO;AAAA,MACL,iBAAkB,MAAK,WAAY;AAAA,MACnC,kBAAmB,MAAK,cAAe;AAAA,MACvC,UAAW,MAAK,cAAe;AAAA,CAC/B,wBAAoB,sBAAsB;AAAA,MAC1C,YAAa,eAAe,SAAS;AAAA,CACvC;AAAA;AAEJ;AAGa,4BAAsB,GAAI,oBAAoB;;ACnQ3D,MAAMA,QAAA,CAAS,QAAO,WAAU,uBAAuB;AAMvD,eAAsB,0BAA4C;AAChE,EAAAA,MAAA,GAAO,KAAK,gCAAgC;AAE5C,EAAI;AAEF,SAAM,wBAAuB,CAAC;AAE9B,SAAM,aAAc,8BAA6B;AACjD,IAAOA,QAAA,MAAK,8BAA8B,WAAW;AAIrD,MAAI,SAAO,IAAS,oBAAe,CAAU,uBAAc,eAAe,IAAM;AAC9E,MAAC,KAAa,UAAU,gBAAmB;AAAA,QACzC;AAAA,CACA,qBAAgB;AAAA,QAChB,SAAW;AAAA,CACb;AAEA,MAAAA,MAAA,GAAO,KAAK,2CAA2C;AAAA;AACzD,SACO,OAAO;AACd,IAAOA,QAAA,OAAM,2CAA2C,KAAK;AAC7D,IAAM;AAAA;AAEV;AAOA,KAAsB,qBAAW,GAAiD;AAChF,MAAI,CAAC,oBAAoB,UAAW,IAAG,CAAG;AACxC,CAAOA,WAAA,MAAK,CAA+B,iCAAG,CAAE;AAChD,IAAO;AAAA;AAGT,EAAI;AACF,IAAO,YAAM,oBAAoB,cAAa,GAAG;AAAA,SAC1C,OAAO;AACd,IAAAA,MAAA,GAAO,KAAM,wBAAwB,IAAG,KAAK,KAAK;AAClD,IAAO;AAAA;AAEX;AAOA,KAAsB,qBAAW,GAA0D;AACzF,EAAI,KAAC,IAAI,GAAK;AACZ,IAAAA,MAAA,GAAO,KAAK,gBAAgB;AAC5B,IAAO;AAAA;AAGT,EAAO,kBAAW,IAAI,GAAG;AAC3B;AAOA,KAAsB,4BAAkB,OAAyD;AAC/F,EAAI,KAAC,QAAQ,GAAK;AAChB,IAAAA,MAAA,GAAO,KAAK,6BAA6B;AACzC,IAAO;AAAA;AAGT,EAAO,kBAAW,QAAQ,GAAG;AAC/B;AAOA,KAAsB,oCAA0B,UAAqD;AACnG,MAAI,CAAC,cAAc,CAAC,WAAW,MAAQ;AACrC,IAAAA,MAAA,GAAO,KAAK,gCAAgC;AAC5C,IAAO;AAAA;AAGT,EAAI;AAEF,MAAI,YAAW,QAAO,MAAU,eAAW,OAAO,YAAc;AAC9D,MAAI;AACF,QAAAA,MAAA,GAAO,IAAK,UAAS,UAAW,QAAO,EAAE,CAAiC;AAC1E,aAAM,SAAU,QAAM,WAAW,MAAO,cAAa,WAAW,EAAE;AAElE,UAAI,UAAW,SAAO,MAAK,OAAO,EAAE,SAAS,CAAG;AAE9C,UAAO;AAAA,YACL,GAAG;AAAA,YACH,QAAQ,UAAW;AAAA,YACnB,UAAU,UAAW;AAAA,YACrB,YAAY,UAAW;AAAA,CACvB,eAAK,WAAW;AAAA,CAClB;AAAA;AACF,aACO,UAAU;AACjB,CAAOA,eAAA,OAAM,CAA2B,kCAAQ,CAAE;AAAA;AACpD;AAIF,IAAO;AAAA,MACL,QAAQ,UAAW;AAAA,MACnB,UAAU,UAAW;AAAA,MACrB,YAAY,UAAW;AAAA,MACvB,KAAK,UAAW;AAAA,MAChB,MAAO,GAAG,WAAW,MAAK,aAAa,WAAW,WAAW,EAAE;AAAA,CAC/D,cAAW,uBAAI,IAAK,IAAE,WAAY;AAAA,MAClC,MAAQ;AAAA,CACV;AAAA,SACO,OAAO;AACd,CAAOA,WAAA,OAAM,CAA8B,kCAAK,CAAE;AAClD,IAAO;AAAA;AAEX;AAQsB,sCAAuB,OAAe,UAAqD;AAC/G,EAAI,KAAC,cAAc,CAAC,WAAW,UAAU,CAAC,WAAW,OAAO,eAAiB;AAC3E,IAAO;AAAA;AAGT,EAAI;AACF,IAAAA,MAAA,GAAO,IAAK,iCAAiC,WAAW,KAAI,CAAE;AAG9D,UAAM,MAAS,SAAM,MAAO,WAAU,aAAc;AAAA,MAClD,QAAQ,CAAE,MAAM;AAAA,MAChB,KAAM,OAAM,SAAS,eAAgB;AAAA,KACtC;AAED,MAAI,SAAU,SAAO,EAAC,EAAK,SAAO,EAAC,EAAE,MAAQ;AAG3C,MAAI;AACF,CAAM,wBAAa,QAAO,EAAC,CAAE;AAI7B,cAAM,QAAW,SAAM,UAAW,QAAO,eAAgB;AAAA,UACvD,iBAAiB,CAAE,YAAW,UAAW;AAAA,SAC3C,CAAG,YAAW,GAAG;AAEjB,UAAI,WAAY,SAAO,MAAK,QAAQ,EAAE,SAAS,CAAG;AAChD,UAAO;AAAA,YACL,GAAG;AAAA,YACH,QAAQ,UAAW;AAAA,YACnB,UAAU,UAAW;AAAA,YACrB,YAAY,UAAW;AAAA,CACvB,eAAK,WAAW;AAAA,CAClB;AAAA;AACF,aACO,aAAa;AACpB,CAAOA,eAAA,OAAM,CAAyC,mDAAW,CAAE;AAEnE,QAAI;AAEF,CAAM,wBAAW,QAAM,WAAW,MAAO;AAAA,CACvC,aAAE,UAAW,OAAO,EAAC,EAAE,MAAO;AAAA,YAC9B,UAAW;AAAA,CACb;AAEA,YAAI,WAAY,SAAO,MAAK,QAAQ,EAAE,SAAS,CAAG;AAChD,YAAO;AAAA,cACL,GAAG;AAAA,cACH,QAAQ,UAAW;AAAA,cACnB,UAAU,UAAW;AAAA,cACrB,YAAY,UAAW;AAAA,CACvB,iBAAK,WAAW;AAAA,CAClB;AAAA;AACF,eACO,eAAe;AACtB,CAAOA,iBAAA,OAAM,CAA4C,wDAAa,CAAE;AAAA;AAC1E;AACF;AACF,SACO,OAAO;AACd,CAAOA,WAAA,OAAM,CAAuC,2CAAK,CAAE;AAAA;AAG7D,EAAO;AACT;AAQsB,+BAAgB,GAAa,UAAuB,IAA2B;AACnG,EAAI;AAEF,IAAM,mBAAa,MAAM,WAAW,GAAG;AAEvC,QAAI,CAAC,UAAY;AACf,CAAOA,aAAA,MAAK,CAA+B,iCAAG,CAAE;AAChD,MAAO;AAAA;AAGT,IAAAA,QAAA,CAAO,KAAK,CAAY,sBAAW,IAAI,CAAW,qBAAW,EAAE,CAAE;AAGjE,IAAI,gBAAY,MAAM,0BAA0B,UAAU;AAI1D,CAAI,aAAU,KAAC,UAAa,IAAC,UAAU,KAAS,cAAU,KAAM,UAAS,UAAW,GAAE,CAAI;AACxF,MAAAA,MAAA,GAAO,KAAK,uEAAuE;AACnF,YAAM,OAAU,SAAM,sBAAuB,OAAO,WAAU;AAE9D,UAAI,OAAS;AAEX,QAAY;AAAA,UACV,GAAG;AAAA,UACH,GAAG;AAAA;AAAA,UAEH,QAAQ,UAAW;AAAA,UACnB,UAAU,UAAW;AAAA,UACrB,YAAY,UAAW;AAAA,CACvB,aAAK,WAAW;AAAA,CAClB;AAAA;AACF;AAGF,QAAI,SAAW;AACb,MAAAA,QAAA,CAAO,KAAK,CAAiC,0CAAU,KAAS,cAAU,UAAU,CAAE;AAAA;AAGxF,IAAO;AAAA,SACA,OAAO;AACd,IAAAA,MAAA,GAAO,KAAM,8BAA8B,IAAG,KAAK,KAAK;AACxD,IAAO;AAAA;AAEX;;ACxPA,MAAM,OAAS,QAAO,WAAU,YAAY;AAG5C,GAAI,YAAc;AAClB,GAAI,WAAa;AACjB,GAAI,iBAAmB;AACvB,GAAI,eAAiB;AACrB,GAAI,iBAAmB;AACvB,GAAI,cAAgB;AACpB,GAAI,aAAe;AAGnB,MAAM,iCAAkB,IAAI;AAG5B,MAAM,sBAAuB;AAAA,EAC3B,YAAY,WAAW,MAAQ;AAE7B,IAAI,KAAC,UAAU,UAAY;AACzB,MAAM,UAAI,MAAM,oCAAoC;AAAA;AAGtD,SAAK,QAAU,WAAU;AACzB,SAAK,SAAY;AAGjB,SAAK,SAAY,aAAW,KAAK,KAAK,EAAI,QAAK,MAAO,GAAE,SAAS,EAAE,EAAE,SAAU,IAAG,CAAC,CAAC;AAGpF,IAAK,qCAAgB,IAAK;AAC1B,SAAK,UAAa;AAClB,SAAK,QAAW;AAChB,IAAK,0CAAqB,IAAK;AAC/B,SAAK,UAAa;AAClB,SAAK,MAAS;AACd,SAAK,OAAU;AACf,SAAK,aAAgB;AAAA;AACvB,EAEA,MAAS;AACP,QAAI,IAAK,eAAc,CAAC,KAAK,aAAe;AAC1C,MAAM,gCAAU,IAAK;AACrB,WAAM,qBAAsB,KAAI,SAAY,SAAK,eAAe,OAAQ;AAExE,CAAI,6BAAsB,MAAK,QAAO,aAAe;AACnD,aAAK,UAAc;AAAA,OACd;AACL,aAAK,QAAY;AAAA;AAGnB,WAAK,cAAiB;AAAA;AACxB;AACF,EAEA,QAAW;AACT,MAAI,OAAK,aAAe;AACtB,aAAO,IAAK;AAAA;AAGd,SAAK,MAAO;AACZ,SAAK,UAAa;AAClB,IAAK,mCAAc,IAAK;AACxB,SAAM,cAAe,MAAK,SAAQ,SAAY,QAAK,UAAU,OAAQ;AAErE,QAAI,IAAK,eAAc,IAAK,QAAO,kBAAoB;AACrD,WAAK,aAAgB;AAAA,QACnB,YAAY,IAAK;AAAA,CACjB,uBAAkB,OAAK,KAAM,MAAK,WAAa,KAAI;AAAA,CACnD,mBAAc,OAAK,KAAM,MAAK,SAAW,KAAI;AAAA,QAC7C,WAAY,KAAK,WAAU,WAAY;AAAA,QACvC,SAAU,KAAK,SAAQ,WAAY;AAAA,CACnC,4BAAuB,OAAK,KAAM,gBAAe,GAAI;AAAA,CACvD;AACA,aAAO,IAAK;AAAA;AAEd,IAAO;AAAA;AACT,EAEA,WAAc;AACZ,IAAO;AAAA,MACL,WAAY,MAAK,SAAU;AAAA,MAC3B,SAAS,IAAK;AAAA,MACd,MAAO,MAAK,SAAU;AAAA,MACtB,WAAW,IAAK;AAAA,MAChB,UAAW,KAAK,WAAU,WAAY;AAAA,CACtC,kBAAe,OAAK,KAAM,MAAK,WAAa,KAAI;AAAA,CAChD,gBAAa,OAAK,KAAM,MAAK,WAAW,GAAI;AAAA,CAC9C;AAAA;AAEJ;AAGA,eAAe,eAAkB;AAC/B,EAAM,cAAQ,KAAM,OAAO,SAAQ,KAAK,GAAI,EAAC,aAAe,cAAY,CAAC;AACzE,cAAc,QAAM,WAAe;AACnC,aAAa,QAAM,UAAc;AACjC,EAAO,YAAK,CAAuB,wBAAE,QAAU,GAAC,CAAC,aAAa,OAAS,GAAC,CAAC,YAAY;AAGrF,IAAI,cAAe,aAAY;AAC7B,UAAM,YAAe,OAAIC,CAAkB,aAAa,WAAU;AAClE,IAAe,mBAAI,aAAa,YAAY;AAC5C,WAAO,KAAK,2BAA2B;AAAA;AAIzC,EAAgB,qCAAqB,KAAM,oBAAmB;AAC9D,EAAO,YAAK,iCAAiC,aAAa;AAG1D,EAAuB;AACzB;AAGA,OAAO,OAAQ,WAAU,WAAY,MAAO,SAAY;AACtD,SAAO,IAAK,8BAA6B,MAAO,MAAK,OAAO,CAAC;AAC7D,IAAI,UAAQ,WAAa;AACvB,gBAAc,UAAQ,WAAY;AAAA;AAEpC,IAAI,UAAQ,UAAY;AACtB,eAAa,UAAQ,UAAW;AAAA;AAElC,IAAI,UAAQ,aAAe;AACzB,CAAgB,wCAAqB,OAAQ,eAAc,QAAQ;AACnE,IAAO,YAAK,kCAAkC,aAAa;AAAA;AAI7D,CAAI,aAAQ,WAAe,YAAQ,UAAY;AAC7C,MAAI,cAAe,aAAY;AAC7B,YAAM,YAAe,OAAIA,CAAkB,aAAa,WAAU;AAClE,MAAe,mBAAI,aAAa,YAAY;AAC5C,aAAO,KAAK,6BAA6B;AAAA;AAC3C;AAEJ,CAAC;AAGD,eAAe,UAAa;AAC1B,SAAO,KAAK,wBAAwB;AAGpC,QAAM,eAAgB;AAGtB,QAAM,0BAA2B;AAGjC,QAAM,cAAe;AAErB,SAAO,KAAK,uBAAuB;AACrC;AAGA,UAAW,GAAE,MAAM,CAAS;AAC1B,EAAO,aAAM,yBAAyB,KAAK;AAC7C,CAAC;AAGD,OAAO,QAAQ,SAAU,aAAY,CAAC,SAAS,QAAQ,YAAiB;AACtE,EAAO,YAAK,qBAAqB,OAAO;AAExC,EAAI,YAAQ,SAAS,iBAAmB;AACtC,IAAO,YAAK,kCAAkC,gBAAgB;AAC9D,iBAAa,gBAAgB;AAAA,GAC/B,QACS,SAAQ,UAAS,cAAgB;AACxC,CAAO,eAAK,0BAA4B,UAAQ,MAAM;AACtD,IAAmB,2BAAQ,QAAQ,YAAY;AAC/C,IAAO;AAAA,GACT,QACS,SAAQ,UAAS,kBAAoB;AAC5C,WAAO,IAAK,iCAAgC,OAAQ,iBAAgB,QAAQ,IAAI;AAChF,IAAuB,+BAAQ,gBAAgB,OAAQ,KAAI,EACxD,IAAK,WAAY,iBAAa,QAAQ,CAAC,EACvC,KAAM,QAAS,iBAAa,CAAE,UAAS,OAAO,KAAO,QAAM,OAAQ,EAAC,CAAC;AACxE,IAAO;AAAA,GACT,QAES,SAAQ,UAAS,YAAc;AACtC,IAAO,YAAK,0BAA0B,OAAO;AAC7C,qBAAiB,OAAO,CACrB,MAAK,cAAY,YAAa,SAAQ,CAAC,CACvC,OAAM,CAAS,uBAAa,EAAE,OAAS,QAAO,QAAO,KAAM,UAAS,CAAC;AACxE,IAAO;AAAA;AAET,EAAO;AACT,CAAC;AAGD,KAAe,2BAAiB,OAAS;AACvC,MAAI,CAAC,YAAc;AACjB,IAAM,UAAI,MAAM,+BAA+B;AAAA;AAGjD,EAAI;AAEF,IAAI;AAEJ,MAAI,UAAQ,GAAK;AAEf,CAAY,sBAAM,gBAAgB,SAAQ,GAAG;AAAA,CACpC,sBAAQ,MAAU,YAAQ,EAAI;AAEvC,WAAM,WAAa,mBAAgB,OAAQ,QAAQ,SAAQ,EAAE;AAC7D,MAAY;AAAA,QACV,QAAQ,OAAQ;AAAA,QAChB,UAAU,OAAQ;AAAA,QAClB;AAAA,QACA,IAAK,SAAQ,GAAO;AAAA,CACpB,cAAO,OAAQ,OAAS,IAAG,UAAQ,OAAO,WAAY,EAAC,CAAW,kBAAQ,EAAE;AAAA,CAC5E,gBAAW,uBAAI,IAAK,IAAE,WAAY;AAAA,QAClC,MAAQ;AAAA,CACV;AAAA,KACK;AACL,MAAM,UAAI,MAAM,2CAA2C;AAAA;AAG7D,QAAI,CAAC,SAAW;AACd,YAAM,GAAI,MAAM,4BAA4B,SAAQ,GAAO,YAAQ,EAAE,CAAE;AAAA;AAIzE,IAAM,qBAAe,MAAM,kBAAkB,SAAS;AAEtD,WAAO,EAAE,SAAS,IAAM,YAAW,aAAa;AAAA,SACzC,OAAO;AACd,CAAO,gBAAM,CAAyB,6BAAK,CAAE;AAC7C,IAAM;AAAA;AAEV;AAEA,eAAe,mBAAmB,QAAQ,YAAc;AACtD,MAAI,CAAC,YAAc;AACjB,iBAAa,EAAE,SAAS,KAAO,SAAO,iCAAiC;AACvE;AAAA;AAGF,MAAI,CAAC,gBAAkB;AACrB,iBAAa,EAAE,SAAS,KAAO,SAAO,oBAAoB;AAC1D;AAAA;AAGF,EAAI;AAEF,SAAM,SAAU,kBAAiB;AACjC,UAAM,YAAa,cAAa,OAAS,SAAQ,iBAAgB;AACjE,qBAAiB,MAAS;AAC1B,IAAa,eAAE,OAAS,QAAM;AAAA,SACvB,OAAO;AACd,IAAO,aAAM,0BAA0B,KAAK;AAC5C,iBAAa,CAAE,QAAS,QAAO,MAAO,QAAM,SAAS;AAAA;AAEzD;AAGA,eAAe,cAAiB;AAC9B,SAAO,KAAK,oCAAoC;AAGhD,EAAM,gBAAU,eAAe,MAAO;AAGtC,QAAM,eAAe,CAAC;AAEtB,aAAW,UAAU,OAAS;AAE5B,IAAI;AAEF,MAAW,sBAAW,OAAO,WAAa;AACxC,QAAM,mBAAa,QAAQ,QAAS;AAEpC,CAAM,mBAAQ,YAAW,OAAM,kCAAkC;AACjE,YAAI,KAAO;AACT,UAAM,eAAS,MAAM,CAAC;AACtB,UAAM,YAAM,MAAM,CAAC;AACnB,UAAa,kBAAK,EAAE,UAAY,IAAG,OAAM,CAAI,MAAG,IAAI;AAAA;AACtD;AACF,WACO,KAAK;AACZ,CAAO,kBAAM,CAAyC,2CAAG,CAAE;AAAA;AAC7D;AAIF,EAAI,iBAAa,WAAW,CAAG;AAC7B,CAAa;AAAA,MACX,CAAE,YAAY,YAAY;AAAA,MAC1B,CAAE,YAAY,sBAAsB;AAAA,MACpC,CAAE,YAAY,UAAU;AAAA,MACxB,CAAE,YAAY,aAAa;AAAA,CAC3B,OAAE,YAAY,CAAiB;AAAA,CACjC;AAAA;AAGF,SAAO,KAAK,CAAiD,qDAAK,SAAU,aAAY,CAAC,CAAE;AAG3F,CAAO,sBAAc,WAAY,aAAY,uBAAyB;AAAA,IACpE,GAAK;AAAA,GACN;AAGD,CAAO,aAAK,WAAY,aAAY,0BAA0B;AAG9D,CAAO,aAAK,SAAU,aAAY,sBAAsB;AAGxD,SAAO,OAAQ,gBAAe,WAAY,EAAC,QAAa;AACtD,CAAI,gBAAa,UAAO,SAAQ,cAAgB;AAC9C,MAAkB;AAAA;AACpB,GACD;AAED,SAAO,KAAK,iCAAiC;AAC/C;AA0CA,KAAe,kCAAwB,OAAS;AAC9C,SAAO,IAAK,+BAA+B,QAAQ,IAAG,CAAE;AAExD,EAAI;AAEF,IAAM,mBAAa,MAAM,kBAAkB,OAAO;AAElD,QAAI,CAAC,UAAY;AACf,aAAO,KAAK,4BAA4B;AACxC;AAAA;AAGF,WAAO,KAAK,CAAmB,6BAAW,IAAI,CAAI,cAAW,EAAE,CAAE;AAGjE,IAAM,aAAO,MAAM,OAAO,IAAK,OAAM,CAAE,OAAQ,QAAM,aAAe,QAAM;AAC1E,IAAI,SAAK,SAAS,CAAK,SAAK,CAAC,CAAE,QAAO,QAAQ,KAAO;AAEnD,MAAM,iCAA2B,IAAK,EAAC,CAAC;AAAA,KACnC;AAEL,YAAM,SAAY,SAAM,eAAgB,SAAQ,GAAG;AACnD,UAAI,SAAW;AACb,eAAO,IAAK,yBAAyB,UAAU,MAAK,CAAE;AAAA;AACxD;AACF,SACO,OAAO;AACd,CAAO,gBAAM,CAAgC,oCAAK,CAAE;AAAA;AAExD;AAEA,KAAe,qCAA2B,UAAY;AACpD,SAAO,IAAK,mCAAmC,WAAW,MAAK,CAAE;AACjE,OAAM,KAAM,QAAM,OAAO,IAAK,KAAI,WAAW,KAAK;AAElD,IAAI,GAAC,GAAI,KAAO,eAAY,GAAI,KAAI,GAAG,CAAG;AACxC,WAAO,IAAK,6CAA6C,IAAI,IAAG,CAAE;AAClE;AAAA;AAGF,EAAI;AAEF,IAAY,gBAAI,IAAI,GAAG;AAGvB,SAAM,4BAA2B,GAAG;AAAA,SAC7B,OAAO;AACd,CAAO,gBAAM,CAAoC,wCAAK,CAAE;AAAA,GACxD;AACA,eAAW,CAAM;AACf,MAAY,mBAAO,IAAI,GAAG;AAAA,OACzB,GAAG;AAAA;AAEV;AAEA,eAAe,uBAAuB,KAAO,cAAY,GAAK;AAC5D,CAAI,gBAAW,MAAW,mBAAc,CAAC,IAAI,IAAO,cAAY,KAAI,GAAI,IAAG,CAAG;AAC5E;AAAA;AAGF,SAAO,IAAK,+BAA+B,IAAI,IAAG,CAAE;AAEpD,EAAI;AAEF,IAAY,gBAAI,IAAI,GAAG;AAGvB,SAAM,4BAA2B,GAAG;AAAA,SAC7B,OAAO;AACd,CAAO,gBAAM,CAAgC,oCAAK,CAAE;AAAA,GACpD;AACA,eAAW,CAAM;AACf,MAAY,mBAAO,IAAI,GAAG;AAAA,OACzB,GAAG;AAAA;AAEV;AAgBA,KAAe,qCAA2B,GAAK;AAC7C,EAAI,KAAC,IAAI,GAAK;AAGd,EAAM,mBAAa,MAAM,WAAW,GAAG;AAEvC,MAAI,CAAC,UAAY;AACf,WAAO,KAAK,qDAAqD;AACjE,UAAM,iBAAkB;AACxB;AAAA;AAGF,MAAI,cAAgB;AAClB,WAAO,KAAK,iDAAiD;AAC7D,UAAM,iBAAkB;AAAA;AAI1B,SAAO,IAAK,yBAAyB,IAAI,IAAG,CAAE;AAC9C,OAAM,WAAY,QAAM,gBAAgB,GAAI,MAAK,IAAI,EAAE;AAEvD,MAAI,SAAW;AACb,WAAO,IAAK,6BAA6B,UAAU,WAAU,CAAE;AAG/D,CAAmB;AAGnB,CAAiB,uBAAI,uBAAuB,YAAW,aAAa;AAEpE,IAAM,iBAAW,eAAe,WAAY;AAC5C,IAAO,YAAK,wBAAwB,QAAQ;AAG5C,IAAsB;AAGtB,WAAO,IAAK,8BAA8B,UAAU,WAAU,CAAE;AAChE,IAAI;AACF,WAAM,mBAAkB,SAAS;AAAA,WAC1B,OAAO;AACd,CAAO,kBAAM,CAAgC,oCAAK,CAAE;AAAA;AACtD;AAEJ;AAGA,eAAe,iBAAoB;AACjC,IAAI,iBAAkB,mBAAkB;AACtC,WAAO,IAAK,uBAAuB,iBAAiB,WAAU,CAAE;AAChE,IAAM,oBAAc,eAAe,QAAS;AAC5C,QAAI,WAAa;AACf,MAAO,YAAK,2BAA2B,WAAW;AAClD,MAAM,yBAAmB,kBAAkB,WAAW;AAAA;AAExD,CAAiB;AACjB,CAAmB;AACnB,IAAqB;AAAA;AAEzB;AAEA,SAAS,qBAAwB;AAC/B,MAAI,CAAC,gBAAkB;AACrB,WAAO,KAAK,4BAA4B;AACxC,uBAAmB,YAAY,CAAM;AACnC,UAAI,cAAgB;AAClB,uBAAe,MAAO;AAAA;AACxB,KACF,CAAG,eAAc,sBAAsB;AAAA;AAE3C;AAEA,SAAS,oBAAuB;AAC9B,MAAI,gBAAkB;AACpB,kBAAc,gBAAgB;AAC9B,CAAmB;AAAA;AAEvB;AAGA,eAAe,mBAAmB,WAAW,WAAa;AACxD,EAAI,KAAC,YAAgB,KAAC,SAAW;AAC/B,WAAO,MAAM,mDAAqD;AAAA,MAChE,iBAAiB,CAAC,CAAC;AAAA,CACnB,kBAAc,EAAC,CAAC;AAAA,KACjB;AACD;AAAA;AAGF,EAAI;AAEF,IAAI,KAAC,UAAU,UAAY;AACzB,aAAO,MAAM,wDAAwD;AACrE;AAAA;AAGF,SAAM,SAAU,WAAU;AAE1B,UAAM,YAAa;AAAA,MACjB;AAAA,MACA;AAAA,CACA;AAAA,CACF;AAEA,WAAO,KAAK,yBAA2B;AAAA,MACrC;AAAA,MACA,WAAW,WAAY;AAAA,MACvB,YAAY,WAAY;AAAA,MACxB,UAAU,WAAY;AAAA,CACtB,eAAW,YAAY;AAAA,KACxB;AAAA,SAEM,OAAO;AACd,IAAO,aAAM,kCAAkC,KAAK;AAAA;AAExD;AAGA,KAAe,4BAAkB,SAAW;AAC1C,MAAI,CAAC,YAAc;AACjB,WAAO,MAAM,+BAA+B;AAC5C,IAAO;AAAA;AAIT,EAAI,KAAC,UAAU,UAAY;AACzB,CAAI,iBAAU,MAAU,cAAU,QAAU;AAC1C,gBAAU,UAAa,mBAAgB,SAAU,SAAQ,UAAU,QAAQ;AAAA,KACtE;AACL,aAAO,MAAM,2CAA2C;AACxD,MAAO;AAAA;AACT;AAGF,EAAI;AACF,WAAO,IAAK,iCAAiC,UAAU,WAAU,CAAE;AACnE,UAAM,aAAgB,SAAM,YAAa,kBAAiB,SAAS;AACnE,WAAO,IAAK,oCAAoC,cAAc,WAAU,CAAE;AAC1E,IAAO;AAAA,SACA,OAAO;AACd,WAAO,KAAM,kCAAkC,MAAK,GAAI,MAAK;AAC7D,IAAO;AAAA;AAEX;AAEA,eAAe,uBAAuB,MAAM,IAAM;AAChD,MAAI,CAAC,YAAc;AACjB,IAAM,UAAI,MAAM,+BAA+B;AAAA;AAGjD,EAAI;AAEF,OAAI,SAAU,MAAK;AAGnB,QAAI,CAAC,QAAQ,QAAS,IAAG,CAAG;AAE1B,MAAM,eAAS,KAAK,MAAU;AAC9B,MAAU,0BAAgB,QAAQ,OAAO;AACzC,CAAO,iBAAK,CAAwC,8CAAO,CAAE;AAAA;AAG/D,IAAM,kBAAY,KAAK,KAAQ;AAAA,MAC7B,OAAO,IAAK;AAAA,MACZ,QAAQ,IAAK;AAAA,MACb,UAAY;AAAA,CACV;AAEJ,MAAI,OAAS,UAAQ;AACnB,YAAM,YAAa;AAAA,QACjB;AAAA,CACA,WAAK;AAAA,CACL;AAAA,CACF;AAAA,KACK;AACL,YAAM,YAAa;AAAA,QACjB;AAAA,QACA;AAAA,CACA,WAAK;AAAA,CACL;AAAA,CACF;AAAA;AAGF,IAAO,SAAE,SAAS,IAAK;AAAA,SAChB,OAAO;AACd,IAAO,aAAM,8BAA8B,KAAK;AAChD,IAAM;AAAA;AAEV;AAGA,SAAS,sBAAyB;AAEhC,OAAK,SAAY;AAAA,CACf,OAAI,YAAe;AAAE,MAAO;AAAA,CAAc;AAAA,IAC1C,iBAAiB,CAAM,iBAAc;AAAA,CACrC,mBAAiB,OAAM;AAAA,CACvB,qBAAmB,OAAM;AAAA,CACzB,cAAW,CAAM;AAAA,CACnB;AAEA,SAAO,KAAK,0EAA0E;AACxF","names":["logger","GitHubStoreClient"],"ignoreList":[0],"sources":["../node_modules/gh-store-client/dist/index.mjs","../utils/logger.ts","../papers/plugins/registry.ts","../papers/source_utils.ts","../papers/manager.ts","../config/session.js","../papers/plugins/loader.ts","../papers/url_detection_service.ts","../background_integration.ts","../background.js"],"sourcesContent":["var d=class{constructor(e={}){this.cache=new Map,this.maxSize=e.maxSize??1e3,this.ttl=e.ttl??1e3*60*60,this.accessOrder=[]}get(e){let s=this.cache.get(e);if(s){if(Date.now()-s.lastAccessed>this.ttl){this.cache.delete(e),this.removeFromAccessOrder(e);return}return s.lastAccessed=Date.now(),this.updateAccessOrder(e),s.issueNumber}}set(e,s,t){if(this.cache.size>=this.maxSize&&!this.cache.has(e)){let r=this.accessOrder[this.accessOrder.length-1];r&&(this.cache.delete(r),this.removeFromAccessOrder(r))}this.cache.set(e,{issueNumber:s,lastAccessed:Date.now(),createdAt:t.createdAt,updatedAt:t.updatedAt}),this.updateAccessOrder(e)}remove(e){this.cache.delete(e),this.removeFromAccessOrder(e)}clear(){this.cache.clear(),this.accessOrder=[]}getStats(){return{size:this.cache.size,maxSize:this.maxSize,ttl:this.ttl}}shouldRefresh(e,s){let t=this.cache.get(e);return t?s>t.updatedAt:!0}updateAccessOrder(e){this.removeFromAccessOrder(e),this.accessOrder.unshift(e)}removeFromAccessOrder(e){let s=this.accessOrder.indexOf(e);s>-1&&this.accessOrder.splice(s,1)}};var l=\"0.3.2\";var f=class{constructor(e,s,t={}){this.token=e,this.repo=s,this.config={baseLabel:t.baseLabel??\"stored-object\",uidPrefix:t.uidPrefix??\"UID:\",reactions:{processed:t.reactions?.processed??\"+1\",initialState:t.reactions?.initialState??\"rocket\"}},this.cache=new d(t.cache)}async fetchFromGitHub(e,s={}){let t=new URL(`https://api.github.com/repos/${this.repo}${e}`);s.params&&(Object.entries(s.params).forEach(([i,a])=>{t.searchParams.append(i,a)}),delete s.params);let r=await fetch(t.toString(),{...s,headers:{Authorization:`token ${this.token}`,Accept:\"application/vnd.github.v3+json\",...s.headers}});if(!r.ok)throw new Error(`GitHub API error: ${r.status}`);return r.json()}createCommentPayload(e,s){let t={_data:e,_meta:{client_version:l,timestamp:new Date().toISOString(),update_mode:\"append\"}};return s&&(t.type=s),t}async getObject(e){let s=this.cache.get(e),t;if(s)try{t=await this.fetchFromGitHub(`/issues/${s}`),this._verifyIssueLabels(t,e)||(this.cache.remove(e),t=void 0)}catch{this.cache.remove(e)}if(!t){let c=await this.fetchFromGitHub(\"/issues\",{method:\"GET\",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(\",\"),state:\"closed\"}});if(!c||c.length===0)throw new Error(`No object found with ID: ${e}`);t=c[0]}if(!t?.body)throw new Error(`Invalid issue data received for ID: ${e}`);let r=JSON.parse(t.body),i=new Date(t.created_at),a=new Date(t.updated_at);return this.cache.set(e,t.number,{createdAt:i,updatedAt:a}),{meta:{objectId:e,label:`${this.config.uidPrefix}${e}`,createdAt:i,updatedAt:a,version:await this._getVersion(t.number)},data:r}}async createObject(e,s){let t=`${this.config.uidPrefix}${e}`,r=await this.fetchFromGitHub(\"/issues\",{method:\"POST\",body:JSON.stringify({title:`Stored Object: ${e}`,body:JSON.stringify(s,null,2),labels:[this.config.baseLabel,t]})});this.cache.set(e,r.number,{createdAt:new Date(r.created_at),updatedAt:new Date(r.updated_at)});let i=this.createCommentPayload(s,\"initial_state\"),a=await this.fetchFromGitHub(`/issues/${r.number}/comments`,{method:\"POST\",body:JSON.stringify({body:JSON.stringify(i,null,2)})});return await this.fetchFromGitHub(`/issues/comments/${a.id}/reactions`,{method:\"POST\",body:JSON.stringify({content:this.config.reactions.processed})}),await this.fetchFromGitHub(`/issues/comments/${a.id}/reactions`,{method:\"POST\",body:JSON.stringify({content:this.config.reactions.initialState})}),await this.fetchFromGitHub(`/issues/${r.number}`,{method:\"PATCH\",body:JSON.stringify({state:\"closed\"})}),{meta:{objectId:e,label:t,createdAt:new Date(r.created_at),updatedAt:new Date(r.updated_at),version:1},data:s}}_verifyIssueLabels(e,s){let t=new Set([this.config.baseLabel,`${this.config.uidPrefix}${s}`]);return e.labels.some(r=>t.has(r.name))}async updateObject(e,s){let t=await this.fetchFromGitHub(\"/issues\",{method:\"GET\",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(\",\"),state:\"all\"}});if(!t||t.length===0)throw new Error(`No object found with ID: ${e}`);let r=t[0],i=this.createCommentPayload(s);return await this.fetchFromGitHub(`/issues/${r.number}/comments`,{method:\"POST\",body:JSON.stringify({body:JSON.stringify(i,null,2)})}),await this.fetchFromGitHub(`/issues/${r.number}`,{method:\"PATCH\",body:JSON.stringify({state:\"open\"})}),this.getObject(e)}async listAll(){let e=await this.fetchFromGitHub(\"/issues\",{method:\"GET\",params:{labels:this.config.baseLabel,state:\"closed\"}}),s={};for(let t of e)if(!t.labels.some(r=>r.name===\"archived\"))try{let r=this._getObjectIdFromLabels(t),i=JSON.parse(t.body),a={objectId:r,label:r,createdAt:new Date(t.created_at),updatedAt:new Date(t.updated_at),version:await this._getVersion(t.number)};s[r]={meta:a,data:i}}catch{continue}return s}async listUpdatedSince(e){let s=await this.fetchFromGitHub(\"/issues\",{method:\"GET\",params:{labels:this.config.baseLabel,state:\"closed\",since:e.toISOString()}}),t={};for(let r of s)if(!r.labels.some(i=>i.name===\"archived\"))try{let i=this._getObjectIdFromLabels(r),a=JSON.parse(r.body),n=new Date(r.updated_at);if(n>e){let c={objectId:i,label:i,createdAt:new Date(r.created_at),updatedAt:n,version:await this._getVersion(r.number)};t[i]={meta:c,data:a}}}catch{continue}return t}async getObjectHistory(e){let s=await this.fetchFromGitHub(\"/issues\",{method:\"GET\",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(\",\"),state:\"all\"}});if(!s||s.length===0)throw new Error(`No object found with ID: ${e}`);let t=s[0],r=await this.fetchFromGitHub(`/issues/${t.number}/comments`),i=[];for(let a of r)try{let n=JSON.parse(a.body),c=\"update\",m,b={client_version:\"legacy\",timestamp:a.created_at,update_mode:\"append\"};typeof n==\"object\"?\"_data\"in n?(c=n.type||\"update\",m=n._data,b=n._meta||b):\"type\"in n&&n.type===\"initial_state\"?(c=\"initial_state\",m=n.data):m=n:m=n,i.push({timestamp:a.created_at,type:c,data:m,commentId:a.id})}catch{continue}return i}async _getVersion(e){return(await this.fetchFromGitHub(`/issues/${e}/comments`)).length+1}_getObjectIdFromLabels(e){for(let s of e.labels)if(s.name!==this.config.baseLabel&&s.name.startsWith(this.config.uidPrefix))return s.name.slice(this.config.uidPrefix.length);throw new Error(`No UID label found with prefix ${this.config.uidPrefix}`)}};var u={baseLabel:\"stored-object\",uidPrefix:\"UID:\",reactions:{processed:\"+1\",initialState:\"rocket\"},retries:{maxAttempts:3,backoffFactor:2},rateLimit:{maxRequestsPerHour:1e3}};function _(o){return{...u,...o,reactions:{...u.reactions,...o.reactions},retries:{...u.retries,...o.retries},rateLimit:{...u.rateLimit,...o.rateLimit}}}function v(o){return/^gh[ps]_[a-zA-Z0-9]{36}$/.test(o)}function P(o){return/^[\\w-]+\\/[\\w-]+$/.test(o)}var h=class extends Error{constructor(e){super(e),this.name=\"ConfigError\"}},g=class extends h{constructor(e=\"Invalid GitHub token format\"){super(e),this.name=\"TokenError\"}},p=class extends h{constructor(e=\"Invalid repository format. Use owner/repo\"){super(e),this.name=\"RepoError\"}};export{h as ConfigError,u as DEFAULT_CONFIG,f as GitHubStoreClient,p as RepoError,g as TokenError,_ as mergeConfig,P as validateRepo,v as validateToken};\n//# sourceMappingURL=index.mjs.map","// extension/utils/logger.ts\n\n/**\n * Simple logger utility inspired by loguru\n */\nclass Logger {\n  private name: string;\n  \n  constructor(name: string) {\n    this.name = name;\n  }\n  \n  info(message: string, ...args: any[]): void {\n    console.log(`[INFO] ${this.name}: ${message}`, ...args);\n  }\n  \n  warning(message: string, ...args: any[]): void {\n    console.warn(`[WARNING] ${this.name}: ${message}`, ...args);\n  }\n  \n  error(message: string, ...args: any[]): void {\n    console.error(`[ERROR] ${this.name}: ${message}`, ...args);\n  }\n  \n  debug(message: string, ...args: any[]): void {\n    console.debug(`[DEBUG] ${this.name}: ${message}`, ...args);\n  }\n}\n\nexport const loguru = {\n  getLogger: (name: string) => new Logger(name)\n};\n","// extension/papers/plugins/registry.ts - Enhanced registry logging\n\nimport { SourcePlugin } from './source_plugin';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('PluginRegistry');\nconst debugLogger = loguru.getLogger('PluginRegistryDebug');\n\nclass PluginRegistry {\n  private plugins: Map<string, SourcePlugin> = new Map();\n  \n  register(plugin: SourcePlugin): void {\n    debugLogger.info(`Registering plugin: ${plugin.id} (${plugin.name})`);\n    \n    // Validate plugin has required fields\n    if (!plugin.id || typeof plugin.id !== 'string') {\n      debugLogger.error(`Plugin missing valid id: ${JSON.stringify(plugin)}`);\n      return;\n    }\n    \n    if (!Array.isArray(plugin.urlPatterns) || plugin.urlPatterns.length === 0) {\n      debugLogger.warning(`Plugin ${plugin.id} has no URL patterns`);\n    }\n    \n    if (!plugin.extractId || typeof plugin.extractId !== 'function') {\n      debugLogger.error(`Plugin ${plugin.id} missing required extractId method`);\n      return;\n    }\n    \n    if (this.plugins.has(plugin.id)) {\n      debugLogger.warning(`Plugin with ID ${plugin.id} already registered, overwriting`);\n      logger.warning(`Plugin with ID ${plugin.id} already registered, overwriting`);\n    }\n    \n    this.plugins.set(plugin.id, plugin);\n    debugLogger.info(`Successfully registered plugin: ${plugin.name} (${plugin.id})`);\n    debugLogger.info(`Plugin capabilities: hasApi=${!!plugin.hasApi}, formatId=${!!plugin.formatId}`);\n    logger.info(`Registered plugin: ${plugin.name} (${plugin.id})`);\n  }\n  \n  getAll(): SourcePlugin[] {\n    debugLogger.info(`Getting all plugins, currently ${this.plugins.size} registered`);\n    return Array.from(this.plugins.values());\n  }\n  \n  get(id: string): SourcePlugin | undefined {\n    debugLogger.info(`Looking up plugin by id: ${id}`);\n    const plugin = this.plugins.get(id);\n    if (!plugin) {\n      debugLogger.warning(`No plugin found with id: ${id}`);\n    } else {\n      debugLogger.info(`Found plugin: ${plugin.name} (${plugin.id})`);\n    }\n    return plugin;\n  }\n  \n  findForUrl(url: string): { plugin: SourcePlugin; id: string } | null {\n    debugLogger.info(`Finding plugin for URL: ${url}`);\n    \n    for (const plugin of this.plugins.values()) {\n      debugLogger.info(`Testing URL against plugin: ${plugin.id}`);\n      \n      for (const pattern of plugin.urlPatterns) {\n        debugLogger.info(`Testing pattern: ${pattern.toString()}`);\n        \n        if (pattern.test(url)) {\n          debugLogger.info(`URL matches pattern for plugin: ${plugin.id}`);\n          \n          const id = plugin.extractId(url);\n          if (id) {\n            debugLogger.info(`Successfully extracted ID: ${id}`);\n            return { plugin, id };\n          } else {\n            debugLogger.warning(`Pattern matched but failed to extract ID`);\n          }\n        }\n      }\n    }\n    \n    debugLogger.warning(`No plugin found for URL: ${url}`);\n    return null;\n  }\n}\n\n// Export singleton instance\nexport const pluginRegistry = new PluginRegistry();\ndebugLogger.info('PluginRegistry singleton instance created');\n","// extension/papers/source_utils.ts\n// Fixed to export isNewFormat function\n\nimport { pluginRegistry } from './plugins/registry';\nimport { loguru } from '../utils/logger';\n\nconst logger = loguru.getLogger('SourceUtils');\n\n/**\n * Format a source-specific ID into a universal primary ID format\n * Uses source-specific formatId from plugin if available\n * \n * @param {string} source - Source type (e.g. 'arxiv', 'doi')\n * @param {string} id - Original source-specific identifier\n * @returns {string} Formatted primary ID\n */\nexport function formatPrimaryId(source: string, id: string): string {\n  // First check if we have a plugin for this source\n  const plugin = pluginRegistry.get(source);\n  \n  // Use plugin's formatId method if available\n  if (plugin && plugin.formatId) {\n    return plugin.formatId(id);\n  }\n  \n  // Sanitize the ID by replacing problematic characters\n  const safeId = id\n    .replace(/\\//g, '_')\n    .replace(/:/g, '.')\n    .replace(/\\s/g, '_')\n    .replace(/\\\\/g, '_');\n  \n  return `${source}.${safeId}`;\n}\n\n/**\n * Parse a primary ID into its source type and original source ID\n * \n * @param {string} prefixedId - The primary ID in the format \"{source_prefix}.{id}\"\n * @returns {Object} Object with source type and source ID\n */\nexport function parseId(prefixedId: string): { type: string; id: string } {\n  // Split at the first dot\n  const [prefix, ...idParts] = prefixedId.split('.');\n  const id = idParts.join('.'); // Rejoin in case ID contains periods\n  \n  // Map prefix to source type by looking up plugins\n  const plugins = pluginRegistry.getAll();\n  for (const plugin of plugins) {\n    // Check if the plugin's ID format matches the prefix\n    if (plugin.formatId) {\n      const sampleId = plugin.formatId('test');\n      const samplePrefix = sampleId.split('.')[0];\n      if (samplePrefix === prefix) {\n        return {\n          type: plugin.id,\n          id: id\n        };\n      }\n    }\n  }\n  \n  // Assume the prefix is the source type\n  return {\n    type: prefix,\n    id: prefix === 'doi' ? id.replace(/_/g, '/') : id\n  };\n}\n\n/**\n * Checks if a string is in the required prefixed format\n * @param {string} id - ID to check\n * @returns {boolean} True if the ID is in the correct format\n */\nexport function isNewFormat(id: string): boolean {\n  if (!id) return false;\n  \n  // Check if it contains a dot, which separates the source from the ID\n  return id.includes('.');\n}\n\n/**\n * Gets a display label for a source type using the plugin if available\n * \n * @param {string} sourceType - Source type\n * @returns {string} Human-readable label\n */\nexport function getSourceLabel(sourceType: string): string {\n  const plugin = pluginRegistry.get(sourceType);\n  if (plugin) {\n    return plugin.name;\n  }\n  \n  return sourceType.charAt(0).toUpperCase() + sourceType.slice(1);\n}\n\n/**\n * Get canonical URL for a paper using the plugin if available\n * \n * @param {string} sourceType - Source type\n * @param {string} id - Source ID\n * @returns {string} Canonical URL\n */\nexport function getCanonicalUrl(sourceType: string, id: string): string {\n  // First check if a plugin is available for this source\n  const plugin = pluginRegistry.get(sourceType);\n  if (plugin) {\n    // If the plugin has any URL patterns, try to construct a URL\n    if (plugin.urlPatterns && plugin.urlPatterns.length > 0) {\n      const pattern = plugin.urlPatterns[0].toString();\n      // Extract the domain and path pattern\n      const match = pattern.match(/([^/]+)(\\/[^)]+)/);\n      if (match) {\n        const domain = match[1].replace(/\\\\\\./, '.');\n        const path = match[2]\n          .replace(/\\\\\\//g, '/')\n          .replace(/\\([^)]+\\)/, id);\n        return `https://${domain}${path}`;\n      }\n    }\n  }\n  \n  switch (sourceType) {\n    case 'arxiv':\n      return `https://arxiv.org/abs/${id}`;\n    case 'semanticscholar':\n      return `https://www.semanticscholar.org/paper/${id}`;\n    case 'doi':\n      return `https://doi.org/${id}`;\n    case 'acm':\n      return `https://dl.acm.org/doi/${id}`;\n    case 'openreview':\n      return `https://openreview.net/forum?id=${id}`;\n    default:\n      return id.startsWith('10.') ? `https://doi.org/${id}` : \"\";\n  }\n}\n","// extension/papers/manager.ts\n// Refactored to remove legacy ID handling\n\nimport { GitHubStoreClient } from 'gh-store-client';\nimport type { Json } from 'gh-store-client';\nimport { \n  type PaperMetadata, \n  type InteractionLog, \n  type Interaction,\n  type ReadingSessionData\n} from './types';\nimport { formatPrimaryId } from './source_utils';\nimport { loguru } from '../utils/logger';\n\nconst logger = loguru.getLogger('PaperManager');\n\n/**\n * Checks if data is an interaction log\n */\nfunction isInteractionLog(data: any): data is InteractionLog {\n  return typeof data === \"object\" && \n         data !== null && \n         typeof data.paper_id === \"string\" && \n         Array.isArray(data.interactions);\n}\n\nexport class PaperManager {\n  private client: GitHubStoreClient;\n  // Concurrency control locks\n  private creationLocks = new Map<string, Promise<any>>();\n  \n  constructor(client: GitHubStoreClient) {\n    this.client = client;\n  }\n\n  /**\n   * Get or create a paper record\n   */\n  async getOrCreatePaper(paperData: any): Promise<any> {\n    // Ensure paperData has a primary_id\n    if (!paperData.primary_id) {\n      if (paperData.source && paperData.sourceId) {\n        paperData.primary_id = formatPrimaryId(paperData.source, paperData.sourceId);\n      } else {\n        throw new Error(\"Invalid paper data: missing primary_id and cannot generate it\");\n      }\n    }\n    \n    const objectId = `paper:${paperData.primary_id}`;\n    logger.info(`Getting or creating paper: ${objectId}`);\n    \n    try {\n      // Try to get the paper\n      const obj = await this.client.getObject(objectId);\n      const data = obj.data as Record<string, any>;\n      \n      logger.info(`Found existing paper: ${objectId}`);\n      return data;\n    } catch (error) {\n      if (error instanceof Error && error.message.includes(\"No object found\")) {\n        // Create new paper with appropriate fields\n        const defaultPaperData: Record<string, any> = {\n          primary_id: paperData.primary_id,\n          source: paperData.source,\n          sourceId: paperData.sourceId,\n          url: paperData.url || '',\n          title: paperData.title || paperData.sourceId,\n          authors: paperData.authors || '',\n          abstract: paperData.abstract || '',\n          timestamp: new Date().toISOString(),\n          rating: 'novote'\n        };\n        \n        // Add source-specific data directly\n        if (paperData.source_specific_metadata) {\n          defaultPaperData.source_specific_metadata = paperData.source_specific_metadata;\n        }\n        \n        // Always add identifiers object\n        defaultPaperData.identifiers = {\n          original: paperData.sourceId,\n          url: paperData.url\n        };\n        \n        // Add cross-references if available\n        if (paperData.doi) {\n          defaultPaperData.identifiers.doi = paperData.doi;\n        }\n        \n        logger.info(`Creating new paper object: ${objectId}`);\n        try {\n          await this.client.createObject(objectId, defaultPaperData);\n          logger.info(`Successfully created paper: ${objectId}`);\n          return defaultPaperData;\n        } catch (createError) {\n          logger.error(`Error creating paper object: ${createError}`);\n          throw createError;\n        }\n      }\n      logger.error(`Error in getOrCreatePaper: ${error}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Get or create an interaction log\n   */\n  private async getOrCreateInteractionLog(paperId: string): Promise<InteractionLog> {\n    const objectId = `interactions:${paperId}`;\n    \n    // Check if we're already creating this log\n    if (this.creationLocks.has(objectId)) {\n      logger.info(`Waiting for existing creation of interaction log: ${objectId}`);\n      return this.creationLocks.get(objectId) as Promise<InteractionLog>;\n    }\n    \n    // Create a new promise for this operation\n    const creationPromise = (async () => {\n      try {\n        const obj = await this.client.getObject(objectId);\n        const data = obj.data;\n        \n        if (isInteractionLog(data)) {\n          return data;\n        }\n        \n        throw new Error('Invalid interaction log format');\n      } catch (error) {\n        if (error instanceof Error && error.message.includes('No object found')) {\n          // Create new log\n          const newLog: InteractionLog = {\n            paper_id: paperId,\n            interactions: []\n          };\n          \n          logger.info(`Creating new interaction log: ${objectId}`);\n          await this.client.createObject(objectId, newLog);\n          return newLog;\n        }\n        throw error;\n      } finally {\n        // Release the lock after a delay\n        setTimeout(() => {\n          this.creationLocks.delete(objectId);\n        }, 500);\n      }\n    })();\n    \n    // Store the promise\n    this.creationLocks.set(objectId, creationPromise);\n    \n    return creationPromise;\n  }\n\n  /**\n   * Log a reading session for a paper\n   */\n  async logReadingSession(\n    paperId: string,\n    session: ReadingSessionData,\n    paperData?: any\n  ): Promise<void> {\n    // Ensure paper exists with proper data\n    if (paperData) {\n      if (!paperData.primary_id) {\n        paperData.primary_id = paperId;\n      }\n      await this.getOrCreatePaper(paperData);\n    }\n\n    // Log the session as interaction\n    await this.addInteraction(paperId, {\n      type: \"reading_session\",\n      timestamp: new Date().toISOString(),\n      data: session\n    });\n  }\n\n  /**\n   * Log an annotation for a paper\n   */\n  async logAnnotation(\n    paperId: string,\n    key: string,\n    value: Json,\n    paperData?: any\n  ): Promise<void> {\n    // Ensure paper exists with proper data\n    if (paperData) {\n      if (!paperData.primary_id) {\n        paperData.primary_id = paperId;\n      }\n      await this.getOrCreatePaper(paperData);\n    }\n\n    // Log the annotation as interaction\n    await this.addInteraction(paperId, {\n      type: \"annotation\",\n      timestamp: new Date().toISOString(),\n      data: { key, value }\n    });\n  }\n\n  /**\n   * Update a paper's rating\n   */\n  async updateRating(\n    paperId: string,\n    rating: string,\n    paperData?: any\n  ): Promise<void> {\n    // Get existing paper data\n    const paper = await this.getOrCreatePaper(paperData || { primary_id: paperId });\n\n    // Update rating\n    const objectId = `paper:${paperId}`;\n    await this.client.updateObject(objectId, { \n      ...paper,\n      rating \n    });\n\n    // Log rating change\n    await this.addInteraction(paperId, {\n      type: \"rating\",\n      timestamp: new Date().toISOString(),\n      data: { rating }\n    });\n  }\n\n  /**\n   * Add an interaction to a paper's log\n   */\n  private async addInteraction(paperId: string, interaction: Interaction): Promise<void> {\n    const log = await this.getOrCreateInteractionLog(paperId);\n    log.interactions.push(interaction);\n    \n    // Store with the standard format ID\n    const objectId = `interactions:${paperId}`;\n    await this.client.updateObject(objectId, log);\n  }\n\n  /**\n   * Get interactions for a paper\n   */\n  async getInteractions(\n    paperId: string,\n    options: {\n      type?: string;\n      startTime?: Date;\n      endTime?: Date;\n    } = {}\n  ): Promise<Interaction[]> {\n    try {\n      const log = await this.getOrCreateInteractionLog(paperId);\n      let interactions = log.interactions;\n\n      if (options.type) {\n        interactions = interactions.filter((i: Interaction) => i.type === options.type);\n      }\n\n      if (options.startTime || options.endTime) {\n        interactions = interactions.filter((i: Interaction) => {\n          const time = new Date(i.timestamp);\n          if (options.startTime && time < options.startTime) return false;\n          if (options.endTime && time > options.endTime) return false;\n          return true;\n        });\n      }\n\n      return interactions;\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('No object found')) {\n        return [];\n      }\n      throw error;\n    }\n  }\n  \n  /**\n   * Get total reading time for a paper\n   */\n  async getPaperReadingTime(paperId: string): Promise<number> {\n    const interactions = await this.getInteractions(paperId, { type: 'reading_session' });\n    return interactions.reduce((total, i) => {\n      const data = i.data;\n      if (typeof data === 'object' && data !== null && 'duration_seconds' in data) {\n        return total + (data.duration_seconds as number);\n      }\n      return total;\n    }, 0);\n  }\n\n  /**\n   * Get paper history\n   */\n  async getPaperHistory(paperId: string): Promise<Json[]> {\n    const objectId = `paper:${paperId}`;\n    return this.client.getObjectHistory(objectId);\n  }\n}\n","// extension/config/session.js\n\n// Default configuration values\nconst DEFAULT_CONFIG = {\n    idleThresholdMinutes: 5,\n    minSessionDurationSeconds: 30,\n    // Adding more granular control\n    requireContinuousActivity: true,  // If true, resets timer on idle\n    logPartialSessions: false,        // If true, logs sessions even if under minimum duration\n    activityUpdateIntervalSeconds: 1  // How often to update active time\n};\n\n// Load session configuration from storage\nasync function loadSessionConfig() {\n    const items = await chrome.storage.sync.get('sessionConfig');\n    return { ...DEFAULT_CONFIG, ...items.sessionConfig };\n}\n\n// Save session configuration to storage\nasync function saveSessionConfig(config) {\n    await chrome.storage.sync.set({\n        sessionConfig: {\n            idleThresholdMinutes: Number(config.idleThresholdMinutes),\n            minSessionDurationSeconds: Number(config.minSessionDurationSeconds),\n            requireContinuousActivity: Boolean(config.requireContinuousActivity),\n            logPartialSessions: Boolean(config.logPartialSessions),\n            activityUpdateIntervalSeconds: Number(config.activityUpdateIntervalSeconds)\n        }\n    });\n}\n\n// Convert configuration to milliseconds for internal use\nfunction getConfigurationInMs(config) {\n    return {\n        idleThreshold: config.idleThresholdMinutes * 60 * 1000,\n        minSessionDuration: config.minSessionDurationSeconds * 1000,\n        activityUpdateInterval: config.activityUpdateIntervalSeconds * 1000,\n        requireContinuousActivity: config.requireContinuousActivity,\n        logPartialSessions: config.logPartialSessions\n    };\n}\n\nexport { loadSessionConfig, saveSessionConfig, getConfigurationInMs, DEFAULT_CONFIG };","// extension/papers/plugins/loader.ts\n// Improved plugin loader with better initialization handling\n\nimport { loguru } from '../../utils/logger';\nimport { pluginRegistry } from './registry';\n\n// Import plugins directly (static import)\nimport * as plugins from './sources/index';\n\nconst logger = loguru.getLogger('PluginLoader');\n\n// Track plugin initialization state\nlet pluginsInitialized = false;\nlet initializationPromise: Promise<void> | null = null;\n\n/**\n * Load all built-in source plugins with improved error handling\n */\nasync function loadBuiltinPlugins(): Promise<void> {\n  logger.info('Loading built-in plugins');\n  \n  try {\n    // Plugins are already loaded via the static import\n    // This is just to check if they were properly registered\n    const pluginCount = pluginRegistry.getAll().length;\n    \n    if (pluginCount === 0) {\n      logger.warning('No plugins were registered. Attempting emergency registration.');\n      // Emergency fallback - directly import critical plugins\n      try {\n        await import('./sources/arxiv_plugin');\n        await import('./sources/semantic_scholar_plugin');\n        await import('./sources/openreview_plugin');\n        \n        // Check if emergency loading worked\n        const emergencyCount = pluginRegistry.getAll().length;\n        if (emergencyCount > 0) {\n          logger.info(`Emergency plugin loading successful: ${emergencyCount} plugins registered`);\n        } else {\n          throw new Error('Failed to load any plugins even with emergency loading');\n        }\n      } catch (emergencyError) {\n        logger.error('Emergency plugin loading failed:', emergencyError);\n        throw emergencyError;\n      }\n    } else {\n      logger.info(`${pluginCount} plugins are registered.`);\n    }\n  } catch (error) {\n    logger.error('Error loading plugins', error);\n    // Log detailed error information for debugging\n    if (error instanceof Error) {\n      logger.error(`Plugin loading error: ${error.message}`);\n      if (error.stack) {\n        logger.error(`Stack trace: ${error.stack}`);\n      }\n    }\n    // Rethrow to indicate initialization failure\n    throw error;\n  }\n}\n\n/**\n * Initialize the plugin system with retry capability\n * @param {number} retries Number of retries if initialization fails\n * @returns {Promise<void>}\n */\nexport async function initializePluginSystem(retries = 3): Promise<void> {\n  // If already initialized, return immediately\n  if (pluginsInitialized) {\n    return;\n  }\n  \n  // If initialization is in progress, return the existing promise\n  if (initializationPromise) {\n    return initializationPromise;\n  }\n  \n  // Start initialization\n  logger.info('Initializing plugin system');\n  \n  // Create a new initialization promise\n  initializationPromise = (async () => {\n    let attemptCount = 0;\n    let lastError: Error | null = null;\n    \n    // Try initialization with retries\n    while (attemptCount < retries) {\n      try {\n        await loadBuiltinPlugins();\n        \n        // Log loaded plugins\n        const loadedPlugins = pluginRegistry.getAll();\n        logger.info(`Initialized ${loadedPlugins.length} plugins:`);\n        \n        loadedPlugins.forEach(plugin => {\n          logger.info(`- ${plugin.name} (${plugin.id}) v${plugin.version}`);\n        });\n        \n        // Mark as successful\n        pluginsInitialized = true;\n        return;\n      } catch (error) {\n        attemptCount++;\n        lastError = error instanceof Error ? error : new Error(String(error));\n        logger.warning(`Plugin initialization attempt ${attemptCount} failed: ${lastError.message}`);\n        \n        if (attemptCount < retries) {\n          // Wait before retrying\n          const delay = Math.pow(2, attemptCount) * 500; // Exponential backoff\n          logger.info(`Retrying plugin initialization in ${delay}ms...`);\n          await new Promise(resolve => setTimeout(resolve, delay));\n        }\n      }\n    }\n    \n    // If we get here, all retries failed\n    logger.error(`Plugin initialization failed after ${retries} attempts.`);\n    if (lastError) {\n      throw lastError;\n    } else {\n      throw new Error('Plugin initialization failed for unknown reasons');\n    }\n  })();\n  \n  try {\n    await initializationPromise;\n    return;\n  } catch (error) {\n    // Reset the promise so future calls can try again\n    initializationPromise = null;\n    throw error;\n  }\n}\n\n/**\n * Check if plugins are initialized\n * @returns {boolean} True if plugins are initialized\n */\nexport function arePluginsInitialized(): boolean {\n  return pluginsInitialized;\n}\n\n/**\n * Get current plugin initialization state\n * @returns {Object} Initialization state\n */\nexport function getPluginInitializationState() {\n  return {\n    initialized: pluginsInitialized,\n    initializationInProgress: !!initializationPromise,\n    pluginCount: pluginRegistry.getAll().length\n  };\n}\n\n/**\n * Manually reset plugin initialization state\n * Used primarily for testing and emergency recovery\n */\nexport function resetPluginInitialization(): void {\n  pluginsInitialized = false;\n  initializationPromise = null;\n  logger.warning('Plugin initialization state has been reset');\n}\n","// extension/papers/url_detection_service.ts - Fixed version\n\nimport { pluginRegistry } from './plugins/registry';\nimport { formatPrimaryId } from './source_utils';\nimport { arePluginsInitialized, initializePluginSystem } from './plugins/loader';\nimport { loguru } from '../utils/logger';\n\nconst logger = loguru.getLogger('URLDetectionService');\n\n// Type definition for detected source information\nexport interface DetectedSourceInfo {\n  type: string;          // Source type (e.g., 'arxiv', 'doi')\n  id: string;            // Source-specific ID\n  primary_id: string;    // Universal primary ID \n  url: string;           // Original URL\n  plugin?: any;          // Associated plugin if available\n}\n\nclass URLDetectionService {\n  // Track URLs being processed to prevent duplicates\n  private pendingUrls = new Set<string>();\n  \n  // Debounce configuration\n  private debounceTime = 500; // ms\n  private debounceTimers = new Map<string, NodeJS.Timeout>();\n  \n  // Cache successful detections to avoid repeat processing\n  private detectionCache = new Map<string, DetectedSourceInfo>();\n  private maxCacheSize = 100;\n  \n  constructor() {\n    logger.info('URL Detection Service initialized');\n  }\n  \n  /**\n   * Detect paper source from URL\n   * @param {string} url URL to analyze\n   * @returns {Promise<DetectedSourceInfo|null>} Detected source info or null\n   */\n  async detectSource(url: string): Promise<DetectedSourceInfo | null> {\n    if (!url) {\n      logger.warning('Empty URL provided to detectSource');\n      return null;\n    }\n    \n    // First check cache\n    if (this.detectionCache.has(url)) {\n      logger.info(`Cache hit for ${url}`);\n      return this.detectionCache.get(url) as DetectedSourceInfo;\n    }\n    \n    // Ensure plugins are initialized\n    if (!arePluginsInitialized()) {\n      logger.info('Plugins not initialized, initializing now...');\n      try {\n        await initializePluginSystem();\n      } catch (error) {\n        logger.error('Failed to initialize plugins:', error);\n        return null;\n      }\n    }\n    \n    // Check if URL is already being processed\n    if (this.isUrlPending(url)) {\n      logger.info(`URL already being processed: ${url}`);\n      return null;\n    }\n    \n    try {\n      // Mark URL as pending\n      this.addPendingUrl(url);\n      \n      // Try using the plugin registry's findForUrl method first\n      const result = pluginRegistry.findForUrl(url);\n      if (result) {\n        const sourceInfo: DetectedSourceInfo = {\n          type: result.plugin.id,\n          id: result.id,\n          primary_id: result.plugin.formatId ? \n            result.plugin.formatId(result.id) : \n            formatPrimaryId(result.plugin.id, result.id),\n          url: url,\n          plugin: result.plugin\n        };\n        \n        // Add to cache\n        this.addToCache(url, sourceInfo);\n        \n        logger.info(`Detected source using plugin registry: ${sourceInfo.type}:${sourceInfo.id}`);\n        return sourceInfo;\n      }\n      \n      // Fall back to checking each plugin manually\n      const plugins = pluginRegistry.getAll();\n      \n      for (const plugin of plugins) {\n        for (const pattern of plugin.urlPatterns) {\n          const match = url.match(pattern);\n          if (match) {\n            const id = plugin.extractId(url);\n            if (id) {\n              const sourceInfo: DetectedSourceInfo = {\n                type: plugin.id,\n                id: id,\n                primary_id: plugin.formatId ? \n                  plugin.formatId(id) : \n                  formatPrimaryId(plugin.id, id),\n                url: url,\n                plugin: plugin\n              };\n              \n              // Add to cache\n              this.addToCache(url, sourceInfo);\n              \n              logger.info(`Detected source using manual check: ${sourceInfo.type}:${sourceInfo.id}`);\n              return sourceInfo;\n            }\n          }\n        }\n      }\n      \n      logger.info(`No matching source found for URL: ${url}`);\n      return null;\n    } finally {\n      // Clean up pending URL after a delay to prevent immediate reprocessing\n      this.removePendingUrlWithDelay(url);\n    }\n  }\n  \n  /**\n   * Check if a URL is valid for paper detection\n   * @param {string} url URL to check\n   * @returns {boolean} True if URL is valid\n   */\n  isValidUrl(url: string): boolean {\n    if (!url || typeof url !== 'string') return false;\n    \n    try {\n      // Basic URL validation\n      new URL(url);\n      \n      // Check for common academic domains\n      const commonDomains = [\n        'arxiv.org',\n        'semanticscholar.org',\n        'doi.org',\n        'dl.acm.org',\n        'openreview.net',\n        's2-research.org'\n      ];\n      \n      return commonDomains.some(domain => url.includes(domain));\n    } catch (e) {\n      return false;\n    }\n  }\n  \n  /**\n   * Check if URL is currently being processed\n   * @param {string} url URL to check\n   * @returns {boolean} True if URL is pending\n   */\n  isUrlPending(url: string): boolean {\n    return this.pendingUrls.has(url);\n  }\n  \n  /**\n   * Add URL to pending set\n   * @param {string} url URL to add\n   */\n  addPendingUrl(url: string): void {\n    this.pendingUrls.add(url);\n  }\n  \n  /**\n   * Remove URL from pending set\n   * @param {string} url URL to remove\n   */\n  removePendingUrl(url: string): void {\n    this.pendingUrls.delete(url);\n    \n    // Clear any existing timer\n    if (this.debounceTimers.has(url)) {\n      clearTimeout(this.debounceTimers.get(url));\n      this.debounceTimers.delete(url);\n    }\n  }\n  \n  /**\n   * Remove URL from pending set after a delay\n   * @param {string} url URL to remove\n   * @param {number} delay Delay in ms (default: debounceTime)\n   */\n  removePendingUrlWithDelay(url: string, delay?: number): void {\n    // Clear any existing timer\n    if (this.debounceTimers.has(url)) {\n      clearTimeout(this.debounceTimers.get(url) as NodeJS.Timeout);\n    }\n    \n    // Set new timer\n    const timer = setTimeout(() => {\n      this.pendingUrls.delete(url);\n      this.debounceTimers.delete(url);\n    }, delay || this.debounceTime);\n    \n    this.debounceTimers.set(url, timer);\n  }\n  \n  /**\n   * Add a successful detection to cache\n   * @param {string} url URL \n   * @param {DetectedSourceInfo} info Detection info\n   */\n  private addToCache(url: string, info: DetectedSourceInfo): void {\n    if (!url) {\n      logger.warning('Attempted to cache with empty URL');\n      return;\n    }\n    \n    // Implement LRU cache eviction if needed\n    if (this.detectionCache.size >= this.maxCacheSize) {\n      // Remove oldest entry (first key)\n      const oldestKey = this.detectionCache.keys().next().value;\n      if (oldestKey) {\n        this.detectionCache.delete(oldestKey);\n      }\n    }\n    \n    this.detectionCache.set(url, info);\n  }\n  \n  /**\n   * Clear the detection cache\n   */\n  clearCache(): void {\n    this.detectionCache.clear();\n  }\n  \n  /**\n   * Reset the service state\n   * Used for testing and emergency recovery\n   */\n  reset(): void {\n    // Clear pending URLs\n    this.pendingUrls.clear();\n    \n    // Clear all timers\n    for (const timer of this.debounceTimers.values()) {\n      clearTimeout(timer);\n    }\n    this.debounceTimers.clear();\n    \n    // Clear cache\n    this.clearCache();\n    \n    logger.info('URL Detection Service has been reset');\n  }\n  \n  /**\n   * Get service status information\n   * @returns {Object} Service status\n   */\n  getStatus(): any {\n    return {\n      pendingUrlsCount: this.pendingUrls.size,\n      activeTimersCount: this.debounceTimers.size,\n      cacheSize: this.detectionCache.size,\n      pluginsInitialized: arePluginsInitialized(),\n      pluginCount: pluginRegistry.getAll().length\n    };\n  }\n}\n\n// Export singleton instance\nexport const urlDetectionService = new URLDetectionService();\n","// extension/background_integration.ts - With service worker support\n\nimport { urlDetectionService, DetectedSourceInfo } from './papers/url_detection_service';\nimport { initializePluginSystem, getPluginInitializationState } from './papers/plugins/loader';\nimport { formatPrimaryId } from './papers/source_utils';\nimport { loguru } from './utils/logger';\n\n// Define NavDetails interface for Chrome API types\ninterface NavDetails {\n    tabId: number;\n    url: string;\n    frameId: number;\n    timeStamp: number;\n}\n\nconst logger = loguru.getLogger('BackgroundIntegration');\n\n/**\n * Initialize the enhanced services\n * @returns {Promise<void>}\n */\nexport async function initializeEnhancedServices(): Promise<void> {\n  logger.info('Initializing enhanced services');\n  \n  try {\n    // Initialize plugin system with retry capability\n    await initializePluginSystem(3);\n    \n    const pluginState = getPluginInitializationState();\n    logger.info('Plugin system initialized:', pluginState);\n    \n    // Add this integration module to the extension debug API\n    // Using 'self' for service worker context\n    if (typeof self !== 'undefined' && 'self' in globalThis && '__DEBUG__' in self) {\n      (self as any).__DEBUG__.enhancedServices = {\n        urlDetectionService,\n        getPluginState: getPluginInitializationState,\n        handleUrl: processUrl\n      };\n      \n      logger.info('Debug API extended with enhanced services');\n    }\n  } catch (error) {\n    logger.error('Failed to initialize enhanced services:', error);\n    throw error;\n  }\n}\n\n/**\n * Process a URL using the enhanced detection service\n * @param {string} url URL to process\n * @returns {Promise<DetectedSourceInfo|null>} Detection result\n */\nexport async function processUrl(url: string): Promise<DetectedSourceInfo | null> {\n  if (!urlDetectionService.isValidUrl(url)) {\n    logger.info(`Invalid or unsupported URL: ${url}`);\n    return null;\n  }\n  \n  try {\n    return await urlDetectionService.detectSource(url);\n  } catch (error) {\n    logger.error(`Error processing URL ${url}:`, error);\n    return null;\n  }\n}\n\n/**\n * Process a tab using the enhanced detection service\n * @param {chrome.tabs.Tab} tab Tab to process\n * @returns {Promise<DetectedSourceInfo|null>} Detection result\n */\nexport async function processTab(tab: chrome.tabs.Tab): Promise<DetectedSourceInfo | null> {\n  if (!tab.url) {\n    logger.info('Tab has no URL');\n    return null;\n  }\n  \n  return processUrl(tab.url);\n}\n\n/**\n * Process navigation event using the enhanced detection service\n * @param {NavDetails} details Navigation details\n * @returns {Promise<DetectedSourceInfo|null>} Detection result\n */\nexport async function processNavigation(details: NavDetails): Promise<DetectedSourceInfo | null> {\n  if (!details.url) {\n    logger.info('Navigation event has no URL');\n    return null;\n  }\n  \n  return processUrl(details.url);\n}\n\n/**\n * Extract metadata from a detected source\n * @param {DetectedSourceInfo} sourceInfo Source info\n * @returns {Promise<Object|null>} Extracted metadata or null\n */\nexport async function extractMetadataFromSource(sourceInfo: DetectedSourceInfo): Promise<any | null> {\n  if (!sourceInfo || !sourceInfo.plugin) {\n    logger.info('No valid source info or plugin');\n    return null;\n  }\n  \n  try {\n    // Try to use the plugin's API if available\n    if (sourceInfo.plugin.hasApi && sourceInfo.plugin.fetchApiData) {\n      try {\n        logger.info(`Using ${sourceInfo.plugin.id} plugin API to extract metadata`);\n        const apiData = await sourceInfo.plugin.fetchApiData(sourceInfo.id);\n        \n        if (apiData && Object.keys(apiData).length > 0) {\n          // Ensure required fields are present\n          return {\n            ...apiData,\n            source: sourceInfo.type,\n            sourceId: sourceInfo.id,\n            primary_id: sourceInfo.primary_id,\n            url: sourceInfo.url\n          };\n        }\n      } catch (apiError) {\n        logger.error(`Error using plugin API: ${apiError}`);\n      }\n    }\n    \n    // Fall back to default minimal data\n    return {\n      source: sourceInfo.type,\n      sourceId: sourceInfo.id,\n      primary_id: sourceInfo.primary_id,\n      url: sourceInfo.url,\n      title: `${sourceInfo.type.toUpperCase()} Paper: ${sourceInfo.id}`,\n      timestamp: new Date().toISOString(),\n      rating: 'novote'\n    };\n  } catch (error) {\n    logger.error(`Error extracting metadata: ${error}`);\n    return null;\n  }\n}\n\n/**\n * Process a document with DOM access using the given tab\n * @param {number} tabId Tab ID for DOM access\n * @param {DetectedSourceInfo} sourceInfo Source info\n * @returns {Promise<Object|null>} Extracted metadata or null\n */\nexport async function extractMetadataFromDOM(tabId: number, sourceInfo: DetectedSourceInfo): Promise<any | null> {\n  if (!sourceInfo || !sourceInfo.plugin || !sourceInfo.plugin.extractMetadata) {\n    return null;\n  }\n  \n  try {\n    logger.info(`Attempting DOM extraction for ${sourceInfo.type}`);\n    \n    // Execute script to get HTML document\n    const script = await chrome.scripting.executeScript({\n      target: { tabId },\n      func: () => document.documentElement.outerHTML\n    });\n    \n    if (script && script[0] && script[0].result) {\n      // Create DOM document from HTML for service worker context\n      // Use non-DOM parser for service worker environment\n      try {\n        const htmlString = script[0].result as string;\n        \n        // Since we're in a service worker, we need to use a different approach for metadata extraction\n        // Ask the plugin to extract metadata - must be a service worker safe implementation\n        const metadata = await sourceInfo.plugin.extractMetadata({\n          documentElement: { outerHTML: htmlString }\n        }, sourceInfo.url);\n        \n        if (metadata && Object.keys(metadata).length > 0) {\n          return {\n            ...metadata,\n            source: sourceInfo.type,\n            sourceId: sourceInfo.id,\n            primary_id: sourceInfo.primary_id,\n            url: sourceInfo.url\n          };\n        }\n      } catch (parserError) {\n        logger.error(`Error parsing HTML in service worker: ${parserError}`);\n        // Fall back to direct string content\n        try {\n          // Use a simpler approach - pass the HTML as a string\n          const metadata = await sourceInfo.plugin.extractMetadata(\n            { innerHTML: script[0].result },\n            sourceInfo.url\n          );\n          \n          if (metadata && Object.keys(metadata).length > 0) {\n            return {\n              ...metadata,\n              source: sourceInfo.type,\n              sourceId: sourceInfo.id,\n              primary_id: sourceInfo.primary_id,\n              url: sourceInfo.url\n            };\n          }\n        } catch (fallbackError) {\n          logger.error(`Error with fallback metadata extraction: ${fallbackError}`);\n        }\n      }\n    }\n  } catch (error) {\n    logger.error(`Error extracting metadata from DOM: ${error}`);\n  }\n  \n  return null;\n}\n\n/**\n * Fully process a URL with all enhanced services\n * @param {string} url URL to process\n * @param {number|null} tabId Optional tab ID for DOM access\n * @returns {Promise<Object|null>} Full paper data or null\n */\nexport async function fullyProcessUrl(url: string, tabId: number | null = null): Promise<any | null> {\n  try {\n    // Detect source\n    const sourceInfo = await processUrl(url);\n    \n    if (!sourceInfo) {\n      logger.info(`No source detected for URL: ${url}`);\n      return null;\n    }\n    \n    logger.info(`Detected ${sourceInfo.type} paper: ${sourceInfo.id}`);\n    \n    // Try API metadata extraction first\n    let paperData = await extractMetadataFromSource(sourceInfo);\n    \n    // If API extraction failed or returned minimal data and we have a tab ID,\n    // try DOM extraction as a fallback\n    if (tabId && (!paperData || !paperData.title || paperData.title.includes(sourceInfo.id))) {\n      logger.info('API extraction failed or returned minimal data, trying DOM extraction');\n      const domData = await extractMetadataFromDOM(tabId, sourceInfo);\n      \n      if (domData) {\n        // Merge API and DOM data, with DOM data taking precedence\n        paperData = {\n          ...paperData,\n          ...domData,\n          // Ensure critical fields are preserved\n          source: sourceInfo.type,\n          sourceId: sourceInfo.id,\n          primary_id: sourceInfo.primary_id,\n          url: sourceInfo.url\n        };\n      }\n    }\n    \n    if (paperData) {\n      logger.info(`Successfully processed paper: ${paperData.title || paperData.primary_id}`);\n    }\n    \n    return paperData;\n  } catch (error) {\n    logger.error(`Error fully processing URL ${url}:`, error);\n    return null;\n  }\n}\n","// background.js - Updated with unified approach and plugin handling improvements\n\nimport { GitHubStoreClient } from 'gh-store-client';\nimport { PaperManager } from './papers/manager';\nimport { loadSessionConfig, getConfigurationInMs } from './config/session.js';\nimport { formatPrimaryId } from './papers/source_utils';\nimport { initializePluginSystem } from './papers/plugins/loader';\nimport { pluginRegistry } from './papers/plugins/registry';\nimport { loguru } from './utils/logger';\n\n// Import the new enhanced services\nimport { \n  initializeEnhancedServices, \n  processNavigation,\n  processTab,\n  fullyProcessUrl \n} from './background_integration';\n\nconst logger = loguru.getLogger('Background');\n\n// Global state\nlet githubToken = '';\nlet githubRepo = '';\nlet currentPaperData = null;\nlet currentSession = null;\nlet activityInterval = null;\nlet sessionConfig = null;\nlet paperManager = null;\n\n// Debounce mechanism to avoid multiple creations of the same paper\nconst pendingUrls = new Set();\n\n// Enhanced reading session for modern format\nclass EnhancedReadingSession {\n  constructor(paperData, config) {\n    // Validate required fields\n    if (!paperData.primary_id) {\n      throw new Error('Paper data must include primary_id');\n    }\n    \n    this.paperId = paperData.primary_id;\n    this.paperData = paperData;\n    \n    // Generate unique session ID\n    this.sessionId = `session_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n    \n    // Initialize timing data\n    this.startTime = new Date();\n    this.activeTime = 0;\n    this.idleTime = 0;\n    this.lastActiveTime = new Date();\n    this.isTracking = true;\n    this.config = config;\n    this.endTime = null;\n    this.finalizedData = null;\n  }\n  \n  update() {\n    if (this.isTracking && !this.finalizedData) {\n      const now = new Date();\n      const timeSinceLastActive = now.getTime() - this.lastActiveTime.getTime();\n      \n      if (timeSinceLastActive < this.config.idleThreshold) {\n        this.activeTime += timeSinceLastActive;\n      } else {\n        this.idleTime += timeSinceLastActive;\n      }\n      \n      this.lastActiveTime = now;\n    }\n  }\n  \n  finalize() {\n    if (this.finalizedData) {\n      return this.finalizedData;\n    }\n \n    this.update();\n    this.isTracking = false;\n    this.endTime = new Date();\n    const totalElapsed = this.endTime.getTime() - this.startTime.getTime();\n \n    if (this.activeTime >= this.config.minSessionDuration) {\n      this.finalizedData = {\n        session_id: this.sessionId,\n        duration_seconds: Math.round(this.activeTime / 1000),\n        idle_seconds: Math.round(this.idleTime / 1000),\n        start_time: this.startTime.toISOString(),\n        end_time: this.endTime.toISOString(),\n        total_elapsed_seconds: Math.round(totalElapsed / 1000)\n      };\n      return this.finalizedData;\n    }\n    return null;\n  }\n  \n  getMetadata() {\n    return {\n      sourceType: this.paperData.source,\n      paperId: this.paperId,\n      title: this.paperData.title,\n      sessionId: this.sessionId,\n      startTime: this.startTime.toISOString(),\n      activeSeconds: Math.round(this.activeTime / 1000),\n      idleSeconds: Math.round(this.idleTime / 1000)\n    };\n  }\n}\n\n// Load credentials and configuration when extension starts\nasync function loadCredentials() {\n  const items = await chrome.storage.sync.get(['githubToken', 'githubRepo']);\n  githubToken = items.githubToken || '';\n  githubRepo = items.githubRepo || '';\n  logger.info('Credentials loaded:', { hasToken: !!githubToken, hasRepo: !!githubRepo });\n  \n  // Initialize paper manager if we have credentials\n  if (githubToken && githubRepo) {\n    const githubClient = new GitHubStoreClient(githubToken, githubRepo);\n    paperManager = new PaperManager(githubClient);\n    logger.info('Paper manager initialized');\n  }\n  \n  // Load session configuration\n  sessionConfig = getConfigurationInMs(await loadSessionConfig());\n  logger.info('Session configuration loaded:', sessionConfig);\n  \n  // Initialize debug objects\n  initializeDebugObjects();\n}\n\n// Listen for credential changes\nchrome.storage.onChanged.addListener(async (changes) => {\n  logger.info('Storage changes detected:', Object.keys(changes));\n  if (changes.githubToken) {\n    githubToken = changes.githubToken.newValue;\n  }\n  if (changes.githubRepo) {\n    githubRepo = changes.githubRepo.newValue;\n  }\n  if (changes.sessionConfig) {\n    sessionConfig = getConfigurationInMs(changes.sessionConfig.newValue);\n    logger.info('Session configuration updated:', sessionConfig);\n  }\n  \n  // Reinitialize paper manager if credentials changed\n  if (changes.githubToken || changes.githubRepo) {\n    if (githubToken && githubRepo) {\n      const githubClient = new GitHubStoreClient(githubToken, githubRepo);\n      paperManager = new PaperManager(githubClient);\n      logger.info('Paper manager reinitialized');\n    }\n  }\n});\n\n// Update the initialize function to include the enhanced services\nasync function initialize() {\n  logger.info('Initializing extension');\n  \n  // Load credentials and config\n  await loadCredentials();\n  \n  // Initialize enhanced services (includes plugin system)\n  await initializeEnhancedServices();\n  \n  // Set up listeners for tab changes\n  await setupListeners();\n  \n  logger.info('Extension initialized');\n}\n\n// Initialize extension\ninitialize().catch(error => {\n  logger.error('Initialization failed', error);\n});\n\n// Message passing between background and popup/content scripts\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  logger.info('Message received:', request);\n  \n  if (request.type === 'getCurrentPaper') {\n    logger.info('Popup requested current paper:', currentPaperData);\n    sendResponse(currentPaperData);\n  }\n  else if (request.type === 'updateRating') {\n    logger.info('Rating update requested:', request.rating);\n    handleUpdateRating(request.rating, sendResponse);\n    return true; // Will respond asynchronously\n  }\n  else if (request.type === 'updateAnnotation') {\n    logger.info('Annotation update requested:', request.annotationType, request.data);\n    handleAnnotationUpdate(request.annotationType, request.data)\n      .then(response => sendResponse(response))\n      .catch(error => sendResponse({ success: false, error: error.message }));\n    return true; // Will respond asynchronously\n  }\n  // Add a dedicated handler for track paper requests from content scripts\n  else if (request.type === 'trackPaper') {\n    logger.info('Track paper requested:', request);\n    handleTrackPaper(request)\n      .then(response => sendResponse(response))\n      .catch(error => sendResponse({ success: false, error: error.message }));\n    return true; // Will respond asynchronously\n  }\n  return true;\n});\n\n// Replace the handleTrackPaper function\nasync function handleTrackPaper(request) {\n  if (!paperManager) {\n    throw new Error('Paper manager not initialized');\n  }\n\n  try {\n    // Process the paper URL using enhanced services\n    let paperData;\n    \n    if (request.url) {\n      // If it's a URL, use fullyProcessUrl\n      paperData = await fullyProcessUrl(request.url);\n    } else if (request.source && request.id) {\n      // If it's just source and ID, create basic data\n      const primary_id = formatPrimaryId(request.source, request.id);\n      paperData = {\n        source: request.source,\n        sourceId: request.id,\n        primary_id: primary_id,\n        url: request.url || '',\n        title: request.title || `${request.source.toUpperCase()} Paper: ${request.id}`,\n        timestamp: new Date().toISOString(),\n        rating: 'novote'\n      };\n    } else {\n      throw new Error('Invalid request: missing URL or source/id');\n    }\n    \n    if (!paperData) {\n      throw new Error(`Could not process paper: ${request.url || request.id}`);\n    }\n    \n    // Create GitHub issue for the paper\n    const createdPaper = await createGithubIssue(paperData);\n    \n    return { success: true, paperData: createdPaper };\n  } catch (error) {\n    logger.error(`Error tracking paper: ${error}`);\n    throw error;\n  }\n}\n\nasync function handleUpdateRating(rating, sendResponse) {\n  if (!paperManager) {\n    sendResponse({ success: false, error: 'Paper manager not initialized' });\n    return;\n  }\n\n  if (!currentPaperData) {\n    sendResponse({ success: false, error: 'No current paper' });\n    return;\n  }\n\n  try {\n    // Always use primary_id for rating updates\n    const paperId = currentPaperData.primary_id;\n    await paperManager.updateRating(paperId, rating, currentPaperData);\n    currentPaperData.rating = rating;\n    sendResponse({ success: true });\n  } catch (error) {\n    logger.error('Error updating rating:', error);\n    sendResponse({ success: false, error: error.message });\n  }\n}\n\n// Consolidated setup for all navigation and tab listeners\nasync function setupListeners() {\n  logger.info('Setting up unified event listeners');\n  \n  // Get all supported hosts from plugins\n  const plugins = pluginRegistry.getAll();\n  \n  // Create host patterns from all plugins\n  const hostPatterns = [];\n  \n  for (const plugin of plugins) {\n    // Add all the plugin URL patterns if possible\n    try {\n      // Extract domain patterns from the plugin's URL patterns\n      for (const pattern of plugin.urlPatterns) {\n        const patternStr = pattern.toString();\n        // Extract domain from pattern - this is a simplified approach\n        const match = patternStr.match(/([a-zA-Z0-9.-]+)\\\\?\\.([a-zA-Z]+)/);\n        if (match) {\n          const domain = match[1];\n          const tld = match[2];\n          hostPatterns.push({ hostSuffix: `${domain}.${tld}` });\n        }\n      }\n    } catch (err) {\n      logger.error(`Error processing plugin URL patterns: ${err}`);\n    }\n  }\n  \n  // Add default patterns if we couldn't extract from plugins\n  if (hostPatterns.length === 0) {\n    hostPatterns.push(\n      { hostSuffix: 'arxiv.org' },\n      { hostSuffix: 'semanticscholar.org' },\n      { hostSuffix: 'doi.org' },\n      { hostSuffix: 'dl.acm.org' },\n      { hostSuffix: 'openreview.net' }\n    );\n  }\n  \n  logger.info(`Setting up navigation listener with patterns: ${JSON.stringify(hostPatterns)}`);\n  \n  // CONSOLIDATED LISTENER: Set up a single navigation listener with all hosts\n  chrome.webNavigation.onCompleted.addListener(handleUnifiedNavigation, { \n    url: hostPatterns\n  });\n  \n  // CONSOLIDATED LISTENER: Set up a single tab activation listener\n  chrome.tabs.onActivated.addListener(handleUnifiedTabActivation);\n  \n  // CONSOLIDATED LISTENER: Set up a single tab update listener\n  chrome.tabs.onUpdated.addListener(handleUnifiedTabUpdate);\n  \n  // Window focus changes\n  chrome.windows.onFocusChanged.addListener((windowId) => {\n    if (windowId === chrome.windows.WINDOW_ID_NONE) {\n      endCurrentSession();\n    }\n  });\n  \n  logger.info('All event listeners initialized');\n}\n\n// Helper function to find the appropriate plugin for a URL\nfunction findPluginForUrl(url) {\n  // Try using the plugin registry's dedicated method\n  const result = pluginRegistry.findForUrl(url);\n  if (result) {\n    return {\n      type: result.plugin.id,\n      id: result.id,\n      primary_id: result.plugin.formatId ? \n        result.plugin.formatId(result.id) : \n        formatPrimaryId(result.plugin.id, result.id),\n      plugin: result.plugin\n    };\n  }\n  \n  // Fall back to manual checking of all plugins\n  const plugins = pluginRegistry.getAll();\n  \n  for (const plugin of plugins) {\n    for (const pattern of plugin.urlPatterns) {\n      const match = url.match(pattern);\n      if (match) {\n        const id = plugin.extractId(url);\n        if (id) {\n          return {\n            type: plugin.id,\n            id: id,\n            primary_id: plugin.formatId ? plugin.formatId(id) : formatPrimaryId(plugin.id, id),\n            plugin: plugin\n          };\n        }\n      }\n    }\n  }\n  \n  // No plugin match\n  return null;\n}\n\n// Replace the handleUnifiedNavigation function\nasync function handleUnifiedNavigation(details) {\n  logger.info(`Unified navigation handler: ${details.url}`);\n  \n  try {\n    // Use enhanced detection service\n    const sourceInfo = await processNavigation(details);\n    \n    if (!sourceInfo) {\n      logger.info('Not a recognized paper URL');\n      return;\n    }\n    \n    logger.info(`Detected paper: ${sourceInfo.type}:${sourceInfo.id}`);\n    \n    // Check if tab is active\n    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n    if (tabs.length > 0 && tabs[0].id === details.tabId) {\n      // This is the active tab, handle as tab change\n      await handleTabChangeWithPlugins(tabs[0]);\n    } else {\n      // Process URL but don't start a session\n      const paperData = await fullyProcessUrl(details.url);\n      if (paperData) {\n        logger.info(`Processed paper data: ${paperData.title}`);\n      }\n    }\n  } catch (error) {\n    logger.error(`Error in navigation handler: ${error}`);\n  }\n}\n\nasync function handleUnifiedTabActivation(activeInfo) {\n  logger.info(`Unified tab activation handler: ${activeInfo.tabId}`);\n  const tab = await chrome.tabs.get(activeInfo.tabId);\n  \n  if (!tab.url || pendingUrls.has(tab.url)) {\n    logger.info(`Tab URL empty or already being processed: ${tab.url}`);\n    return;\n  }\n  \n  try {\n    // Mark URL as being processed\n    pendingUrls.add(tab.url);\n    \n    // Delegate to the appropriate handler\n    await handleTabChangeWithPlugins(tab);\n  } catch (error) {\n    logger.error(`Error in tab activation handler: ${error}`);\n  } finally {\n    setTimeout(() => {\n      pendingUrls.delete(tab.url);\n    }, 500);\n  }\n}\n\nasync function handleUnifiedTabUpdate(tabId, changeInfo, tab) {\n  if (changeInfo.status !== 'complete' || !tab.url || pendingUrls.has(tab.url)) {\n    return;\n  }\n  \n  logger.info(`Unified tab update handler: ${tab.url}`);\n  \n  try {\n    // Mark URL as being processed\n    pendingUrls.add(tab.url);\n    \n    // Delegate to the appropriate handler\n    await handleTabChangeWithPlugins(tab);\n  } catch (error) {\n    logger.error(`Error in tab update handler: ${error}`);\n  } finally {\n    setTimeout(() => {\n      pendingUrls.delete(tab.url);\n    }, 500);\n  }\n}\n\n// Replace the processPaperUrl function\nasync function processPaperUrl(url) {\n  logger.info(`Processing paper URL: ${url}`);\n  \n  try {\n    // Use the enhanced services for full processing\n    return await fullyProcessUrl(url);\n  } catch (error) {\n    logger.error(`Error processing paper URL: ${error}`);\n    return null;\n  }\n}\n\n// Replace the handleTabChangeWithPlugins function\nasync function handleTabChangeWithPlugins(tab) {\n  if (!tab.url) return;\n  \n  // Use enhanced detection service\n  const sourceInfo = await processTab(tab);\n  \n  if (!sourceInfo) {\n    logger.info('Not a recognized paper page, ending current session');\n    await endCurrentSession();\n    return;\n  }\n  // End any existing session\n  if (currentSession) {\n    logger.info('Ending existing session before starting new one');\n    await endCurrentSession();\n  }\n\n  // Process the paper URL with full metadata extraction\n  logger.info(`Processing paper URL: ${tab.url}`);\n  const paperData = await fullyProcessUrl(tab.url, tab.id);\n  \n  if (paperData) {\n    logger.info(`Starting new session for: ${paperData.primary_id}`);\n    \n    // Store current paper data\n    currentPaperData = paperData;\n    \n    // Create a new reading session\n    currentSession = new EnhancedReadingSession(paperData, sessionConfig);\n    \n    const metadata = currentSession.getMetadata();\n    logger.info('New session created:', metadata);\n    \n    // Start tracking reading time\n    startActivityTracking();\n    \n    // Create GitHub issue\n    logger.info(`Creating GitHub issue for: ${paperData.primary_id}`);\n    try {\n      await createGithubIssue(paperData);\n    } catch (error) {\n      logger.error(`Error creating GitHub issue: ${error}`);\n    }\n  }\n}\n\n\nasync function endCurrentSession() {\n  if (currentSession && currentPaperData) {\n    logger.info(`Ending session for: ${currentPaperData.primary_id}`);\n    const sessionData = currentSession.finalize();\n    if (sessionData) {\n      logger.info('Creating reading event:', sessionData);\n      await createReadingEvent(currentPaperData, sessionData);\n    }\n    currentSession = null;\n    currentPaperData = null;\n    stopActivityTracking();\n  }\n}\n\nfunction startActivityTracking() {\n  if (!activityInterval) {\n    logger.info('Starting activity tracking');\n    activityInterval = setInterval(() => {\n      if (currentSession) {\n        currentSession.update();\n      }\n    }, sessionConfig.activityUpdateInterval);\n  }\n}\n\nfunction stopActivityTracking() {\n  if (activityInterval) {\n    clearInterval(activityInterval);\n    activityInterval = null;\n  }\n}\n\n// Create reading event function for all sources\nasync function createReadingEvent(paperData, sessionData) {\n  if (!paperManager || !paperData) {\n    logger.error('Missing required data for creating reading event:', {\n      hasPaperManager: !!paperManager,\n      hasPaperData: !!paperData\n    });\n    return;\n  }\n\n  try {\n    // Always use primary_id for storage\n    if (!paperData.primary_id) {\n      logger.error('Paper data missing primary_id. This should not happen.');\n      return;\n    }\n    \n    const paperId = paperData.primary_id;\n    \n    await paperManager.logReadingSession(\n      paperId,\n      sessionData,\n      paperData\n    );\n    \n    logger.info('Reading session logged:', {\n      paperId: paperId,\n      sessionId: sessionData.session_id,\n      activeTime: sessionData.duration_seconds,\n      idleTime: sessionData.idle_seconds,\n      totalTime: sessionData.total_elapsed_seconds\n    });\n    \n  } catch (error) {\n    logger.error('Error logging reading session:', error);\n  }\n}\n\n// GitHub issue creation function\nasync function createGithubIssue(paperData) {\n  if (!paperManager) {\n    logger.error('Paper manager not initialized');\n    return null;\n  }\n\n  // Ensure paper has primary_id\n  if (!paperData.primary_id) {\n    if (paperData.source && paperData.sourceId) {\n      paperData.primary_id = formatPrimaryId(paperData.source, paperData.sourceId);\n    } else {\n      logger.error('Cannot create paper - no valid identifier');\n      return null;\n    }\n  }\n  \n  try {\n    logger.info(`Creating/getting paper issue: ${paperData.primary_id}`);\n    const existingPaper = await paperManager.getOrCreatePaper(paperData);\n    logger.info(`Paper metadata stored/retrieved: ${existingPaper.primary_id}`);\n    return existingPaper;\n  } catch (error) {\n    logger.error(`Error handling paper metadata: ${error}`, error);\n    return null;\n  }\n}\n\nasync function handleAnnotationUpdate(type, data) {\n  if (!paperManager) {\n    throw new Error('Paper manager not initialized');\n  }\n\n  try {\n    // Ensure we have a valid paper ID\n    let paperId = data.paperId;\n    \n    // If we get a legacy ID without the source prefix, try to determine the source from context\n    if (!paperId.includes('.')) {\n      // Try to determine source from data\n      const source = data.source || 'arxiv'; // Default to arxiv if not specified\n      paperId = formatPrimaryId(source, paperId);\n      logger.info(`Converted ID to standardized format: ${paperId}`);\n    }\n    \n    const paperData = data.title ? {\n      title: data.title,\n      source: data.source,\n      primary_id: paperId\n    } : undefined;\n\n    if (type === 'vote') {\n      await paperManager.updateRating(\n        paperId,\n        data.vote,\n        paperData\n      );\n    } else {\n      await paperManager.logAnnotation(\n        paperId,\n        'notes',\n        data.notes,\n        paperData\n      );\n    }\n\n    return { success: true };\n  } catch (error) {\n    logger.error('Error logging interaction:', error);\n    throw error;\n  }\n}\n\n// Initialize debug objects in service worker scope\nfunction initializeDebugObjects() {\n  // Don't use window in service worker context\n  self.__DEBUG__ = {\n    get paperManager() { return paperManager; },\n    getGithubClient: () => paperManager?.client,\n    getCurrentPaper: () => currentPaperData,\n    getCurrentSession: () => currentSession,\n    getConfig: () => sessionConfig\n  };\n\n  logger.info('Debug objects registered, access via __DEBUG__ in service worker console');\n}\n"],"file":"background.bundle.js"}