{"version":3,"file":"index-CeCyCSyP.js","sources":["../../utils/logger.ts","../../source-integration/arxiv/xml-parser.ts","../../utils/metadata-transformer.ts","../../source-integration/arxiv/index.ts"],"sourcesContent":["// utils/logger.ts\n// Logging utility wrapping loguru\n\n/**\n * Logger class for consistent logging throughout the extension\n */\nexport class Logger {\n  constructor(private module: string) {}\n  \n  /**\n   * Log debug message\n   */\n  debug(message: string, data?: any): void {\n    console.debug(`[${this.module}] ${message}`, data !== undefined ? data : '');\n  }\n  \n  /**\n   * Log info message\n   */\n  info(message: string, data?: any): void {\n    console.info(`[${this.module}] ${message}`, data !== undefined ? data : '');\n  }\n  \n  /**\n   * Log warning message\n   */\n  warning(message: string, data?: any): void {\n    console.warn(`[${this.module}] ${message}`, data !== undefined ? data : '');\n  }\n  \n  /**\n   * Log error message\n   */\n  error(message: string, data?: any): void {\n    console.error(`[${this.module}] ${message}`, data !== undefined ? data : '');\n  }\n}\n\n/**\n * Loguru mock for browser extension use\n */\nclass LoguruMock {\n  /**\n   * Get logger for a module\n   */\n  getLogger(module: string): Logger {\n    return new Logger(module);\n  }\n}\n\n// Export singleton instance\nexport const loguru = new LoguruMock();\n","// source-integration/arxiv/xml-parser.ts\n// ArXiv API XML response parser - simplified for use with metadata transformer\n\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('arxiv-xml-parser');\n\nexport interface ArXivParsedData {\n  title: string;\n  summary: string;\n  authors: string[];\n  published_date: string;\n  arxiv_tags: string[];\n  [key: string]: any; // Add index signature to satisfy Json type requirements\n}\n\n/**\n * Parse ArXiv API XML response into a structured object\n */\nexport async function parseXMLText(xmlText: string): Promise<ArXivParsedData | null> {\n  logger.debug('Parsing ArXiv XML response');\n  \n  try {\n    // Parse XML to DOM\n    const parser = new DOMParser();\n    const xmlDoc = parser.parseFromString(xmlText, \"text/xml\");\n    \n    // Check for parse errors\n    const parseError = xmlDoc.querySelector('parsererror');\n    if (parseError) {\n      throw new Error('XML parsing error: ' + parseError.textContent);\n    }\n    \n    // Get entry element\n    const entry = xmlDoc.querySelector('entry');\n    if (!entry) {\n      throw new Error('No entry element found in XML');\n    }\n    \n    // Extract basic fields\n    const title = entry.querySelector('title')?.textContent?.trim() || '';\n    const summary = entry.querySelector('summary')?.textContent?.trim() || '';\n    const published = entry.querySelector('published')?.textContent?.trim() || '';\n    \n    // Extract authors\n    const authors = Array.from(entry.querySelectorAll('author name'))\n      .map(name => name.textContent?.trim() || '');\n    \n    // Extract categories/tags\n    const categories = new Set<string>();\n    \n    // Primary category\n    const primaryCategory = entry.querySelector('arxiv\\\\:primary_category, primary_category');\n    if (primaryCategory && primaryCategory.hasAttribute('term')) {\n      categories.add(primaryCategory.getAttribute('term') || '');\n    }\n    \n    // Other categories\n    const categoryElements = entry.querySelectorAll('category');\n    categoryElements.forEach(cat => {\n      if (cat.hasAttribute('term')) {\n        categories.add(cat.getAttribute('term') || '');\n      }\n    });\n    \n    const result: ArXivParsedData = {\n      title,\n      summary,\n      authors,\n      published_date: published,\n      arxiv_tags: Array.from(categories)\n    };\n    \n    logger.debug('XML parsing completed successfully');\n    return result;\n  } catch (error) {\n    logger.error('Error parsing ArXiv XML', error);\n    return null;\n  }\n}\n","// extension/utils/metadata-transformer.ts\n// Generic metadata transformation utilities\n\nimport { PaperMetadata } from '../papers/types';\nimport { loguru } from './logger';\n\nconst logger = loguru.getLogger('metadata-transformer');\n\n/**\n * Interface for source-specific metadata mapping\n */\nexport interface MetadataMapping {\n  // Maps source-specific fields to standard metadata\n  titleField: string | string[];\n  authorsField: string | string[];\n  abstractField: string | string[];\n  dateField: string | string[];\n  tagsField: string | string[];\n  \n  // Optional custom extraction functions\n  extractAuthors?: (data: any) => string;\n  extractTags?: (data: any) => string[];\n  extractDate?: (data: any) => string;\n}\n\n/**\n * Transform source-specific API response to standard metadata\n */\nexport function transformMetadata(\n  sourceId: string,\n  paperId: string,\n  apiData: any,\n  mapping: MetadataMapping,\n  sourceUrl: string\n): PaperMetadata {\n  // Extract fields using provided mapping\n  const getField = (data: any, fieldPath: string | string[]): any => {\n    if (Array.isArray(fieldPath)) {\n      // Try multiple possible field paths\n      for (const path of fieldPath) {\n        const value = getField(data, path);\n        if (value !== undefined && value !== null && value !== '') {\n          return value;\n        }\n      }\n      return '';\n    }\n    \n    // Handle nested paths like \"document.title\"\n    const parts = fieldPath.split('.');\n    let value = data;\n    \n    for (const part of parts) {\n      if (value === undefined || value === null) return '';\n      value = value[part];\n    }\n    \n    return value !== undefined && value !== null ? value : '';\n  };\n  \n  // Extract title\n  const title = getField(apiData, mapping.titleField);\n  \n  // Extract authors - either use custom function or default extraction\n  const authors = mapping.extractAuthors \n    ? mapping.extractAuthors(apiData)\n    : Array.isArray(getField(apiData, mapping.authorsField))\n      ? getField(apiData, mapping.authorsField).join(', ')\n      : getField(apiData, mapping.authorsField);\n  \n  // Extract abstract\n  const abstract = getField(apiData, mapping.abstractField);\n  \n  // Extract published date\n  const publishedDate = mapping.extractDate\n    ? mapping.extractDate(apiData)\n    : getField(apiData, mapping.dateField);\n  \n  // Extract tags\n  const tags = mapping.extractTags\n    ? mapping.extractTags(apiData)\n    : Array.isArray(getField(apiData, mapping.tagsField))\n      ? getField(apiData, mapping.tagsField)\n      : [];\n  \n  const metadata: PaperMetadata = {\n    sourceId,\n    paperId,\n    url: sourceUrl,\n    title,\n    authors,\n    abstract,\n    timestamp: new Date().toISOString(),\n    rating: 'novote',\n    publishedDate,\n    tags\n  };\n  \n  logger.debug('Transformed metadata', { sourceId, paperId });\n  return metadata;\n}\n","// source-integration/arxiv/index.ts\n// ArXiv integration using metadata transformer\n\nimport { SourceIntegration } from '../types';\nimport { PaperMetadata } from '../../papers/types';\nimport { parseXMLText } from './xml-parser';\nimport { transformMetadata, MetadataMapping } from '../../utils/metadata-transformer';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('arxiv-integration');\n\nexport class ArXivIntegration implements SourceIntegration {\n  readonly id = 'arxiv';\n  readonly name = 'arXiv.org';\n  \n  // URL patterns for papers\n  readonly urlPatterns = [\n    /arxiv\\.org\\/(abs|pdf|html)\\/([0-9.]+)/,\n    /arxiv\\.org\\/\\w+\\/([0-9.]+)/\n  ];\n  \n  // Content script matches\n  readonly contentScriptMatches = [\n    \"*://*.arxiv.org/*\"\n  ];\n  \n  // Metadata mapping for ArXiv\n  private readonly METADATA_MAPPING: MetadataMapping = {\n    titleField: 'title',\n    authorsField: 'authors',\n    abstractField: 'summary',\n    dateField: 'published_date',\n    tagsField: 'arxiv_tags',\n    \n    // Custom author extraction (since authors is an array)\n    extractAuthors: (data) => {\n      if (Array.isArray(data.authors)) {\n        return data.authors.join(', ');\n      }\n      return data.authors || '';\n    }\n  };\n\n  /**\n   * Check if this integration can handle the given URL\n   */\n  canHandleUrl(url: string): boolean {\n    return this.urlPatterns.some(pattern => pattern.test(url));\n  }\n\n  /**\n   * Extract paper ID from URL\n   */\n  extractPaperId(url: string): string | null {\n    for (const pattern of this.urlPatterns) {\n      const match = url.match(pattern);\n      if (match) {\n        return match[2] || match[1]; // The capture group with the paper ID\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Extract metadata from page or fetch from API\n   */\n  async extractMetadata(document: Document, paperId: string): Promise<PaperMetadata | null> {\n    logger.info(`Extracting metadata for arXiv ID: ${paperId}`);\n    \n    // Try to extract from page first\n    const pageMetadata = this.extractFromPage(document, paperId);\n    if (pageMetadata) {\n      logger.debug('Extracted metadata from page');\n      return pageMetadata;\n    }\n    \n    // If page extraction fails, fetch from API\n    logger.debug('Falling back to API for metadata');\n    return this.fetchFromApi(paperId);\n  }\n  \n  /**\n   * Extract metadata from ArXiv page\n   */\n  private extractFromPage(document: Document, paperId: string): PaperMetadata | null {\n    try {\n      // Extract title\n      const titleElement = document.querySelector('.title');\n      if (!titleElement) return null;\n      \n      const title = titleElement.textContent?.replace('Title:', '').trim() || '';\n      \n      // Extract authors\n      const authorsElement = document.querySelector('.authors');\n      const authors = authorsElement?.textContent?.replace('Authors:', '').trim() || '';\n      \n      // Extract abstract\n      const abstractElement = document.querySelector('.abstract');\n      const abstract = abstractElement?.textContent?.replace('Abstract:', '').trim() || '';\n      \n      // Extract categories\n      const categoriesElement = document.querySelector('.subjects');\n      const categoriesText = categoriesElement?.textContent?.replace('Subjects:', '').trim() || '';\n      const tags = categoriesText.split(';').map(tag => tag.trim());\n      \n      // Extract publication date\n      const dateElement = document.querySelector('.dateline');\n      const publishedDate = dateElement?.textContent?.trim() || '';\n      \n      // Create metadata object\n      return {\n        sourceId: this.id,\n        paperId,\n        url: window.location.href,\n        title,\n        authors,\n        abstract,\n        timestamp: new Date().toISOString(),\n        rating: 'novote',\n        publishedDate,\n        tags\n      };\n    } catch (error) {\n      logger.error('Error extracting from page:', error);\n      return null;\n    }\n  }\n  \n  /**\n   * Fetch metadata from ArXiv API\n   */\n  private async fetchFromApi(arxivId: string): Promise<PaperMetadata | null> {\n    try {\n      const apiUrl = `https://export.arxiv.org/api/query?id_list=${arxivId}`;\n      logger.debug(`API URL: ${apiUrl}`);\n      \n      const response = await fetch(apiUrl);\n      \n      if (!response.ok) {\n        throw new Error(`ArXiv API error: ${response.status}`);\n      }\n      \n      const text = await response.text();\n      const parsedXml = await parseXMLText(text);\n      \n      if (!parsedXml) {\n        logger.error('Failed to parse API response');\n        return null;\n      }\n      \n      // Use the metadata transformer to convert the parsed XML to standard format\n      const paperData = transformMetadata(\n        this.id,\n        arxivId,\n        parsedXml,\n        this.METADATA_MAPPING,\n        `https://arxiv.org/abs/${arxivId}`\n      );\n      \n      logger.debug('Paper metadata processed', paperData);\n      return paperData;\n    } catch (error) {\n      logger.error('Error processing arXiv metadata', error);\n      return null;\n    }\n  }\n}\n\n// Export a singleton instance that can be used by both background and content scripts\nexport const arxivIntegration = new ArXivIntegration();\n"],"names":["logger","value"],"mappings":"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"}