{"version":3,"file":"openreview_plugin-D10kTOwB.js","sources":["../../papers/plugins/sources/openreview_plugin.ts"],"sourcesContent":["// extension/papers/plugins/sources/openreview_plugin.ts\n\nimport { SourcePlugin } from '../source_plugin';\nimport { UnifiedPaperData } from '../../types';\nimport { loguru } from '../../../utils/logger';\n\nconst logger = loguru.getLogger('OpenReviewPlugin');\n\n// Types for OpenReview API responses\ninterface OpenReviewNote {\n  id: string;\n  forum: string;\n  content: Record<string, any>;\n  invitation: string;\n  readers: string[];\n  signatures: string[];\n  writers: string[];\n  cdate: number;\n  pdate?: number;\n  mdate?: number;\n  venue?: string;\n  venueid?: string;\n}\n\ninterface OpenReviewRating {\n  rating: string | null;\n  confidence: string | null;\n}\n\nexport const openreviewPlugin: SourcePlugin = {\n  id: 'openreview',\n  name: 'OpenReview',\n  description: 'Support for OpenReview papers',\n  version: '1.1.0',\n  \n  urlPatterns: [\n    /openreview\\.net\\/forum\\?id=([a-zA-Z0-9_\\-]+)/,\n    /openreview\\.net\\/pdf\\?id=([a-zA-Z0-9_\\-]+)/\n  ],\n  \n  extractId(url: string): string | null {\n    for (const pattern of this.urlPatterns) {\n      const match = url.match(pattern);\n      if (match) {\n        return match[1];\n      }\n    }\n    return null;\n  },\n  \n  async extractMetadata(document: Document, url: string): Promise<Partial<UnifiedPaperData>> {\n    logger.info(`Extracting metadata from OpenReview page: ${url}`);\n    \n    try {\n      // Extract paper ID from URL\n      const paperId = this.extractId(url);\n      if (!paperId) {\n        logger.warning(`Could not extract paper ID from URL: ${url}`);\n        return { title: 'Unknown OpenReview Paper', url };\n      }\n      \n      // First priority: Extract from meta tags (most reliable)\n      const getMetaContent = (name: string): string | undefined => {\n        const element = document.querySelector(`meta[name=\"${name}\"]`);\n        return element ? element.getAttribute('content') || undefined : undefined;\n      };\n      \n      // Get all citation_author meta tags\n      const authorElements = document.querySelectorAll('meta[name=\"citation_author\"]');\n      const authors = Array.from(authorElements)\n        .map(el => el.getAttribute('content') || '')\n        .filter(Boolean)\n        .join(', ');\n      \n      // Extract title, abstract, and other metadata from meta tags\n      const title = getMetaContent('citation_title') || document.title.replace(' | OpenReview', '');\n      const abstract = getMetaContent('citation_abstract');\n      const publicationDate = getMetaContent('citation_online_date');\n      const conferenceTitle = getMetaContent('citation_conference_title');\n      const pdfUrl = getMetaContent('citation_pdf_url');\n      \n      // Secondary approach: Extract from DOM structure if meta tags are incomplete\n      const extractFromDOM = () => {\n        const getContentFieldValue = (fieldName: string): string | null => {\n          // Find the field element that contains the field name\n          const fields = Array.from(document.querySelectorAll('.note-content-field, .note_content_field'));\n          for (const field of fields) {\n            if (field.textContent?.includes(fieldName)) {\n              // Get its sibling or parent's next element which contains the value\n              const valueEl = field.nextElementSibling || \n                             field.parentElement?.querySelector('.note-content-value, .note_content_value');\n              \n              if (valueEl && valueEl.textContent) {\n                return valueEl.textContent.trim();\n              }\n            }\n          }\n          return null;\n        };\n        \n        // Extract the submission title if not found in meta\n        const domTitle = document.querySelector('.note_content_title, .note-content-title')?.textContent?.trim() || '';\n        \n        // Extract authors if not found in meta\n        let domAuthors = '';\n        const authorEl = document.querySelector('.signatures, .author, .authors');\n        if (authorEl && authorEl.textContent) {\n          domAuthors = authorEl.textContent.trim();\n        }\n        \n        // Extract abstract if not found in meta\n        const domAbstract = getContentFieldValue('Abstract') || '';\n        \n        // Extract keywords\n        const keywords = getContentFieldValue('Keywords') || '';\n        \n        // Extract TL;DR summary\n        const tldr = getContentFieldValue('TL;DR') || '';\n        \n        // Extract venue information\n        let venue = '';\n        const venueEl = document.querySelector('.item:contains(\"venue\"), .meta_row .item');\n        if (venueEl && venueEl.textContent) {\n          venue = venueEl.textContent.trim();\n        }\n        \n        return {\n          domTitle,\n          domAuthors,\n          domAbstract,\n          keywords,\n          tldr,\n          venue\n        };\n      };\n      \n      // Extract review information\n      const extractReviewInfo = () => {\n        // Check if there are reviews on the page\n        const reviewElements = document.querySelectorAll('.reply-container, .note-reply');\n        const reviewCount = reviewElements.length;\n        \n        // Try to determine decision based on common decision elements\n        let decision = '';\n        const decisionEl = document.querySelector(\n          '.decision, .meta-review, .metareview, [id*=\"decision\"], [class*=\"decision\"]'\n        );\n        if (decisionEl && decisionEl.textContent) {\n          decision = decisionEl.textContent.trim();\n        }\n        \n        // Extract ratings if available\n        const ratings: Array<{type: string, value: string}> = [];\n        const ratingElements = document.querySelectorAll('.rating, .score, .evaluation');\n        \n        ratingElements.forEach(el => {\n          const ratingText = el.textContent?.trim();\n          if (ratingText) {\n            const match = ratingText.match(/(.+):\\s*(\\d+)/);\n            if (match) {\n              ratings.push({ type: match[1].trim(), value: match[2].trim() });\n            } else {\n              ratings.push({ type: 'rating', value: ratingText });\n            }\n          }\n        });\n        \n        return {\n          reviewCount,\n          decision,\n          ratings\n        };\n      };\n      \n      // Get additional DOM-based data\n      const domData = extractFromDOM();\n      const reviewInfo = extractReviewInfo();\n      \n      // Construct the source-specific metadata\n      const sourceSpecificMetadata: Record<string, any> = {\n        forum_id: paperId,\n        conference: conferenceTitle || domData.venue || '',\n        pdf_url: pdfUrl || '',\n        publication_date: publicationDate || '',\n        tldr: domData.tldr || '',\n        keywords: domData.keywords || '',\n        review_info: {\n          review_count: reviewInfo.reviewCount,\n          decision: reviewInfo.decision,\n          ratings: reviewInfo.ratings\n        }\n      };\n      \n      // Filter out empty values\n      Object.keys(sourceSpecificMetadata).forEach(key => {\n        if (\n          sourceSpecificMetadata[key] === '' || \n          sourceSpecificMetadata[key] === null || \n          sourceSpecificMetadata[key] === undefined ||\n          (Array.isArray(sourceSpecificMetadata[key]) && sourceSpecificMetadata[key].length === 0) ||\n          (typeof sourceSpecificMetadata[key] === 'object' && Object.keys(sourceSpecificMetadata[key]).length === 0)\n        ) {\n          delete sourceSpecificMetadata[key];\n        }\n      });\n      \n      return {\n        title: title || domData.domTitle || `OpenReview Paper: ${paperId}`,\n        authors: authors || domData.domAuthors || '',\n        abstract: abstract || domData.domAbstract || '',\n        url: url,\n        source_specific_metadata: sourceSpecificMetadata\n      };\n    } catch (error) {\n      logger.error('Error extracting metadata from OpenReview page', error);\n      return {\n        title: `OpenReview Paper: ${this.extractId(url) || 'Unknown'}`,\n        url: url\n      };\n    }\n  },\n  \n  hasApi: true,\n  \n  async fetchApiData(id: string): Promise<Partial<UnifiedPaperData>> {\n    logger.info(`Fetching OpenReview API data for ID: ${id}`);\n    \n    try {\n      // OpenReview public API endpoint for notes\n      const apiUrl = `https://api.openreview.net/notes?id=${id}`;\n      \n      // Fetch note data from API\n      const response = await fetch(apiUrl);\n      \n      if (!response.ok) {\n        throw new Error(`API error: ${response.status}`);\n      }\n      \n      const data = await response.json();\n      \n      // Check if we got valid data\n      if (!data.notes || data.notes.length === 0) {\n        logger.warning(`No note found for ID: ${id}`);\n        return {};\n      }\n      \n      // Extract the note data\n      const note = data.notes[0] as OpenReviewNote;\n      const content = note.content || {};\n      \n      // Extract basic metadata\n      const title = content.title || '';\n      const authors = Array.isArray(content.authors) ? content.authors.join(', ') : content.authors || '';\n      const abstract = content.abstract || '';\n      \n      // Construct source-specific metadata\n      const sourceSpecificMetadata: Record<string, any> = {\n        forum_id: id,\n        venue: note.venue || '',\n        venueid: note.venueid || '',\n        invitation: note.invitation || '',\n        creation_date: note.cdate ? new Date(note.cdate).toISOString() : '',\n        publication_date: note.pdate ? new Date(note.pdate).toISOString() : '',\n        tldr: content.TL_DR || content['TL;DR'] || '',\n        keywords: content.keywords || '',\n      };\n      \n      // Try to get reviews/comments if they exist\n      try {\n        // Fetch forum data (includes replies/reviews)\n        const forumApiUrl = `https://api.openreview.net/notes?forum=${id}`;\n        const forumResponse = await fetch(forumApiUrl);\n        \n        if (forumResponse.ok) {\n          const forumData = await forumResponse.json();\n          \n          // Extract reviews and comments\n          const replies = forumData.notes.filter((n: OpenReviewNote) => n.id !== id);\n          \n          if (replies.length > 0) {\n            // Find review notes\n            const reviews = replies.filter((n: OpenReviewNote) => \n              n.invitation.includes('/Review') || \n              n.invitation.includes('/review') || \n              n.invitation.includes('/evaluation')\n            );\n            \n            // Find meta-review/decision notes\n            const decisions = replies.filter((n: OpenReviewNote) => \n              n.invitation.includes('/Decision') || \n              n.invitation.includes('/decision') || \n              n.invitation.includes('/Meta_Review') || \n              n.invitation.includes('/meta-review')\n            );\n            \n            sourceSpecificMetadata.review_info = {\n              reviews_count: reviews.length,\n              decisions_count: decisions.length,\n              total_replies: replies.length,\n              // Extract ratings if available\n              ratings: reviews\n                .filter((r: OpenReviewNote) => r.content.rating || r.content.score || r.content.confidence)\n                .map((r: OpenReviewNote) => ({\n                  rating: r.content.rating || r.content.score || null,\n                  confidence: r.content.confidence || null,\n                } as OpenReviewRating)),\n              // Extract decision text if available\n              decision: decisions.length > 0 ? \n                (decisions[0].content.decision || decisions[0].content.recommendation || '') : ''\n            };\n          }\n        }\n      } catch (error) {\n        logger.warning(`Error fetching forum data: ${error}`);\n        // Continue without forum data\n      }\n      \n      // Filter out empty values\n      Object.keys(sourceSpecificMetadata).forEach(key => {\n        if (\n          sourceSpecificMetadata[key] === '' || \n          sourceSpecificMetadata[key] === null || \n          sourceSpecificMetadata[key] === undefined ||\n          (Array.isArray(sourceSpecificMetadata[key]) && sourceSpecificMetadata[key].length === 0) ||\n          (typeof sourceSpecificMetadata[key] === 'object' && \n            Object.keys(sourceSpecificMetadata[key]).filter(k => sourceSpecificMetadata[key][k] !== null).length === 0)\n        ) {\n          delete sourceSpecificMetadata[key];\n        }\n      });\n      \n      return {\n        title,\n        authors,\n        abstract,\n        source_specific_metadata: sourceSpecificMetadata,\n        url: `https://openreview.net/forum?id=${id}`\n      };\n    } catch (error) {\n      logger.error(`Error fetching OpenReview API data: ${error}`);\n      return {};\n    }\n  },\n  \n  color: '#6d4c41',\n  icon: 'ðŸ“‹',\n  \n  formatId(id: string): string {\n    return `openreview.${id}`;\n  }\n};\n\n// Register the plugin\nimport { pluginRegistry } from '../registry';\npluginRegistry.register(openreviewPlugin);\n"],"names":[],"mappings":"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"}