{"version":3,"file":"content-script.js","sources":["../../utils/logger.ts","../../source-integration/link-processor.ts","../../utils/metadata-extractor.ts","../../source-integration/base-source.ts","../../source-integration/arxiv/xml-parser.ts","../../source-integration/arxiv/index.ts","../../content.ts"],"sourcesContent":["// utils/logger.ts\n// Logging utility wrapping loguru\n\n/**\n * Logger class for consistent logging throughout the extension\n */\nexport class Logger {\n  constructor(private module: string) {}\n  \n  /**\n   * Log debug message\n   */\n  debug(message: string, data?: any): void {\n    console.debug(`[${this.module}] ${message}`, data !== undefined ? data : '');\n  }\n  \n  /**\n   * Log info message\n   */\n  info(message: string, data?: any): void {\n    console.info(`[${this.module}] ${message}`, data !== undefined ? data : '');\n  }\n  \n  /**\n   * Log warning message\n   */\n  warning(message: string, data?: any): void {\n    console.warn(`[${this.module}] ${message}`, data !== undefined ? data : '');\n  }\n  \n  /**\n   * Log error message\n   */\n  error(message: string, data?: any): void {\n    console.error(`[${this.module}] ${message}`, data !== undefined ? data : '');\n  }\n}\n\n/**\n * Loguru mock for browser extension use\n */\nclass LoguruMock {\n  /**\n   * Get logger for a module\n   */\n  getLogger(module: string): Logger {\n    return new Logger(module);\n  }\n}\n\n// Export singleton instance\nexport const loguru = new LoguruMock();\n","// extension/source-integration/link-processor.ts\n// Generic link detection and processing module\n\nimport { loguru } from '../utils/logger';\n\nconst logger = loguru.getLogger('link-processor');\n\ninterface LinkPattern {\n  // Source integration ID\n  sourceId: string;\n  \n  // Regular expression to match URLs\n  pattern: RegExp;\n  \n  // Function to extract paper ID from URL\n  extractPaperId: (url: string) => string | null;\n}\n\nexport class LinkProcessor {\n  private patterns: LinkPattern[] = [];\n  private observer: MutationObserver | null = null;\n  private processedLinks = new Set<string>();\n  private onLinkFound: (sourceId: string, paperId: string, link: HTMLAnchorElement) => void;\n  \n  constructor(onLinkFound: (sourceId: string, paperId: string, link: HTMLAnchorElement) => void) {\n    this.onLinkFound = onLinkFound;\n    logger.debug('Link processor initialized');\n  }\n  \n  /**\n   * Register a new link pattern\n   */\n  registerPattern(pattern: LinkPattern): void {\n    this.patterns.push(pattern);\n    logger.debug(`Registered pattern for ${pattern.sourceId}`);\n  }\n  \n  /**\n   * Process all links in the document\n   */\n  processLinks(document: Document): void {\n    // Process all links in the document\n    const links = document.querySelectorAll<HTMLAnchorElement>('a[href]');\n    \n    links.forEach(link => {\n      // Use a unique identifier for this link\n      const linkId = this.getLinkId(link);\n      \n      // Skip if already processed\n      if (this.processedLinks.has(linkId)) {\n        return;\n      }\n      \n      this.processedLinks.add(linkId);\n      \n      // Check each pattern\n      for (const pattern of this.patterns) {\n        if (pattern.pattern.test(link.href)) {\n          const paperId = pattern.extractPaperId(link.href);\n          \n          if (paperId) {\n            // Call the callback\n            this.onLinkFound(pattern.sourceId, paperId, link);\n            break; // Stop after first match\n          }\n        }\n      }\n    });\n  }\n  \n  /**\n   * Start observing for DOM changes\n   */\n  startObserving(document: Document): void {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n    \n    this.observer = new MutationObserver((mutations) => {\n      let newLinks = false;\n      \n      mutations.forEach(mutation => {\n        mutation.addedNodes.forEach(node => {\n          if (node.nodeType === Node.ELEMENT_NODE) {\n            // If this is an anchor tag, check it\n            if ((node as Element).tagName === 'A') {\n              newLinks = true;\n            }\n            \n            // Check for any anchor tags within this element\n            const links = (node as Element).querySelectorAll('a[href]');\n            if (links.length > 0) {\n              newLinks = true;\n            }\n          }\n        });\n      });\n      \n      if (newLinks) {\n        this.processLinks(document);\n      }\n    });\n    \n    this.observer.observe(document.body, {\n      childList: true,\n      subtree: true\n    });\n    \n    logger.debug('Started observing for DOM changes');\n  }\n  \n  /**\n   * Create a unique ID for a link\n   */\n  private getLinkId(link: HTMLAnchorElement): string {\n    // Use href and position in document to create a unique ID\n    const path = this.getElementPath(link);\n    return `${link.href}|${path}`;\n  }\n  \n  /**\n   * Get element path in DOM for identification\n   */\n  private getElementPath(element: Element): string {\n    const path: string[] = [];\n    let current: Element | null = element;\n    \n    while (current && current !== document.body) {\n      let selector = current.tagName.toLowerCase();\n      \n      if (current.id) {\n        selector += `#${current.id}`;\n      } else {\n        const siblings = Array.from(current.parentElement?.children || []);\n        const index = siblings.indexOf(current) + 1;\n        if (siblings.length > 1) {\n          selector += `:nth-child(${index})`;\n        }\n      }\n      \n      path.unshift(selector);\n      current = current.parentElement;\n    }\n    \n    return path.join(' > ');\n  }\n  \n  /**\n   * Stop observing DOM changes\n   */\n  stopObserving(): void {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n      logger.debug('Stopped observing DOM changes');\n    }\n  }\n}\n","// extension/utils/metadata-extractor.ts\n// Object-oriented metadata extraction system with customizable extraction methods\n\nimport { loguru } from './logger';\n\nconst logger = loguru.getLogger('metadata-extractor');\n\nexport interface ExtractedMetadata {\n  title: string;\n  authors: string;\n  description: string;\n  publishedDate: string;\n  doi?: string;\n  journalName?: string;\n  tags?: string[];\n  url?: string;\n}\n\n// Constants for standard source types\nexport const SOURCE_TYPES = {\n  PDF: 'pdf',\n  URL: 'url',\n} as const;\n\nexport type SourceType = typeof SOURCE_TYPES[keyof typeof SOURCE_TYPES];\n\n/**\n * Base class for metadata extraction with customizable extraction methods\n * Each method can be overridden to provide source-specific extraction\n */\nexport class MetadataExtractor {\n  protected document: Document;\n  protected url: string;\n  \n  /**\n   * Create a new metadata extractor for a document\n   */\n  constructor(document: Document) {\n    this.document = document;\n    this.url = document.location.href;\n    logger.debug('Initialized metadata extractor for:', this.url);\n  }\n  \n  /**\n   * Helper method to get content from meta tags\n   */\n  protected getMetaContent(selector: string): string {\n    const element = this.document.querySelector(selector);\n    return element ? element.getAttribute('content') || '' : '';\n  }\n  \n  /**\n   * Extract and return all metadata fields\n   */\n  public extract(): ExtractedMetadata {\n    logger.debug('Extracting metadata from page:', this.url);\n    \n    const metadata: ExtractedMetadata = {\n      title: this.extractTitle(),\n      authors: this.extractAuthors(),\n      description: this.extractDescription(),\n      publishedDate: this.extractPublishedDate(),\n      doi: this.extractDoi(),\n      journalName: this.extractJournalName(),\n      tags: this.extractTags(),\n      url: this.url\n    };\n    \n    logger.debug('Metadata extraction complete:', metadata);\n    return metadata;\n  }\n  \n  /**\n   * Extract title from document\n   * Considers multiple metadata standards with priority order\n   */\n  protected extractTitle(): string {\n    // Title extraction - priority order\n    return (\n      // Dublin Core\n      this.getMetaContent('meta[name=\"DC.Title\"]') ||\n      // Citation\n      this.getMetaContent('meta[name=\"citation_title\"]') ||\n      // Open Graph\n      this.getMetaContent('meta[property=\"og:title\"]') ||\n      // Standard meta\n      this.getMetaContent('meta[name=\"title\"]') ||\n      // Fallback to document title\n      this.document.title\n    );\n  }\n  \n  /**\n   * Extract authors from document\n   * Handles multiple author formats and sources\n   */\n  protected extractAuthors(): string {\n    // Get all citation authors (some pages have multiple citation_author tags)\n    const citationAuthors: string[] = [];\n    this.document.querySelectorAll('meta[name=\"citation_author\"]').forEach(el => {\n      const content = el.getAttribute('content');\n      if (content) citationAuthors.push(content);\n    });\n    \n    // Get all DC creators\n    const dcCreators: string[] = [];\n    this.document.querySelectorAll('meta[name=\"DC.Creator.PersonalName\"]').forEach(el => {\n      const content = el.getAttribute('content');\n      if (content) dcCreators.push(content);\n    });\n    \n    // Individual author elements\n    const dcCreator = this.getMetaContent('meta[name=\"DC.Creator.PersonalName\"]');\n    const citationAuthor = this.getMetaContent('meta[name=\"citation_author\"]');\n    const ogAuthor = this.getMetaContent('meta[property=\"og:article:author\"]') ||\n                    this.getMetaContent('meta[name=\"author\"]');\n    \n    // Set authors with priority\n    if (dcCreators.length > 0) {\n      return dcCreators.join(', ');\n    } else if (citationAuthors.length > 0) {\n      return citationAuthors.join(', ');\n    } else if (dcCreator) {\n      return dcCreator;\n    } else if (citationAuthor) {\n      return citationAuthor;\n    } else if (ogAuthor) {\n      return ogAuthor;\n    }\n    \n    return '';\n  }\n  \n  /**\n   * Extract description/abstract from document\n   */\n  protected extractDescription(): string {\n    return (\n      this.getMetaContent('meta[name=\"DC.Description\"]') ||\n      this.getMetaContent('meta[name=\"citation_abstract\"]') ||\n      this.getMetaContent('meta[property=\"og:description\"]') ||\n      this.getMetaContent('meta[name=\"description\"]')\n    );\n  }\n  \n  /**\n   * Extract publication date from document\n   */\n  protected extractPublishedDate(): string {\n    return (\n      this.getMetaContent('meta[name=\"DC.Date.issued\"]') ||\n      this.getMetaContent('meta[name=\"citation_date\"]') ||\n      this.getMetaContent('meta[property=\"article:published_time\"]')\n    );\n  }\n  \n  /**\n   * Extract DOI (Digital Object Identifier) from document\n   */\n  protected extractDoi(): string {\n    return (\n      this.getMetaContent('meta[name=\"DC.Identifier.DOI\"]') ||\n      this.getMetaContent('meta[name=\"citation_doi\"]')\n    );\n  }\n  \n  /**\n   * Extract journal name from document\n   */\n  protected extractJournalName(): string {\n    return (\n      this.getMetaContent('meta[name=\"DC.Source\"]') ||\n      this.getMetaContent('meta[name=\"citation_journal_title\"]')\n    );\n  }\n  \n  /**\n   * Extract keywords/tags from document\n   */\n  protected extractTags(): string[] {\n    const keywords = this.getMetaContent('meta[name=\"keywords\"]') ||\n                    this.getMetaContent('meta[name=\"DC.Subject\"]');\n    \n    if (keywords) {\n      return keywords.split(',').map(tag => tag.trim());\n    }\n    \n    return [];\n  }\n  \n  /**\n   * Determine if the current URL is a PDF\n   */\n  public isPdf(): boolean {\n    return isPdfUrl(this.url);\n  }\n  \n  /**\n   * Get the source type (PDF or URL)\n   */\n  public getSourceType(): SourceType {\n    return this.isPdf() ? SOURCE_TYPES.PDF : SOURCE_TYPES.URL;\n  }\n  \n  /**\n   * Generate a paper ID for the current URL\n   */\n  public generatePaperId(): string {\n    return generatePaperIdFromUrl(this.url);\n  }\n}\n\n/**\n * Create a common metadata extractor for a document\n * Factory function for creating the default extractor\n */\nexport function createMetadataExtractor(document: Document): MetadataExtractor {\n  return new MetadataExtractor(document);\n}\n\n/**\n * Extract common metadata from a document\n * Convenience function for quick extraction\n */\nexport function extractCommonMetadata(document: Document): ExtractedMetadata {\n  return createMetadataExtractor(document).extract();\n}\n\n/**\n * Generate a paper ID from a URL\n * Creates a consistent hash-based identifier\n */\nexport function generatePaperIdFromUrl(url: string): string {\n  // Use a basic hash function to create an ID from the URL\n  let hash = 0;\n  for (let i = 0; i < url.length; i++) {\n    const char = url.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  \n  // Create a positive hexadecimal string\n  const positiveHash = Math.abs(hash).toString(16).toUpperCase();\n  \n  // Use the first 8 characters as the ID\n  return positiveHash.substring(0, 8);\n}\n\n/**\n * Determine if a URL is a PDF\n */\nexport function isPdfUrl(url: string): boolean {\n  return url.toLowerCase().endsWith('.pdf');\n}\n","// extension/source-integration/base-source.ts\n// Base abstract class for source integrations with default identifier formatting\n// and metadata extraction capability\n\nimport { SourceIntegration } from './types';\nimport { PaperMetadata } from '../papers/types';\nimport { loguru } from '../utils/logger';\nimport { \n  MetadataExtractor, \n  createMetadataExtractor,\n  generatePaperIdFromUrl,\n  SOURCE_TYPES\n} from '../utils/metadata-extractor';\n\nconst logger = loguru.getLogger('base-source');\n\n/**\n * Abstract base class for source integrations\n * Provides default implementations for identifier formatting methods\n * and metadata extraction\n */\nexport abstract class BaseSourceIntegration implements SourceIntegration {\n  // Abstract properties to be implemented by derived classes\n  abstract readonly id: string;\n  abstract readonly name: string;\n  abstract readonly urlPatterns: RegExp[];\n  abstract readonly contentScriptMatches: string[];\n\n  // Abstract methods to be implemented by derived classes\n  abstract canHandleUrl(url: string): boolean;\n  abstract extractPaperId(url: string): string | null;\n  \n  /**\n   * Create a metadata extractor for the given document\n   * Override this method to provide a custom extractor for your source\n   */\n  protected createMetadataExtractor(document: Document): MetadataExtractor {\n    return createMetadataExtractor(document);\n  }\n  \n  /**\n   * Extract metadata from a page\n   * Default implementation uses common metadata extraction\n   * Override in specific source integrations if needed\n   */\n  async extractMetadata(document: Document, paperId: string): Promise<PaperMetadata | null> {\n    try {\n      logger.debug(`Extracting metadata using base extractor for ID: ${paperId}`);\n      \n      // Create a metadata extractor for this document\n      const extractor = this.createMetadataExtractor(document);\n      \n      // Extract metadata\n      const extracted = extractor.extract();\n      const url = document.location.href;\n      \n      // Determine source type (PDF or URL)\n      const sourceType = extractor.getSourceType();\n      \n      // Create PaperMetadata object\n      return {\n        sourceId: this.id,\n        paperId,\n        url: url,\n        title: extracted.title || document.title || paperId,\n        authors: extracted.authors || '',\n        abstract: extracted.description || '',\n        timestamp: new Date().toISOString(),\n        rating: 'novote',\n        publishedDate: extracted.publishedDate || '',\n        tags: extracted.tags || [],\n        doi: extracted.doi,\n        journalName: extracted.journalName,\n        sourceType: sourceType // Store the source type for reference\n      };\n    } catch (error) {\n      logger.error('Error extracting metadata with base extractor', error);\n      return null;\n    }\n  }\n  \n  /**\n   * Format a paper identifier for this source\n   * Default implementation uses the format: sourceId.paperId\n   * Override this method if a source needs a different format\n   */\n  formatPaperId(paperId: string): string {\n    return `${this.id}.${paperId}`;\n  }\n  \n  /**\n   * Parse a paper identifier specific to this source\n   * Default implementation handles source.paperId format and extracts paperId\n   * Override this method if a source uses a different format\n   */\n  parsePaperId(identifier: string): string | null {\n    const prefix = `${this.id}.`;\n    \n    if (identifier.startsWith(prefix)) {\n      return identifier.substring(prefix.length);\n    }\n    \n    // Try legacy format (sourceId:paperId)\n    const legacyPrefix = `${this.id}:`;\n    if (identifier.startsWith(legacyPrefix)) {\n      logger.debug(`Parsed legacy format identifier: ${identifier}`);\n      return identifier.substring(legacyPrefix.length);\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Format a storage object ID for this source\n   * Default implementation uses the format: type:sourceId.paperId\n   * Override this method if a source needs a different format\n   */\n  formatObjectId(type: string, paperId: string): string {\n    return `${type}:${this.formatPaperId(paperId)}`;\n  }\n\n  /**\n   * Create a manual paper entry for any URL\n   * Useful for tracking generic web pages that aren't specific to this source\n   */\n  async createManualPaperEntry(url: string, document: Document): Promise<PaperMetadata | null> {\n    try {\n      logger.debug(`Creating manual paper entry for URL: ${url}`);\n      \n      // Create a metadata extractor\n      const extractor = this.createMetadataExtractor(document);\n      \n      // Extract metadata\n      const extracted = extractor.extract();\n      \n      // Generate a paper ID from the URL\n      const paperId = generatePaperIdFromUrl(url);\n      \n      // Determine if it's a PDF\n      const sourceType = extractor.getSourceType();\n      const sourceId = sourceType; // Use the source type as the source ID\n      \n      // Create a new paper metadata object\n      const metadata: PaperMetadata = {\n        sourceId: sourceId,\n        paperId: paperId,\n        url: url,\n        title: extracted.title || document.title || paperId,\n        authors: extracted.authors || '',\n        abstract: extracted.description || '',\n        timestamp: new Date().toISOString(),\n        rating: 'novote',\n        publishedDate: extracted.publishedDate || '',\n        tags: extracted.tags || [],\n        doi: extracted.doi,\n        journalName: extracted.journalName,\n        sourceType: sourceType\n      };\n      \n      logger.debug('Created manual paper entry', metadata);\n      return metadata;\n    } catch (error) {\n      logger.error('Error creating manual paper entry', error);\n      return null;\n    }\n  }\n}\n","// source-integration/arxiv/xml-parser.ts\n// ArXiv API XML response parser - simplified for use with metadata transformer\n\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('arxiv-xml-parser');\n\nexport interface ArXivParsedData {\n  title: string;\n  summary: string;\n  authors: string[];\n  published_date: string;\n  arxiv_tags: string[];\n  [key: string]: any; // Add index signature to satisfy Json type requirements\n}\n\n/**\n * Parse ArXiv API XML response into a structured object\n */\nexport async function parseXMLText(xmlText: string): Promise<ArXivParsedData | null> {\n  logger.debug('Parsing ArXiv XML response');\n  \n  try {\n    // Parse XML to DOM\n    const parser = new DOMParser();\n    const xmlDoc = parser.parseFromString(xmlText, \"text/xml\");\n    \n    // Check for parse errors\n    const parseError = xmlDoc.querySelector('parsererror');\n    if (parseError) {\n      throw new Error('XML parsing error: ' + parseError.textContent);\n    }\n    \n    // Get entry element\n    const entry = xmlDoc.querySelector('entry');\n    if (!entry) {\n      throw new Error('No entry element found in XML');\n    }\n    \n    // Extract basic fields\n    const title = entry.querySelector('title')?.textContent?.trim() || '';\n    const summary = entry.querySelector('summary')?.textContent?.trim() || '';\n    const published = entry.querySelector('published')?.textContent?.trim() || '';\n    \n    // Extract authors\n    const authors = Array.from(entry.querySelectorAll('author name'))\n      .map(name => name.textContent?.trim() || '');\n    \n    // Extract categories/tags\n    const categories = new Set<string>();\n    \n    // Primary category\n    const primaryCategory = entry.querySelector('arxiv\\\\:primary_category, primary_category');\n    if (primaryCategory && primaryCategory.hasAttribute('term')) {\n      categories.add(primaryCategory.getAttribute('term') || '');\n    }\n    \n    // Other categories\n    const categoryElements = entry.querySelectorAll('category');\n    categoryElements.forEach(cat => {\n      if (cat.hasAttribute('term')) {\n        categories.add(cat.getAttribute('term') || '');\n      }\n    });\n    \n    const result: ArXivParsedData = {\n      title,\n      summary,\n      authors,\n      published_date: published,\n      arxiv_tags: Array.from(categories)\n    };\n    \n    logger.debug('XML parsing completed successfully');\n    return result;\n  } catch (error) {\n    logger.error('Error parsing ArXiv XML', error);\n    return null;\n  }\n}\n","// extension/source-integration/arxiv/index.ts\n// ArXiv integration with custom metadata extractor\n\nimport { BaseSourceIntegration } from '../base-source';\nimport { PaperMetadata } from '../../papers/types';\nimport { parseXMLText } from './xml-parser';\nimport { MetadataExtractor, createMetadataExtractor } from '../../utils/metadata-extractor';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('arxiv-integration');\n\n/**\n * ArXiv-specific metadata extractor\n * Enhances the base extractor with arXiv-specific extraction\n */\nclass ArXivMetadataExtractor extends MetadataExtractor {\n  /**\n   * Extract authors with arXiv-specific handling\n   */\n  protected extractAuthors(): string {\n    // Try arXiv-specific author element first\n    const authorsElement = this.document.querySelector('.authors');\n    if (authorsElement) {\n      const authorsText = authorsElement.textContent?.replace('Authors:', '').trim();\n      if (authorsText) {\n        return authorsText;\n      }\n    }\n    \n    // Fall back to standard extraction\n    return super.extractAuthors();\n  }\n  \n  /**\n   * Extract abstract with arXiv-specific handling\n   */\n  protected extractDescription(): string {\n    // Try arXiv-specific abstract element first\n    const abstractElement = this.document.querySelector('.abstract');\n    if (abstractElement) {\n      const abstractText = abstractElement.textContent?.replace('Abstract:', '').trim();\n      if (abstractText) {\n        return abstractText;\n      }\n    }\n    \n    // Fall back to standard extraction\n    return super.extractDescription();\n  }\n  \n  /**\n   * Extract tags/categories with arXiv-specific handling\n   */\n  protected extractTags(): string[] {\n    // Try arXiv-specific categories element first\n    const categoriesElement = this.document.querySelector('.subjects');\n    if (categoriesElement) {\n      const categoriesText = categoriesElement.textContent?.replace('Subjects:', '').trim();\n      if (categoriesText) {\n        return categoriesText.split(';').map(tag => tag.trim());\n      }\n    }\n    \n    // Fall back to standard extraction\n    return super.extractTags();\n  }\n  \n  /**\n   * Extract publication date with arXiv-specific handling\n   */\n  protected extractPublishedDate(): string {\n    // Try arXiv-specific dateline element first\n    const dateElement = this.document.querySelector('.dateline');\n    if (dateElement) {\n      const dateText = dateElement.textContent?.trim();\n      if (dateText) {\n        return dateText;\n      }\n    }\n    \n    // Fall back to standard extraction\n    return super.extractPublishedDate();\n  }\n}\n\n/**\n * ArXiv integration with custom metadata extraction\n */\nexport class ArXivIntegration extends BaseSourceIntegration {\n  readonly id = 'arxiv';\n  readonly name = 'arXiv.org';\n  \n  // URL patterns for papers\n  readonly urlPatterns = [\n    /arxiv\\.org\\/(abs|pdf|html)\\/([0-9.]+)/,\n    /arxiv\\.org\\/\\w+\\/([0-9.]+)/\n  ];\n  \n  // Content script matches\n  readonly contentScriptMatches = [\n    \"*://*.arxiv.org/*\"\n  ];\n\n  /**\n   * Create a metadata extractor for arXiv pages\n   */\n  protected createMetadataExtractor(document: Document): MetadataExtractor {\n    return new ArXivMetadataExtractor(document);\n  }\n\n  /**\n   * Check if this integration can handle the given URL\n   */\n  canHandleUrl(url: string): boolean {\n    return this.urlPatterns.some(pattern => pattern.test(url));\n  }\n\n  /**\n   * Extract paper ID from URL\n   */\n  extractPaperId(url: string): string | null {\n    for (const pattern of this.urlPatterns) {\n      const match = url.match(pattern);\n      if (match) {\n        return match[2] || match[1]; // The capture group with the paper ID\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Extract metadata from page or fetch from API\n   * Override parent method to handle the API fallback\n   */\n  async extractMetadata(document: Document, paperId: string): Promise<PaperMetadata | null> {\n    logger.info(`Extracting metadata for arXiv ID: ${paperId}`);\n    \n    // Try to extract from page first using our custom extractor\n    const pageMetadata = await super.extractMetadata(document, paperId);\n    \n    if (pageMetadata && pageMetadata.title && pageMetadata.authors) {\n      logger.debug('Extracted metadata from page');\n      return pageMetadata;\n    }\n    \n    // If page extraction fails or is incomplete, fetch from API\n    logger.debug('Falling back to API for metadata');\n    return this.fetchFromApi(paperId);\n  }\n  \n  /**\n   * Fetch metadata from ArXiv API\n   */\n  private async fetchFromApi(arxivId: string): Promise<PaperMetadata | null> {\n    try {\n      const apiUrl = `https://export.arxiv.org/api/query?id_list=${arxivId}`;\n      logger.debug(`API URL: ${apiUrl}`);\n      \n      const response = await fetch(apiUrl);\n      \n      if (!response.ok) {\n        throw new Error(`ArXiv API error: ${response.status}`);\n      }\n      \n      const text = await response.text();\n      const parsedXml = await parseXMLText(text);\n      \n      if (!parsedXml) {\n        logger.error('Failed to parse API response');\n        return null;\n      }\n      \n      // Transform the parsed XML to standard metadata format\n      return {\n        sourceId: this.id,\n        paperId: arxivId,\n        url: `https://arxiv.org/abs/${arxivId}`,\n        title: parsedXml.title || arxivId,\n        authors: Array.isArray(parsedXml.authors) ? parsedXml.authors.join(', ') : parsedXml.authors || '',\n        abstract: parsedXml.summary || '',\n        timestamp: new Date().toISOString(),\n        rating: 'novote',\n        publishedDate: parsedXml.published_date || '',\n        tags: parsedXml.arxiv_tags || [],\n        sourceType: 'url'\n      };\n    } catch (error) {\n      logger.error('Error processing arXiv metadata', error);\n      return null;\n    }\n  }\n}\n\n// Export a singleton instance that can be used by both background and content scripts\nexport const arxivIntegration = new ArXivIntegration();\n","// extension/content.ts\n// Content script with heartbeat session tracking\n\nimport { LinkProcessor } from './source-integration/link-processor';\nimport { SourceIntegration, Message } from './source-integration/types';\nimport { PaperMetadata } from './papers/types';\nimport { loguru } from './utils/logger';\nimport { BaseSourceIntegration } from './source-integration/base-source';\nimport { generatePaperIdFromUrl } from './utils/metadata-extractor';\n\n// Import source plugins directly\nimport { arxivIntegration } from './source-integration/arxiv';\n\nconst logger = loguru.getLogger('content-script');\n\nlogger.info('Paper Tracker content script loaded');\n\n// Create a generic source for fallback extraction\nclass GenericSourceIntegration extends BaseSourceIntegration {\n  readonly id = 'url';\n  readonly name = 'Generic Source';\n  readonly urlPatterns: RegExp[] = [];\n  readonly contentScriptMatches: string[] = [];\n  \n  canHandleUrl(url: string): boolean {\n    return false; // This source doesn't directly handle any URLs\n  }\n  \n  extractPaperId(url: string): string | null {\n    return generatePaperIdFromUrl(url); // Generate a paperId from URL hash\n  }\n}\n\n// Create a singleton instance of the generic source\nconst genericSource = new GenericSourceIntegration();\n\n// Create PDF source for PDF files\nclass PdfSourceIntegration extends BaseSourceIntegration {\n  readonly id = 'pdf';\n  readonly name = 'PDF Document';\n  readonly urlPatterns: RegExp[] = [/\\.pdf$/i];\n  readonly contentScriptMatches: string[] = [];\n  \n  canHandleUrl(url: string): boolean {\n    return url.toLowerCase().endsWith('.pdf');\n  }\n  \n  extractPaperId(url: string): string | null {\n    return generatePaperIdFromUrl(url); // Generate a paperId from URL hash\n  }\n}\n\n// Create a singleton instance of the PDF source\nconst pdfSource = new PdfSourceIntegration();\n\n// Available source integrations\nconst sourceIntegrations: SourceIntegration[] = [\n  arxivIntegration,\n  pdfSource,\n  // Add more sources as they become available\n];\n\n// Track active popup\nlet activePopup: HTMLElement | null = null;\n\n// Heartbeat interval\nlet heartbeatInterval: number | null = null;\nconst HEARTBEAT_INTERVAL = 5000; // 5 seconds\n\n// Track tab visibility\nlet isTabVisible = true;\n\n// Create link processor\nconst linkProcessor = new LinkProcessor((sourceId, paperId, link) => {\n  // Callback when link is found\n  injectAnnotationButton(link, sourceId, paperId);\n});\n\n// Initialize sources\nfunction initializeSources() {\n  // Register each source with the link processor\n  for (const source of sourceIntegrations) {\n    logger.debug(`Initializing source: ${source.id}`);\n    \n    // Register patterns with link processor\n    source.urlPatterns.forEach(pattern => {\n      linkProcessor.registerPattern({\n        sourceId: source.id,\n        pattern,\n        extractPaperId: (url: string) => source.extractPaperId(url)\n      });\n    });\n  }\n}\n\n// Inject common styles\nfunction injectStyles() {\n  if (document.getElementById('paper-tracker-styles')) {\n    return; // Already injected\n  }\n  \n  const styles = `\n  .paper-annotator {\n    display: inline-block;\n    margin-left: 4px;\n    cursor: pointer;\n    font-size: 0.9em;\n    opacity: 0.7;\n    transition: opacity 0.2s;\n    vertical-align: baseline;\n  }\n\n  .paper-annotator:hover {\n    opacity: 1;\n  }\n\n  .paper-popup-wrapper {\n    position: fixed;\n    z-index: 10000;\n  }\n\n  .paper-popup {\n    position: relative;\n    background: white;\n    border: 1px solid #ddd;\n    border-radius: 6px;\n    padding: 12px;\n    box-shadow: 0 4px 12px rgba(0,0,0,0.15);\n    width: 300px;\n    box-sizing: border-box;\n  }\n\n  .paper-popup-header {\n    font-weight: bold;\n    margin-bottom: 8px;\n    line-height: 1.4;\n    font-size: 1em;\n  }\n\n  .paper-popup-meta {\n    color: #666;\n    font-size: 0.85em;\n    margin-bottom: 12px;\n    line-height: 1.4;\n  }\n\n  .paper-popup-buttons {\n    display: flex;\n    gap: 8px;\n    margin: 8px 0;\n  }\n\n  .paper-popup button {\n    padding: 6px 12px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    background: #f5f5f5;\n    cursor: pointer;\n    transition: all 0.2s ease;\n    font-size: 0.9em;\n  }\n\n  .paper-popup button:hover {\n    background: #e8e8e8;\n    border-color: #ccc;\n  }\n\n  .paper-popup button.active {\n    background: #e0e0e0;\n    border-color: #aaa;\n  }\n\n  .paper-popup textarea {\n    width: calc(100% - 16px);\n    min-height: 80px;\n    margin: 8px 0;\n    padding: 8px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    resize: vertical;\n    font-family: inherit;\n    font-size: 0.9em;\n    line-height: 1.4;\n    box-sizing: border-box;\n  }\n\n  .paper-popup textarea:focus {\n    outline: none;\n    border-color: #aaa;\n  }\n\n  .paper-popup-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n    margin-top: 12px;\n  }\n\n  .paper-popup .save-button {\n    background: #2563eb;\n    color: white;\n    border-color: #2563eb;\n  }\n\n  .paper-popup .save-button:hover {\n    background: #1d4ed8;\n    border-color: #1d4ed8;\n  }\n  `;\n  \n  const styleSheet = document.createElement('style');\n  styleSheet.id = 'paper-tracker-styles';\n  styleSheet.textContent = styles;\n  document.head.appendChild(styleSheet);\n  \n  logger.debug('Injected styles');\n}\n\n// Add annotation button to link\nfunction injectAnnotationButton(link: HTMLAnchorElement, sourceId: string, paperId: string): void {\n  // Skip if already processed\n  if (link.nextSibling && \n      link.nextSibling.nodeType === Node.ELEMENT_NODE &&\n      (link.nextSibling as Element).classList.contains('paper-annotator')) {\n    return;\n  }\n  \n  // Create annotator button\n  const annotator = document.createElement('span');\n  annotator.className = 'paper-annotator';\n  annotator.textContent = '📝';\n  annotator.title = 'Add annotation';\n  \n  // Store data attributes\n  annotator.dataset.sourceId = sourceId;\n  annotator.dataset.paperId = paperId;\n  \n  // Add click handler\n  annotator.addEventListener('click', (e) => {\n    e.preventDefault();\n    e.stopPropagation();\n    \n    // Send message to background script to show popup\n    chrome.runtime.sendMessage({\n      type: 'showAnnotationPopup',\n      sourceId,\n      paperId,\n      position: {\n        x: e.clientX,\n        y: e.clientY\n      }\n    });\n  });\n  \n  // Add to page next to link\n  link.parentNode?.insertBefore(annotator, link.nextSibling);\n}\n\n// Get source that can handle a URL\nfunction getSourceForUrl(url: string): SourceIntegration | null {\n  for (const source of sourceIntegrations) {\n    if (source.canHandleUrl(url)) {\n      return source;\n    }\n  }\n  return null;\n}\n\n// Set up click-outside handler for popups\ndocument.addEventListener('click', (e) => {\n  if (activePopup && \n      !activePopup.contains(e.target as Node) && \n      !(e.target as Element).classList.contains('paper-annotator')) {\n    activePopup.parentElement?.remove();\n    activePopup = null;\n  }\n});\n\n// Start heartbeat for session tracking\nfunction startSessionTracking(sourceId: string, paperId: string) {\n  // Stop any existing heartbeat\n  stopHeartbeat();\n  \n  // Only start tracking if tab is visible\n  if (!isTabVisible) {\n    logger.debug(`Not starting session for ${sourceId}.${paperId} because tab is not visible`);\n    return;\n  }\n  \n  // Tell background script to start a new session\n  chrome.runtime.sendMessage({\n    type: 'startSession',\n    sourceId,\n    paperId\n  }, response => {\n    if (response?.success) {\n      logger.debug(`Started session for ${sourceId}.${paperId}`);\n    } else {\n      logger.error(`Failed to start session for ${sourceId}.${paperId}`, response?.error);\n    }\n  });\n  \n  // Start sending heartbeats\n  heartbeatInterval = window.setInterval(() => {\n    chrome.runtime.sendMessage({\n      type: 'sessionHeartbeat',\n      sourceId,\n      paperId,\n      timestamp: Date.now()\n    });\n  }, HEARTBEAT_INTERVAL);\n  \n  logger.info(`Started heartbeat for ${sourceId}:${paperId}`);\n}\n\n// Stop heartbeat\nfunction stopHeartbeat() {\n  if (heartbeatInterval !== null) {\n    clearInterval(heartbeatInterval);\n    heartbeatInterval = null;\n    logger.debug('Stopped heartbeat');\n  }\n}\n\n// Update the processCurrentPage function to handle the force parameter\nasync function processCurrentPage(force: boolean = false): Promise<PaperMetadata | null> {\n  const url = window.location.href;\n  \n  // Find a source that can handle this URL\n  let source = getSourceForUrl(url);\n  \n  // If no source was found and force parameter is set, use generic source\n  if (!source && force) {\n    logger.info(`No matching source found, but force parameter set. Using generic source for: ${url}`);\n    source = url.toLowerCase().endsWith('.pdf') ? pdfSource : genericSource;\n  }\n\n  // If we still don't have a source, return null\n  if (!source) {\n    logger.debug(`No source found for URL: ${url}`);\n    return null;\n  }\n\n  // Now that we have a source, extract the paperId\n  const paperId = source.extractPaperId(url);\n  if (!paperId) {\n    logger.info(`Unable to determine a paperId for url: ${url}`);\n    return null;\n  }\n  \n  try {\n    // Use source-specific extraction or createManualPaperEntry for generic source\n    let metadata: PaperMetadata | null;\n    \n    // if ((source === genericSource || source === pdfSource) && force) {\n    //   metadata = await source.createManualPaperEntry(url, document);\n    // } else {\n    //   metadata = await source.extractMetadata(document, paperId);\n    // }\n    metadata = await source.extractMetadata(document, paperId);\n    \n    \n    if (metadata) {\n      // Send metadata to background script\n      chrome.runtime.sendMessage({\n        type: 'paperMetadata',\n        metadata\n      });\n      \n      logger.debug(`Sent extracted metadata to background script for ${metadata.sourceId}.${metadata.paperId}`);\n      \n      // Start session tracking if tab is visible\n      if (isTabVisible) {\n        startSessionTracking(metadata.sourceId, metadata.paperId);\n      }\n      \n      return metadata;\n    }\n  } catch (error) {\n    logger.error(`Error extracting metadata for ${source.id}.${paperId}`, error);\n  }\n  \n  return null;\n}\n\n// Visibility change listener\ndocument.addEventListener('visibilitychange', () => {\n  const wasVisible = isTabVisible;\n  isTabVisible = document.visibilityState === 'visible';\n  \n  const source = getSourceForUrl(window.location.href);\n  if (!source) return;\n  \n  const paperId = source.extractPaperId(window.location.href);\n  if (!paperId) return;\n  \n  if (isTabVisible && !wasVisible) {\n    // Tab has become visible again - restart session\n    logger.info(`Tab became visible again for ${source.id}:${paperId}`);\n    startSessionTracking(source.id, paperId);\n  } else if (!isTabVisible && wasVisible) {\n    // Tab has become hidden - end current session\n    logger.info(`Tab hidden for ${source.id}:${paperId}`);\n    \n    // Send end session message\n    chrome.runtime.sendMessage({\n      type: 'endSession',\n      sourceId: source.id,\n      paperId: paperId,\n      reason: 'tab_hidden'\n    });\n    \n    // Stop heartbeat\n    stopHeartbeat();\n  }\n});\n\n// Focus/blur listeners\nwindow.addEventListener('focus', () => {\n  const source = getSourceForUrl(window.location.href);\n  if (!source) return;\n  \n  const paperId = source.extractPaperId(window.location.href);\n  if (!paperId) return;\n  \n  // Tab gained focus - restart session if it wasn't already running\n  if (!heartbeatInterval) {\n    logger.info(`Tab gained focus for ${source.id}:${paperId}`);\n    startSessionTracking(source.id, paperId);\n  }\n});\n\nwindow.addEventListener('blur', () => {\n  const source = getSourceForUrl(window.location.href);\n  if (!source) return;\n  \n  const paperId = source.extractPaperId(window.location.href);\n  if (!paperId) return;\n  \n  // Tab lost focus - end current session\n  logger.info(`Tab lost focus for ${source.id}:${paperId}`);\n  \n  // Send end session message\n  chrome.runtime.sendMessage({\n    type: 'endSession',\n    sourceId: source.id,\n    paperId: paperId,\n    reason: 'tab_blur'\n  });\n  \n  // Stop heartbeat\n  stopHeartbeat();\n});\n\n// Inform background when page is unloaded\nwindow.addEventListener('beforeunload', () => {\n  const url = window.location.href;\n  const source = getSourceForUrl(url);\n  if (!source) return;\n  \n  const paperId = source.extractPaperId(url);\n  if (!paperId) return;\n  \n  // Try to send one last message before page unloads\n  chrome.runtime.sendMessage({\n    type: 'endSession',\n    sourceId: source.id,\n    paperId: paperId,\n    reason: 'page_unload'\n  });\n  \n  stopHeartbeat();\n});\n\n// Message handler for background script\nchrome.runtime.onMessage.addListener((message: any, sender, sendResponse) => {\n  logger.debug('Received message', message);\n\n  if (message.type === 'extractPaperMetadata') {\n    logger.debug('Received request to extract paper metadata manually');\n    \n    // Use processCurrentPage with force=true to enable fallback extraction\n    processCurrentPage(true)\n      .then(metadata => {\n        if (metadata) {\n          sendResponse({ success: true, metadata });\n        } else {\n          sendResponse({ success: false, error: 'Failed to extract metadata' });\n        }\n      })\n      .catch(error => {\n        logger.error('Error extracting metadata', error);\n        sendResponse({ \n          success: false, \n          error: error instanceof Error ? error.message : 'Unknown error' \n        });\n      });\n    return true; // Will respond asynchronously\n  }\n  \n  if (message.type === 'showPopup') {\n    // Remove existing popup\n    if (activePopup) {\n      activePopup.parentElement?.remove();\n      activePopup = null;\n    }\n    \n    // Create popup wrapper\n    const wrapper = document.createElement('div');\n    wrapper.className = 'paper-popup-wrapper';\n    \n    // Position near click or element\n    if (message.position) {\n      wrapper.style.left = `${message.position.x}px`;\n      wrapper.style.top = `${message.position.y}px`;\n    }\n    \n    // Create popup\n    const popup = document.createElement('div');\n    popup.className = 'paper-popup';\n    popup.innerHTML = message.html;\n    \n    // Add to page\n    wrapper.appendChild(popup);\n    document.body.appendChild(wrapper);\n    \n    // Set up event handlers\n    if (message.handlers) {\n      for (const handler of message.handlers) {\n        const elements = popup.querySelectorAll(handler.selector);\n        elements.forEach(element => {\n          element.addEventListener(handler.event, () => {\n            chrome.runtime.sendMessage({\n              type: 'popupAction',\n              action: handler.action,\n              sourceId: message.sourceId,\n              paperId: message.paperId,\n              data: {\n                value: element.tagName === 'TEXTAREA' ? \n                  (element as HTMLTextAreaElement).value : \n                  (element as HTMLElement).getAttribute('data-vote'),\n                checked: element.tagName === 'INPUT' ? \n                  (element as HTMLInputElement).checked : undefined,\n                id: (element as HTMLElement).id\n              }\n            });\n          });\n        });\n      }\n    }\n    \n    // Save reference\n    activePopup = popup;\n    \n    sendResponse({ success: true });\n    return true;\n  }\n  \n  if (message.type === 'processPage') {\n    // Re-process the entire page\n    linkProcessor.processLinks(document);\n    processCurrentPage();\n    sendResponse({ success: true });\n    return true;\n  }\n});\n\n// Initialize\n(async function initialize() {\n  // Inject styles\n  injectStyles();\n  \n  // Initialize sources\n  initializeSources();\n  \n  // Process links\n  linkProcessor.processLinks(document);\n  \n  // Start observing for new links\n  linkProcessor.startObserving(document);\n  \n  // Set initial tab visibility\n  isTabVisible = document.visibilityState === 'visible';\n  \n  // Process current page\n  processCurrentPage();\n  \n  // Tell background script we're ready and what page we're on\n  chrome.runtime.sendMessage(\n    { \n      type: 'contentScriptReady', \n      url: window.location.href \n    },\n    (response) => {\n      if (response?.success) {\n        logger.debug('Background script acknowledged ready status');\n      }\n    }\n  );\n})();\n\n// Set up observer for URL changes (single page apps)\nlet lastUrl = location.href;\nnew MutationObserver(() => {\n  const url = location.href;\n  if (url !== lastUrl) {\n    lastUrl = url;\n    processCurrentPage();\n  }\n}).observe(document, { subtree: true, childList: true });\n"],"names":["Logger","constructor","module","this","debug","message","data","console","undefined","info","warning","warn","error","loguru","getLogger","logger","SOURCE_TYPES","MetadataExtractor","document","url","location","href","getMetaContent","selector","element","querySelector","getAttribute","extract","metadata","title","extractTitle","authors","extractAuthors","description","extractDescription","publishedDate","extractPublishedDate","doi","extractDoi","journalName","extractJournalName","tags","extractTags","citationAuthors","querySelectorAll","forEach","el","content","push","dcCreators","dcCreator","citationAuthor","ogAuthor","length","join","keywords","split","map","tag","trim","isPdf","toLowerCase","endsWith","getSourceType","generatePaperId","generatePaperIdFromUrl","hash","i","charCodeAt","Math","abs","toString","toUpperCase","substring","BaseSourceIntegration","createMetadataExtractor","extractMetadata","paperId","extractor","extracted","sourceType","sourceId","id","abstract","timestamp","Date","toISOString","rating","formatPaperId","parsePaperId","identifier","prefix","startsWith","legacyPrefix","formatObjectId","type","createManualPaperEntry","ArXivMetadataExtractor","authorsElement","authorsText","textContent","replace","super","abstractElement","abstractText","categoriesElement","categoriesText","dateElement","dateText","arxivIntegration","name","urlPatterns","contentScriptMatches","canHandleUrl","some","pattern","test","extractPaperId","match","pageMetadata","fetchFromApi","arxivId","apiUrl","response","fetch","ok","Error","status","text","parsedXml","async","xmlText","xmlDoc","DOMParser","parseFromString","parseError","entry","summary","published","Array","from","categories","Set","primaryCategory","hasAttribute","add","cat","result","published_date","arxiv_tags","parseXMLText","isArray","genericSource","pdfSource","sourceIntegrations","activePopup","heartbeatInterval","isTabVisible","linkProcessor","onLinkFound","patterns","observer","processedLinks","registerPattern","processLinks","link","linkId","getLinkId","has","startObserving","disconnect","MutationObserver","mutations","newLinks","mutation","addedNodes","node","nodeType","Node","ELEMENT_NODE","tagName","observe","body","childList","subtree","path","getElementPath","current","siblings","parentElement","children","index","indexOf","unshift","stopObserving","nextSibling","classList","contains","annotator","createElement","className","dataset","addEventListener","e","preventDefault","stopPropagation","chrome","runtime","sendMessage","position","x","clientX","y","clientY","parentNode","insertBefore","injectAnnotationButton","getSourceForUrl","source","startSessionTracking","stopHeartbeat","success","window","setInterval","now","clearInterval","processCurrentPage","force","target","remove","wasVisible","visibilityState","reason","onMessage","addListener","sender","sendResponse","then","catch","wrapper","style","left","top","popup","innerHTML","html","appendChild","handlers","handler","event","action","value","checked","getElementById","styleSheet","head","injectStyles","initializeSources","lastUrl"],"mappings":"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"}