{"version":3,"file":"content-script.js","sources":["../../utils/logger.ts","../../source-integration/link-processor.ts","../../source-integration/base-source.ts","../../source-integration/arxiv/xml-parser.ts","../../utils/metadata-transformer.ts","../../source-integration/arxiv/index.ts","../../content.ts"],"sourcesContent":["// utils/logger.ts\n// Logging utility wrapping loguru\n\n/**\n * Logger class for consistent logging throughout the extension\n */\nexport class Logger {\n  constructor(private module: string) {}\n  \n  /**\n   * Log debug message\n   */\n  debug(message: string, data?: any): void {\n    console.debug(`[${this.module}] ${message}`, data !== undefined ? data : '');\n  }\n  \n  /**\n   * Log info message\n   */\n  info(message: string, data?: any): void {\n    console.info(`[${this.module}] ${message}`, data !== undefined ? data : '');\n  }\n  \n  /**\n   * Log warning message\n   */\n  warning(message: string, data?: any): void {\n    console.warn(`[${this.module}] ${message}`, data !== undefined ? data : '');\n  }\n  \n  /**\n   * Log error message\n   */\n  error(message: string, data?: any): void {\n    console.error(`[${this.module}] ${message}`, data !== undefined ? data : '');\n  }\n}\n\n/**\n * Loguru mock for browser extension use\n */\nclass LoguruMock {\n  /**\n   * Get logger for a module\n   */\n  getLogger(module: string): Logger {\n    return new Logger(module);\n  }\n}\n\n// Export singleton instance\nexport const loguru = new LoguruMock();\n","// extension/source-integration/link-processor.ts\n// Generic link detection and processing module\n\nimport { loguru } from '../utils/logger';\n\nconst logger = loguru.getLogger('link-processor');\n\ninterface LinkPattern {\n  // Source integration ID\n  sourceId: string;\n  \n  // Regular expression to match URLs\n  pattern: RegExp;\n  \n  // Function to extract paper ID from URL\n  extractPaperId: (url: string) => string | null;\n}\n\nexport class LinkProcessor {\n  private patterns: LinkPattern[] = [];\n  private observer: MutationObserver | null = null;\n  private processedLinks = new Set<string>();\n  private onLinkFound: (sourceId: string, paperId: string, link: HTMLAnchorElement) => void;\n  \n  constructor(onLinkFound: (sourceId: string, paperId: string, link: HTMLAnchorElement) => void) {\n    this.onLinkFound = onLinkFound;\n    logger.debug('Link processor initialized');\n  }\n  \n  /**\n   * Register a new link pattern\n   */\n  registerPattern(pattern: LinkPattern): void {\n    this.patterns.push(pattern);\n    logger.debug(`Registered pattern for ${pattern.sourceId}`);\n  }\n  \n  /**\n   * Process all links in the document\n   */\n  processLinks(document: Document): void {\n    // Process all links in the document\n    const links = document.querySelectorAll<HTMLAnchorElement>('a[href]');\n    \n    links.forEach(link => {\n      // Use a unique identifier for this link\n      const linkId = this.getLinkId(link);\n      \n      // Skip if already processed\n      if (this.processedLinks.has(linkId)) {\n        return;\n      }\n      \n      this.processedLinks.add(linkId);\n      \n      // Check each pattern\n      for (const pattern of this.patterns) {\n        if (pattern.pattern.test(link.href)) {\n          const paperId = pattern.extractPaperId(link.href);\n          \n          if (paperId) {\n            // Call the callback\n            this.onLinkFound(pattern.sourceId, paperId, link);\n            break; // Stop after first match\n          }\n        }\n      }\n    });\n  }\n  \n  /**\n   * Start observing for DOM changes\n   */\n  startObserving(document: Document): void {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n    \n    this.observer = new MutationObserver((mutations) => {\n      let newLinks = false;\n      \n      mutations.forEach(mutation => {\n        mutation.addedNodes.forEach(node => {\n          if (node.nodeType === Node.ELEMENT_NODE) {\n            // If this is an anchor tag, check it\n            if ((node as Element).tagName === 'A') {\n              newLinks = true;\n            }\n            \n            // Check for any anchor tags within this element\n            const links = (node as Element).querySelectorAll('a[href]');\n            if (links.length > 0) {\n              newLinks = true;\n            }\n          }\n        });\n      });\n      \n      if (newLinks) {\n        this.processLinks(document);\n      }\n    });\n    \n    this.observer.observe(document.body, {\n      childList: true,\n      subtree: true\n    });\n    \n    logger.debug('Started observing for DOM changes');\n  }\n  \n  /**\n   * Create a unique ID for a link\n   */\n  private getLinkId(link: HTMLAnchorElement): string {\n    // Use href and position in document to create a unique ID\n    const path = this.getElementPath(link);\n    return `${link.href}|${path}`;\n  }\n  \n  /**\n   * Get element path in DOM for identification\n   */\n  private getElementPath(element: Element): string {\n    const path: string[] = [];\n    let current: Element | null = element;\n    \n    while (current && current !== document.body) {\n      let selector = current.tagName.toLowerCase();\n      \n      if (current.id) {\n        selector += `#${current.id}`;\n      } else {\n        const siblings = Array.from(current.parentElement?.children || []);\n        const index = siblings.indexOf(current) + 1;\n        if (siblings.length > 1) {\n          selector += `:nth-child(${index})`;\n        }\n      }\n      \n      path.unshift(selector);\n      current = current.parentElement;\n    }\n    \n    return path.join(' > ');\n  }\n  \n  /**\n   * Stop observing DOM changes\n   */\n  stopObserving(): void {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n      logger.debug('Stopped observing DOM changes');\n    }\n  }\n}\n","// extension/source-integration/base-source.ts\n// Base abstract class for source integrations with default identifier formatting\n\nimport { SourceIntegration } from './types';\nimport { PaperMetadata } from '../papers/types';\nimport { loguru } from '../utils/logger';\n\nconst logger = loguru.getLogger('base-source');\n\n/**\n * Abstract base class for source integrations\n * Provides default implementations for identifier formatting methods\n */\nexport abstract class BaseSourceIntegration implements SourceIntegration {\n  // Abstract properties to be implemented by derived classes\n  abstract readonly id: string;\n  abstract readonly name: string;\n  abstract readonly urlPatterns: RegExp[];\n  abstract readonly contentScriptMatches: string[];\n\n  // Abstract methods to be implemented by derived classes\n  abstract canHandleUrl(url: string): boolean;\n  abstract extractPaperId(url: string): string | null;\n  abstract extractMetadata(document: Document, paperId: string): Promise<PaperMetadata | null>;\n  \n  /**\n   * Format a paper identifier for this source\n   * Default implementation uses the format: sourceId.paperId\n   * Override this method if a source needs a different format\n   */\n  formatPaperId(paperId: string): string {\n    return `${this.id}.${paperId}`;\n  }\n  \n  /**\n   * Parse a paper identifier specific to this source\n   * Default implementation handles source.paperId format and extracts paperId\n   * Override this method if a source uses a different format\n   */\n  parsePaperId(identifier: string): string | null {\n    const prefix = `${this.id}.`;\n    \n    if (identifier.startsWith(prefix)) {\n      return identifier.substring(prefix.length);\n    }\n    \n    // Try legacy format (sourceId:paperId)\n    const legacyPrefix = `${this.id}:`;\n    if (identifier.startsWith(legacyPrefix)) {\n      logger.debug(`Parsed legacy format identifier: ${identifier}`);\n      return identifier.substring(legacyPrefix.length);\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Format a storage object ID for this source\n   * Default implementation uses the format: type:sourceId.paperId\n   * Override this method if a source needs a different format\n   */\n  formatObjectId(type: string, paperId: string): string {\n    return `${type}:${this.formatPaperId(paperId)}`;\n  }\n}\n","// source-integration/arxiv/xml-parser.ts\n// ArXiv API XML response parser - simplified for use with metadata transformer\n\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('arxiv-xml-parser');\n\nexport interface ArXivParsedData {\n  title: string;\n  summary: string;\n  authors: string[];\n  published_date: string;\n  arxiv_tags: string[];\n  [key: string]: any; // Add index signature to satisfy Json type requirements\n}\n\n/**\n * Parse ArXiv API XML response into a structured object\n */\nexport async function parseXMLText(xmlText: string): Promise<ArXivParsedData | null> {\n  logger.debug('Parsing ArXiv XML response');\n  \n  try {\n    // Parse XML to DOM\n    const parser = new DOMParser();\n    const xmlDoc = parser.parseFromString(xmlText, \"text/xml\");\n    \n    // Check for parse errors\n    const parseError = xmlDoc.querySelector('parsererror');\n    if (parseError) {\n      throw new Error('XML parsing error: ' + parseError.textContent);\n    }\n    \n    // Get entry element\n    const entry = xmlDoc.querySelector('entry');\n    if (!entry) {\n      throw new Error('No entry element found in XML');\n    }\n    \n    // Extract basic fields\n    const title = entry.querySelector('title')?.textContent?.trim() || '';\n    const summary = entry.querySelector('summary')?.textContent?.trim() || '';\n    const published = entry.querySelector('published')?.textContent?.trim() || '';\n    \n    // Extract authors\n    const authors = Array.from(entry.querySelectorAll('author name'))\n      .map(name => name.textContent?.trim() || '');\n    \n    // Extract categories/tags\n    const categories = new Set<string>();\n    \n    // Primary category\n    const primaryCategory = entry.querySelector('arxiv\\\\:primary_category, primary_category');\n    if (primaryCategory && primaryCategory.hasAttribute('term')) {\n      categories.add(primaryCategory.getAttribute('term') || '');\n    }\n    \n    // Other categories\n    const categoryElements = entry.querySelectorAll('category');\n    categoryElements.forEach(cat => {\n      if (cat.hasAttribute('term')) {\n        categories.add(cat.getAttribute('term') || '');\n      }\n    });\n    \n    const result: ArXivParsedData = {\n      title,\n      summary,\n      authors,\n      published_date: published,\n      arxiv_tags: Array.from(categories)\n    };\n    \n    logger.debug('XML parsing completed successfully');\n    return result;\n  } catch (error) {\n    logger.error('Error parsing ArXiv XML', error);\n    return null;\n  }\n}\n","// extension/utils/metadata-transformer.ts\n// Generic metadata transformation utilities\n\nimport { PaperMetadata } from '../papers/types';\nimport { loguru } from './logger';\n\nconst logger = loguru.getLogger('metadata-transformer');\n\n/**\n * Interface for source-specific metadata mapping\n */\nexport interface MetadataMapping {\n  // Maps source-specific fields to standard metadata\n  titleField: string | string[];\n  authorsField: string | string[];\n  abstractField: string | string[];\n  dateField: string | string[];\n  tagsField: string | string[];\n  \n  // Optional custom extraction functions\n  extractAuthors?: (data: any) => string;\n  extractTags?: (data: any) => string[];\n  extractDate?: (data: any) => string;\n}\n\n/**\n * Transform source-specific API response to standard metadata\n */\nexport function transformMetadata(\n  sourceId: string,\n  paperId: string,\n  apiData: any,\n  mapping: MetadataMapping,\n  sourceUrl: string\n): PaperMetadata {\n  // Extract fields using provided mapping\n  const getField = (data: any, fieldPath: string | string[]): any => {\n    if (Array.isArray(fieldPath)) {\n      // Try multiple possible field paths\n      for (const path of fieldPath) {\n        const value = getField(data, path);\n        if (value !== undefined && value !== null && value !== '') {\n          return value;\n        }\n      }\n      return '';\n    }\n    \n    // Handle nested paths like \"document.title\"\n    const parts = fieldPath.split('.');\n    let value = data;\n    \n    for (const part of parts) {\n      if (value === undefined || value === null) return '';\n      value = value[part];\n    }\n    \n    return value !== undefined && value !== null ? value : '';\n  };\n  \n  // Extract title\n  const title = getField(apiData, mapping.titleField);\n  \n  // Extract authors - either use custom function or default extraction\n  const authors = mapping.extractAuthors \n    ? mapping.extractAuthors(apiData)\n    : Array.isArray(getField(apiData, mapping.authorsField))\n      ? getField(apiData, mapping.authorsField).join(', ')\n      : getField(apiData, mapping.authorsField);\n  \n  // Extract abstract\n  const abstract = getField(apiData, mapping.abstractField);\n  \n  // Extract published date\n  const publishedDate = mapping.extractDate\n    ? mapping.extractDate(apiData)\n    : getField(apiData, mapping.dateField);\n  \n  // Extract tags\n  const tags = mapping.extractTags\n    ? mapping.extractTags(apiData)\n    : Array.isArray(getField(apiData, mapping.tagsField))\n      ? getField(apiData, mapping.tagsField)\n      : [];\n  \n  const metadata: PaperMetadata = {\n    sourceId,\n    paperId,\n    url: sourceUrl,\n    title,\n    authors,\n    abstract,\n    timestamp: new Date().toISOString(),\n    rating: 'novote',\n    publishedDate,\n    tags\n  };\n  \n  logger.debug('Transformed metadata', { sourceId, paperId });\n  return metadata;\n}\n","// extension/source-integration/arxiv/index.ts\n// ArXiv integration inheriting from BaseSourceIntegration\n\nimport { BaseSourceIntegration } from '../base-source';\nimport { PaperMetadata } from '../../papers/types';\nimport { parseXMLText } from './xml-parser';\nimport { transformMetadata, MetadataMapping } from '../../utils/metadata-transformer';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('arxiv-integration');\n\nexport class ArXivIntegration extends BaseSourceIntegration {\n  readonly id = 'arxiv';\n  readonly name = 'arXiv.org';\n  \n  // URL patterns for papers\n  readonly urlPatterns = [\n    /arxiv\\.org\\/(abs|pdf|html)\\/([0-9.]+)/,\n    /arxiv\\.org\\/\\w+\\/([0-9.]+)/\n  ];\n  \n  // Content script matches\n  readonly contentScriptMatches = [\n    \"*://*.arxiv.org/*\"\n  ];\n  \n  // Metadata mapping for ArXiv\n  private readonly METADATA_MAPPING: MetadataMapping = {\n    titleField: 'title',\n    authorsField: 'authors',\n    abstractField: 'summary',\n    dateField: 'published_date',\n    tagsField: 'arxiv_tags',\n    \n    // Custom author extraction (since authors is an array)\n    extractAuthors: (data) => {\n      if (Array.isArray(data.authors)) {\n        return data.authors.join(', ');\n      }\n      return data.authors || '';\n    }\n  };\n\n  /**\n   * Check if this integration can handle the given URL\n   */\n  canHandleUrl(url: string): boolean {\n    return this.urlPatterns.some(pattern => pattern.test(url));\n  }\n\n  /**\n   * Extract paper ID from URL\n   */\n  extractPaperId(url: string): string | null {\n    for (const pattern of this.urlPatterns) {\n      const match = url.match(pattern);\n      if (match) {\n        return match[2] || match[1]; // The capture group with the paper ID\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Extract metadata from page or fetch from API\n   */\n  async extractMetadata(document: Document, paperId: string): Promise<PaperMetadata | null> {\n    logger.info(`Extracting metadata for arXiv ID: ${paperId}`);\n    \n    // Try to extract from page first\n    const pageMetadata = this.extractFromPage(document, paperId);\n    if (pageMetadata) {\n      logger.debug('Extracted metadata from page');\n      return pageMetadata;\n    }\n    \n    // If page extraction fails, fetch from API\n    logger.debug('Falling back to API for metadata');\n    return this.fetchFromApi(paperId);\n  }\n  \n  /**\n   * Extract metadata from ArXiv page\n   */\n  private extractFromPage(document: Document, paperId: string): PaperMetadata | null {\n    try {\n      // Extract title\n      const titleElement = document.querySelector('.title');\n      if (!titleElement) return null;\n      \n      const title = titleElement.textContent?.replace('Title:', '').trim() || '';\n      \n      // Extract authors\n      const authorsElement = document.querySelector('.authors');\n      const authors = authorsElement?.textContent?.replace('Authors:', '').trim() || '';\n      \n      // Extract abstract\n      const abstractElement = document.querySelector('.abstract');\n      const abstract = abstractElement?.textContent?.replace('Abstract:', '').trim() || '';\n      \n      // Extract categories\n      const categoriesElement = document.querySelector('.subjects');\n      const categoriesText = categoriesElement?.textContent?.replace('Subjects:', '').trim() || '';\n      const tags = categoriesText.split(';').map(tag => tag.trim());\n      \n      // Extract publication date\n      const dateElement = document.querySelector('.dateline');\n      const publishedDate = dateElement?.textContent?.trim() || '';\n      \n      // Create metadata object\n      return {\n        sourceId: this.id,\n        paperId,\n        url: window.location.href,\n        title,\n        authors,\n        abstract,\n        timestamp: new Date().toISOString(),\n        rating: 'novote',\n        publishedDate,\n        tags\n      };\n    } catch (error) {\n      logger.error('Error extracting from page:', error);\n      return null;\n    }\n  }\n  \n  /**\n   * Fetch metadata from ArXiv API\n   */\n  private async fetchFromApi(arxivId: string): Promise<PaperMetadata | null> {\n    try {\n      const apiUrl = `https://export.arxiv.org/api/query?id_list=${arxivId}`;\n      logger.debug(`API URL: ${apiUrl}`);\n      \n      const response = await fetch(apiUrl);\n      \n      if (!response.ok) {\n        throw new Error(`ArXiv API error: ${response.status}`);\n      }\n      \n      const text = await response.text();\n      const parsedXml = await parseXMLText(text);\n      \n      if (!parsedXml) {\n        logger.error('Failed to parse API response');\n        return null;\n      }\n      \n      // Use the metadata transformer to convert the parsed XML to standard format\n      const paperData = transformMetadata(\n        this.id,\n        arxivId,\n        parsedXml,\n        this.METADATA_MAPPING,\n        `https://arxiv.org/abs/${arxivId}`\n      );\n      \n      logger.debug('Paper metadata processed', paperData);\n      return paperData;\n    } catch (error) {\n      logger.error('Error processing arXiv metadata', error);\n      return null;\n    }\n  }\n}\n\n// Export a singleton instance that can be used by both background and content scripts\nexport const arxivIntegration = new ArXivIntegration();\n","// extension/content.ts\n// Content script with heartbeat session tracking\n\nimport { LinkProcessor } from './source-integration/link-processor';\nimport { SourceIntegration, Message } from './source-integration/types';\nimport { PaperMetadata } from './papers/types';\nimport { loguru } from './utils/logger';\n\n// Import source plugins directly\nimport { arxivIntegration } from './source-integration/arxiv';\n\nconst logger = loguru.getLogger('content-script');\n\nlogger.info('Paper Tracker content script loaded');\n\n// Available source integrations\nconst sourceIntegrations: SourceIntegration[] = [\n  arxivIntegration,\n  // Add more sources as they become available\n];\n\n// Track active popup\nlet activePopup: HTMLElement | null = null;\n\n// Heartbeat interval\nlet heartbeatInterval: number | null = null;\nconst HEARTBEAT_INTERVAL = 5000; // 5 seconds\n\n// Track tab visibility\nlet isTabVisible = true;\n\n// Create link processor\nconst linkProcessor = new LinkProcessor((sourceId, paperId, link) => {\n  // Callback when link is found\n  injectAnnotationButton(link, sourceId, paperId);\n});\n\n// Initialize sources\nfunction initializeSources() {\n  // Register each source with the link processor\n  for (const source of sourceIntegrations) {\n    logger.debug(`Initializing source: ${source.id}`);\n    \n    // Register patterns with link processor\n    source.urlPatterns.forEach(pattern => {\n      linkProcessor.registerPattern({\n        sourceId: source.id,\n        pattern,\n        extractPaperId: (url: string) => source.extractPaperId(url)\n      });\n    });\n  }\n}\n\n// Inject common styles\nfunction injectStyles() {\n  if (document.getElementById('paper-tracker-styles')) {\n    return; // Already injected\n  }\n  \n  const styles = `\n  .paper-annotator {\n    display: inline-block;\n    margin-left: 4px;\n    cursor: pointer;\n    font-size: 0.9em;\n    opacity: 0.7;\n    transition: opacity 0.2s;\n    vertical-align: baseline;\n  }\n\n  .paper-annotator:hover {\n    opacity: 1;\n  }\n\n  .paper-popup-wrapper {\n    position: fixed;\n    z-index: 10000;\n  }\n\n  .paper-popup {\n    position: relative;\n    background: white;\n    border: 1px solid #ddd;\n    border-radius: 6px;\n    padding: 12px;\n    box-shadow: 0 4px 12px rgba(0,0,0,0.15);\n    width: 300px;\n    box-sizing: border-box;\n  }\n\n  .paper-popup-header {\n    font-weight: bold;\n    margin-bottom: 8px;\n    line-height: 1.4;\n    font-size: 1em;\n  }\n\n  .paper-popup-meta {\n    color: #666;\n    font-size: 0.85em;\n    margin-bottom: 12px;\n    line-height: 1.4;\n  }\n\n  .paper-popup-buttons {\n    display: flex;\n    gap: 8px;\n    margin: 8px 0;\n  }\n\n  .paper-popup button {\n    padding: 6px 12px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    background: #f5f5f5;\n    cursor: pointer;\n    transition: all 0.2s ease;\n    font-size: 0.9em;\n  }\n\n  .paper-popup button:hover {\n    background: #e8e8e8;\n    border-color: #ccc;\n  }\n\n  .paper-popup button.active {\n    background: #e0e0e0;\n    border-color: #aaa;\n  }\n\n  .paper-popup textarea {\n    width: calc(100% - 16px);\n    min-height: 80px;\n    margin: 8px 0;\n    padding: 8px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    resize: vertical;\n    font-family: inherit;\n    font-size: 0.9em;\n    line-height: 1.4;\n    box-sizing: border-box;\n  }\n\n  .paper-popup textarea:focus {\n    outline: none;\n    border-color: #aaa;\n  }\n\n  .paper-popup-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n    margin-top: 12px;\n  }\n\n  .paper-popup .save-button {\n    background: #2563eb;\n    color: white;\n    border-color: #2563eb;\n  }\n\n  .paper-popup .save-button:hover {\n    background: #1d4ed8;\n    border-color: #1d4ed8;\n  }\n  `;\n  \n  const styleSheet = document.createElement('style');\n  styleSheet.id = 'paper-tracker-styles';\n  styleSheet.textContent = styles;\n  document.head.appendChild(styleSheet);\n  \n  logger.debug('Injected styles');\n}\n\n// Add annotation button to link\nfunction injectAnnotationButton(link: HTMLAnchorElement, sourceId: string, paperId: string): void {\n  // Skip if already processed\n  if (link.nextSibling && \n      link.nextSibling.nodeType === Node.ELEMENT_NODE &&\n      (link.nextSibling as Element).classList.contains('paper-annotator')) {\n    return;\n  }\n  \n  // Create annotator button\n  const annotator = document.createElement('span');\n  annotator.className = 'paper-annotator';\n  annotator.textContent = '📝';\n  annotator.title = 'Add annotation';\n  \n  // Store data attributes\n  annotator.dataset.sourceId = sourceId;\n  annotator.dataset.paperId = paperId;\n  \n  // Add click handler\n  annotator.addEventListener('click', (e) => {\n    e.preventDefault();\n    e.stopPropagation();\n    \n    // Send message to background script to show popup\n    chrome.runtime.sendMessage({\n      type: 'showAnnotationPopup',\n      sourceId,\n      paperId,\n      position: {\n        x: e.clientX,\n        y: e.clientY\n      }\n    });\n  });\n  \n  // Add to page next to link\n  link.parentNode?.insertBefore(annotator, link.nextSibling);\n}\n\n// Get source that can handle a URL\nfunction getSourceForUrl(url: string): SourceIntegration | null {\n  for (const source of sourceIntegrations) {\n    if (source.canHandleUrl(url)) {\n      return source;\n    }\n  }\n  return null;\n}\n\n// Extract paper ID from URL\nfunction extractPaperId(url: string): { sourceId: string, paperId: string } | null {\n  for (const source of sourceIntegrations) {\n    if (source.canHandleUrl(url)) {\n      const paperId = source.extractPaperId(url);\n      if (paperId) {\n        return { sourceId: source.id, paperId };\n      }\n    }\n  }\n  return null;\n}\n\n// Set up click-outside handler for popups\ndocument.addEventListener('click', (e) => {\n  if (activePopup && \n      !activePopup.contains(e.target as Node) && \n      !(e.target as Element).classList.contains('paper-annotator')) {\n    activePopup.parentElement?.remove();\n    activePopup = null;\n  }\n});\n\n// Start heartbeat for session tracking\nfunction startSessionTracking(sourceId: string, paperId: string) {\n  // Stop any existing heartbeat\n  stopHeartbeat();\n  \n  // Only start tracking if tab is visible\n  if (!isTabVisible) {\n    logger.debug(`Not starting session for ${sourceId}:${paperId} because tab is not visible`);\n    return;\n  }\n  \n  // Tell background script to start a new session\n  chrome.runtime.sendMessage({\n    type: 'startSession',\n    sourceId,\n    paperId\n  }, response => {\n    if (response?.success) {\n      logger.debug(`Started session for ${sourceId}:${paperId}`);\n    } else {\n      logger.error(`Failed to start session for ${sourceId}:${paperId}`, response?.error);\n    }\n  });\n  \n  // Start sending heartbeats\n  heartbeatInterval = window.setInterval(() => {\n    chrome.runtime.sendMessage({\n      type: 'sessionHeartbeat',\n      sourceId,\n      paperId,\n      timestamp: Date.now()\n    });\n  }, HEARTBEAT_INTERVAL);\n  \n  logger.info(`Started heartbeat for ${sourceId}:${paperId}`);\n}\n\n// Stop heartbeat\nfunction stopHeartbeat() {\n  if (heartbeatInterval !== null) {\n    clearInterval(heartbeatInterval);\n    heartbeatInterval = null;\n    logger.debug('Stopped heartbeat');\n  }\n}\n\n// Process current page if it's a paper\nasync function processCurrentPage() {\n  const url = window.location.href;\n  const paperInfo = extractPaperId(url);\n  \n  if (paperInfo) {\n    logger.info(`Detected paper: ${paperInfo.sourceId}:${paperInfo.paperId}`);\n    \n    const { sourceId, paperId } = paperInfo;\n    const source = sourceIntegrations.find(s => s.id === sourceId);\n    \n    if (source) {\n      try {\n        const metadata = await source.extractMetadata(document, paperId);\n        \n        if (metadata) {\n          // Send metadata to background script\n          chrome.runtime.sendMessage({\n            type: 'paperMetadata',\n            metadata\n          });\n          \n          logger.debug(`Sent metadata to background script for ${sourceId}:${paperId}`);\n          \n          // Start session tracking if tab is visible\n          if (isTabVisible) {\n            startSessionTracking(sourceId, paperId);\n          }\n        }\n      } catch (error) {\n        logger.error(`Error extracting metadata for ${sourceId}:${paperId}`, error);\n      }\n    }\n  }\n}\n\n// Visibility change listener\ndocument.addEventListener('visibilitychange', () => {\n  const wasVisible = isTabVisible;\n  isTabVisible = document.visibilityState === 'visible';\n  \n  const paperInfo = extractPaperId(window.location.href);\n  if (!paperInfo) return;\n  \n  if (isTabVisible && !wasVisible) {\n    // Tab has become visible again - restart session\n    logger.info(`Tab became visible again for ${paperInfo.sourceId}:${paperInfo.paperId}`);\n    startSessionTracking(paperInfo.sourceId, paperInfo.paperId);\n  } else if (!isTabVisible && wasVisible) {\n    // Tab has become hidden - end current session\n    logger.info(`Tab hidden for ${paperInfo.sourceId}:${paperInfo.paperId}`);\n    \n    // Send end session message\n    chrome.runtime.sendMessage({\n      type: 'endSession',\n      sourceId: paperInfo.sourceId,\n      paperId: paperInfo.paperId,\n      reason: 'tab_hidden'\n    });\n    \n    // Stop heartbeat\n    stopHeartbeat();\n  }\n});\n\n// Focus/blur listeners\nwindow.addEventListener('focus', () => {\n  const paperInfo = extractPaperId(window.location.href);\n  if (!paperInfo) return;\n  \n  // Tab gained focus - restart session if it wasn't already running\n  if (!heartbeatInterval) {\n    logger.info(`Tab gained focus for ${paperInfo.sourceId}:${paperInfo.paperId}`);\n    startSessionTracking(paperInfo.sourceId, paperInfo.paperId);\n  }\n});\n\nwindow.addEventListener('blur', () => {\n  const paperInfo = extractPaperId(window.location.href);\n  if (!paperInfo) return;\n  \n  // Tab lost focus - end current session\n  logger.info(`Tab lost focus for ${paperInfo.sourceId}:${paperInfo.paperId}`);\n  \n  // Send end session message\n  chrome.runtime.sendMessage({\n    type: 'endSession',\n    sourceId: paperInfo.sourceId,\n    paperId: paperInfo.paperId,\n    reason: 'tab_blur'\n  });\n  \n  // Stop heartbeat\n  stopHeartbeat();\n});\n\n// Inform background when page is unloaded\nwindow.addEventListener('beforeunload', () => {\n  const url = window.location.href;\n  const paperInfo = extractPaperId(url);\n  \n  if (paperInfo) {\n    // Try to send one last message before page unloads\n    chrome.runtime.sendMessage({\n      type: 'endSession',\n      sourceId: paperInfo.sourceId,\n      paperId: paperInfo.paperId,\n      reason: 'page_unload'\n    });\n  }\n  \n  stopHeartbeat();\n});\n\n// Message handler for background script\nchrome.runtime.onMessage.addListener((message: any, sender, sendResponse) => {\n  logger.debug('Received message', message);\n  \n  if (message.type === 'showPopup') {\n    // Remove existing popup\n    if (activePopup) {\n      activePopup.parentElement?.remove();\n      activePopup = null;\n    }\n    \n    // Create popup wrapper\n    const wrapper = document.createElement('div');\n    wrapper.className = 'paper-popup-wrapper';\n    \n    // Position near click or element\n    if (message.position) {\n      wrapper.style.left = `${message.position.x}px`;\n      wrapper.style.top = `${message.position.y}px`;\n    }\n    \n    // Create popup\n    const popup = document.createElement('div');\n    popup.className = 'paper-popup';\n    popup.innerHTML = message.html;\n    \n    // Add to page\n    wrapper.appendChild(popup);\n    document.body.appendChild(wrapper);\n    \n    // Set up event handlers\n    if (message.handlers) {\n      for (const handler of message.handlers) {\n        const elements = popup.querySelectorAll(handler.selector);\n        elements.forEach(element => {\n          element.addEventListener(handler.event, () => {\n            chrome.runtime.sendMessage({\n              type: 'popupAction',\n              action: handler.action,\n              sourceId: message.sourceId,\n              paperId: message.paperId,\n              data: {\n                value: element.tagName === 'TEXTAREA' ? \n                  (element as HTMLTextAreaElement).value : \n                  (element as HTMLElement).getAttribute('data-vote'),\n                checked: element.tagName === 'INPUT' ? \n                  (element as HTMLInputElement).checked : undefined,\n                id: (element as HTMLElement).id\n              }\n            });\n          });\n        });\n      }\n    }\n    \n    // Save reference\n    activePopup = popup;\n    \n    sendResponse({ success: true });\n    return true;\n  }\n  \n  if (message.type === 'processPage') {\n    // Re-process the entire page\n    linkProcessor.processLinks(document);\n    processCurrentPage();\n    sendResponse({ success: true });\n    return true;\n  }\n});\n\n// Initialize\n(async function initialize() {\n  // Inject styles\n  injectStyles();\n  \n  // Initialize sources\n  initializeSources();\n  \n  // Process links\n  linkProcessor.processLinks(document);\n  \n  // Start observing for new links\n  linkProcessor.startObserving(document);\n  \n  // Set initial tab visibility\n  isTabVisible = document.visibilityState === 'visible';\n  \n  // Process current page\n  processCurrentPage();\n  \n  // Tell background script we're ready and what page we're on\n  chrome.runtime.sendMessage(\n    { \n      type: 'contentScriptReady', \n      url: window.location.href \n    },\n    (response) => {\n      if (response?.success) {\n        logger.debug('Background script acknowledged ready status');\n      }\n    }\n  );\n})();\n\n// Set up observer for URL changes (single page apps)\nlet lastUrl = location.href;\nnew MutationObserver(() => {\n  const url = location.href;\n  if (url !== lastUrl) {\n    lastUrl = url;\n    processCurrentPage();\n  }\n}).observe(document, { subtree: true, childList: true });\n"],"names":["Logger","constructor","module","this","debug","message","data","console","undefined","info","warning","warn","error","loguru","getLogger","logger","BaseSourceIntegration","formatPaperId","paperId","id","parsePaperId","identifier","prefix","startsWith","substring","length","legacyPrefix","formatObjectId","type","arxivIntegration","name","urlPatterns","contentScriptMatches","METADATA_MAPPING","titleField","authorsField","abstractField","dateField","tagsField","extractAuthors","Array","isArray","authors","join","canHandleUrl","url","some","pattern","test","extractPaperId","match","extractMetadata","document","pageMetadata","extractFromPage","fetchFromApi","titleElement","querySelector","title","textContent","replace","trim","authorsElement","abstractElement","abstract","categoriesElement","tags","split","map","tag","dateElement","publishedDate","sourceId","window","location","href","timestamp","Date","toISOString","rating","arxivId","apiUrl","response","fetch","ok","Error","status","text","parsedXml","async","xmlText","xmlDoc","DOMParser","parseFromString","parseError","entry","summary","published","from","querySelectorAll","categories","Set","primaryCategory","hasAttribute","add","getAttribute","forEach","cat","result","published_date","arxiv_tags","parseXMLText","paperData","apiData","mapping","sourceUrl","getField","fieldPath","path","value","parts","part","extractDate","extractTags","metadata","transformMetadata","sourceIntegrations","activePopup","heartbeatInterval","isTabVisible","linkProcessor","onLinkFound","patterns","observer","processedLinks","registerPattern","push","processLinks","link","linkId","getLinkId","has","startObserving","disconnect","MutationObserver","mutations","newLinks","mutation","addedNodes","node","nodeType","Node","ELEMENT_NODE","tagName","observe","body","childList","subtree","getElementPath","element","current","selector","toLowerCase","siblings","parentElement","children","index","indexOf","unshift","stopObserving","nextSibling","classList","contains","annotator","createElement","className","dataset","addEventListener","e","preventDefault","stopPropagation","chrome","runtime","sendMessage","position","x","clientX","y","clientY","parentNode","insertBefore","injectAnnotationButton","source","startSessionTracking","stopHeartbeat","success","setInterval","now","clearInterval","processCurrentPage","paperInfo","find","s","target","remove","wasVisible","visibilityState","reason","onMessage","addListener","sender","sendResponse","wrapper","style","left","top","popup","innerHTML","html","appendChild","handlers","handler","event","action","checked","getElementById","styleSheet","head","injectStyles","initializeSources","lastUrl"],"mappings":"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"}