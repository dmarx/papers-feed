---
File: extension/utils/icon-manager.ts
---
// extension/utils/icon-manager.ts
// Icon management utility with inline SVGs and enhanced features

import { loguru } from './logger';

const logger = loguru.getLogger('icon-manager');

export enum IconState {
  DEFAULT = 'default',
  DETECTED = 'detected',
  TRACKED = 'tracked',
}

// Your excellent SVG definitions (keeping them as-is)
// Accessible color schemes for each state
const ICON_COLORS = {
  [IconState.DEFAULT]: {
    background: '#fef2f2',
    paper: '#fecaca',
    bookmark: '#dc2626',
  },
  [IconState.DETECTED]: {
    background: '#eff6ff',
    paper: '#93c5fd', 
    bookmark: '#2563eb',
  },
  [IconState.TRACKED]: {
    background: '#ecfdf5',
    paper: '#86efac',
    bookmark: '#059669',
  },
} as const;

const ICON_CONFIGS: {
  [K in IconState]: { colors: typeof ICON_COLORS[K]; title: string };
} = {
  [IconState.DEFAULT]: {
    colors: ICON_COLORS[IconState.DEFAULT],
    title: 'Academic Paper Tracker',
  },
  [IconState.DETECTED]: {
    colors: ICON_COLORS[IconState.DETECTED],
    title: 'Paper Detected - Academic Paper Tracker',
  },
  [IconState.TRACKED]: {
    colors: ICON_COLORS[IconState.TRACKED],
    title: 'Paper Tracked - Academic Paper Tracker',
  },
};

const ICON_SIZES = [16, 32, 48, 128];

export class IconManager {
  private tabStates: Map<number, IconState> = new Map();
  private pendingUpdates: Map<number, Promise<void>> = new Map(); // NEW: Prevent race conditions
  private iconCache: Map<string, Record<string, ImageData>> = new Map(); // NEW: Cache rasterized icons

  constructor() {
    this.setupTabListeners();
    this.preloadIcons(); // NEW: Pre-rasterize all icons at startup
    logger.debug('Icon manager initialized');
  }

  private setupTabListeners(): void {
    chrome.tabs.onRemoved.addListener((tabId) => {
      this.tabStates.delete(tabId);
      this.pendingUpdates.delete(tabId);
      logger.debug(`Cleaned up icon state for closed tab ${tabId}`);
    });

    chrome.tabs.onUpdated.addListener((tabId, changeInfo) => {
      if (changeInfo.status === 'loading' && changeInfo.url) {
        this.setIconState(tabId, IconState.DEFAULT);
        logger.debug(`Reset icon for tab ${tabId} navigating to ${changeInfo.url}`);
      }
    });
  }

  // NEW: Pre-generate all icons for better performance
  private async preloadIcons(): Promise<void> {
    try {
      for (const state of Object.values(IconState)) {
        const config = ICON_CONFIGS[state];
        const imageDataMap: Record<string, ImageData> = {};
        
        for (const px of ICON_SIZES) {
          const imgData = this.createCanvasIcon(config.colors, px, px);
          imageDataMap[px.toString()] = imgData;
        }
        
        this.iconCache.set(state, imageDataMap);
      }
      logger.debug('Pre-loaded all icon states');
    } catch (error) {
      logger.error('Failed to preload icons:', error);
    }
  }

  async setIconState(tabId: number, state: IconState): Promise<void> {
    // NEW: Check if already in this state (deduplication)
    const currentState = this.tabStates.get(tabId);
    if (currentState === state) {
      logger.debug(`Icon already in ${state} state for tab ${tabId}, skipping`);
      return;
    }

    // NEW: Wait for any pending updates to avoid race conditions
    const pending = this.pendingUpdates.get(tabId);
    if (pending) {
      try {
        await pending;
      } catch (error) {
        logger.warn(`Previous icon update failed for tab ${tabId}:`, error);
      }
    }

    // Create update promise
    const updatePromise = this.performIconUpdate(tabId, state);
    this.pendingUpdates.set(tabId, updatePromise);

    try {
      await updatePromise;
      this.tabStates.set(tabId, state);
      logger.debug(`Set icon state to ${state} for tab ${tabId}`);
    } catch (error) {
      logger.error(`Failed to set icon state for tab ${tabId}:`, error);
      throw error;
    } finally {
      this.pendingUpdates.delete(tabId);
    }
  }

  private async performIconUpdate(tabId: number, state: IconState): Promise<void> {
    const config = ICON_CONFIGS[state];

    // Check if tab still exists
    try {
      await chrome.tabs.get(tabId);
    } catch (error) {
      logger.debug(`Tab ${tabId} no longer exists, skipping icon update`);
      return;
    }

    try {
      // NEW: Use cached icons if available, otherwise generate on demand
      let imageDataMap = this.iconCache.get(state);
      
      if (!imageDataMap) {
        logger.debug(`Cache miss for ${state}, generating on demand`);
        imageDataMap = {};
        for (const px of ICON_SIZES) {
          const imgData = this.createCanvasIcon(config.colors, px, px);
          imageDataMap[px.toString()] = imgData;
        }
        this.iconCache.set(state, imageDataMap);
      }

      await chrome.action.setIcon({
        tabId,
        imageData: imageDataMap,
      });

      await chrome.action.setTitle({
        tabId,
        title: config.title,
      });

    } catch (error) {
      // Handle specific Chrome API errors gracefully
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage.includes('No tab with id') || 
          errorMessage.includes('Cannot access')) {
        logger.debug(`Cannot update icon for tab ${tabId}: ${errorMessage}`);
        return;
      }
      throw error;
    }
  }

  // NEW: Create icon using improved Canvas drawing (no borders, larger bookmark)
  private createCanvasIcon(
    colors: { background: string; paper: string; bookmark: string },
    widthPx: number,
    heightPx: number
  ): ImageData {
    const offscreen = new OffscreenCanvas(widthPx, heightPx);
    const ctx = offscreen.getContext('2d');
    if (!ctx) {
      throw new Error('Failed to get 2D context from OffscreenCanvas');
    }

    // Use full canvas - no padding for maximum space utilization
    const paperWidth = widthPx;
    const paperHeight = heightPx;
    
    // Draw background (full canvas)
    ctx.fillStyle = colors.background;
    ctx.fillRect(0, 0, widthPx, heightPx);
    
    // Draw paper (no rounded corners for cleaner look at small sizes)
    ctx.fillStyle = colors.paper;
    ctx.fillRect(0, 0, paperWidth, paperHeight);
    
    // Draw larger, more prominent bookmark (35% of width)
    const bookmarkWidth = Math.floor(widthPx * 0.35);
    const bookmarkHeight = Math.floor(heightPx * 0.8);
    const bookmarkX = widthPx - bookmarkWidth;
    const bookmarkY = 0;
    
    ctx.fillStyle = colors.bookmark;
    ctx.fillRect(bookmarkX, bookmarkY, bookmarkWidth, bookmarkHeight);
    
    // Draw prominent notch (60% of bookmark width for better visibility)
    const notchSize = Math.floor(bookmarkWidth * 0.6);
    ctx.fillStyle = colors.paper;
    ctx.beginPath();
    ctx.moveTo(bookmarkX, bookmarkY + bookmarkHeight);
    ctx.lineTo(bookmarkX + bookmarkWidth, bookmarkY + bookmarkHeight);
    ctx.lineTo(bookmarkX + bookmarkWidth / 2, bookmarkY + bookmarkHeight - notchSize);
    ctx.closePath();
    ctx.fill();

    return ctx.getImageData(0, 0, widthPx, heightPx);
  }

  getIconState(tabId: number): IconState {
    return this.tabStates.get(tabId) || IconState.DEFAULT;
  }

  async setPaperDetected(tabId: number): Promise<void> {
    await this.setIconState(tabId, IconState.DETECTED);
  }

  async setPaperTracked(tabId: number): Promise<void> {
    await this.setIconState(tabId, IconState.TRACKED);
  }

  async resetIcon(tabId: number): Promise<void> {
    await this.setIconState(tabId, IconState.DEFAULT);
  }

  async setBadgeText(tabId: number, text: string, color?: string): Promise<void> {
    try {
      await chrome.action.setBadgeText({ tabId, text });
      if (color) {
        await chrome.action.setBadgeBackgroundColor({ tabId, color });
      }
      logger.debug(`Set badge text "${text}" for tab ${tabId}`);
    } catch (error) {
      logger.error(`Failed to set badge text for tab ${tabId}:`, error);
    }
  }

  async clearBadge(tabId: number): Promise<void> {
    await this.setBadgeText(tabId, '');
  }

  // NEW: Utility method to add dynamic badges/indicators
  async setPaperCount(tabId: number, count: number): Promise<void> {
    if (count > 0) {
      await this.setBadgeText(tabId, count.toString(), '#FF4444');
    } else {
      await this.clearBadge(tabId);
    }
  }

  // NEW: Reset all tabs to default (useful for extension restart)
  async resetAllIcons(): Promise<void> {
    try {
      const tabs = await chrome.tabs.query({});
      await Promise.allSettled(
        tabs.map(tab => tab.id ? this.resetIcon(tab.id) : Promise.resolve())
      );
      logger.info('Reset all tab icons');
    } catch (error) {
      logger.error('Failed to reset all icons:', error);
    }
  }

  // NEW: Get cache statistics for debugging
  getCacheStats(): { states: number; totalSize: number } {
    let totalSize = 0;
    for (const imageDataMap of this.iconCache.values()) {
      for (const imageData of Object.values(imageDataMap)) {
        totalSize += imageData.data.length;
      }
    }
    return {
      states: this.iconCache.size,
      totalSize
    };
  }
}



---
File: extension/utils/logger.ts
---
// utils/logger.ts
// Logging utility wrapping loguru

/**
 * Logger class for consistent logging throughout the extension
 */
export class Logger {
  constructor(private module: string) {}
  
  /**
   * Log debug message
   */
  debug(message: string, data?: any): void {
    console.debug(`[${this.module}] ${message}`, data !== undefined ? data : '');
  }
  
  /**
   * Log info message
   */
  info(message: string, data?: any): void {
    console.info(`[${this.module}] ${message}`, data !== undefined ? data : '');
  }
  
  /**
   * Log warning message
   */
  warning(message: string, data?: any): void {
    console.warn(`[${this.module}] ${message}`, data !== undefined ? data : '');
  }

  /**
   * Alias for warning method (to match loguru API)
   */
  warn(message: string, data?: any): void {
    this.warning(message, data);
  }
  
  /**
   * Log error message
   */
  error(message: string, data?: any): void {
    console.error(`[${this.module}] ${message}`, data !== undefined ? data : '');
  }
}

/**
 * Loguru mock for browser extension use
 */
class LoguruMock {
  /**
   * Get logger for a module
   */
  getLogger(module: string): Logger {
    return new Logger(module);
  }
}

// Export singleton instance
export const loguru = new LoguruMock();



---
File: extension/utils/popup-manager.ts
---
// extension/utils/popup-manager.ts
// Popup management system integrated with source manager

import { SourceManager } from '../source-integration/types';
import { PaperManager } from '../papers/manager';
import { PaperMetadata } from '../papers/types';
import { loguru } from './logger';

const logger = loguru.getLogger('popup-manager');

/**
 * Popup handler information
 */
interface PopupHandler {
  selector: string;
  event: string;
  action: string;
}

/**
 * Popup message type
 */
interface ShowPopupMessage {
  type: 'showPopup';
  sourceId: string;
  paperId: string;
  html: string;
  handlers: PopupHandler[];
  position?: { x: number, y: number };
}

/**
 * Manages all popup-related functionality
 */
export class PopupManager {
  // Source manager and paper manager
  private sourceManagerProvider: () => SourceManager | null;
  private paperManagerProvider: () => PaperManager | null;
  
  /**
   * Create a new popup manager
   */
  constructor(
    sourceManagerProvider: () => SourceManager | null,
    paperManagerProvider: () => PaperManager | null
  ) {
    this.sourceManagerProvider = sourceManagerProvider;
    this.paperManagerProvider = paperManagerProvider;
    
    this.setupMessageListeners();
    logger.debug('Popup manager initialized');
  }
  
  /**
   * Set up message listeners for popup-related messages
   */
  private setupMessageListeners(): void {
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Handle popup actions (ratings, notes, etc.)
      if (message.type === 'popupAction') {
        this.handlePopupAction(
          message.sourceId,
          message.paperId,
          message.action,
          message.data
        ).then(() => {
          sendResponse({ success: true });
        }).catch(error => {
          logger.error('Error handling popup action', error);
          sendResponse({ 
            success: false, 
            error: error instanceof Error ? error.message : 'Unknown error' 
          });
        });
        
        return true; // Will respond asynchronously
      }
      
      // Handle request to show annotation popup
      if (message.type === 'showAnnotationPopup' && sender.tab?.id) {
        this.handleShowAnnotationPopup(
          sender.tab.id,
          message.sourceId,
          message.paperId,
          message.position
        ).then(() => {
          sendResponse({ success: true });
        }).catch(error => {
          logger.error('Error showing popup', error);
          sendResponse({ 
            success: false, 
            error: error instanceof Error ? error.message : 'Unknown error'
          });
        });
        
        return true; // Will respond asynchronously
      }
      
      return false; // Not handled
    });
  }
  
  /**
   * Handle a request to show an annotation popup
   */
  private async handleShowAnnotationPopup(
    tabId: number,
    sourceId: string,
    paperId: string,
    position: { x: number, y: number }
  ): Promise<void> {
    logger.debug(`Showing annotation popup for ${sourceId}:${paperId}`);
    
    // Check if we have source and paper manager
    const sourceManager = this.sourceManagerProvider();
    const paperManager = this.paperManagerProvider();
    
    if (!sourceManager) {
      throw new Error('Source manager not initialized');
    }
    
    if (!paperManager) {
      throw new Error('Paper manager not initialized');
    }
    
    try {
      // Get paper data
      const paper = await paperManager.getPaper(sourceId, paperId);
      
      // Create popup HTML
      const html = this.createPopupHtml(paper || { 
        sourceId, 
        paperId,
        title: paperId,
        authors: '',
        abstract: '',
        url: '',
        timestamp: new Date().toISOString(),
        publishedDate: '',
        tags: [],
        rating: 'novote'
      });
      
      // Get handlers
      const handlers = this.getStandardPopupHandlers();
      
      // Send message to content script to show popup
      const message: ShowPopupMessage = {
        type: 'showPopup',
        sourceId,
        paperId,
        html,
        handlers,
        position
      };
      
      await chrome.tabs.sendMessage(tabId, message);
      
      logger.debug(`Sent popup to content script for ${sourceId}:${paperId}`);
    } catch (error) {
      logger.error(`Error showing popup for ${sourceId}:${paperId}`, error);
      throw error;
    }
  }
  
  /**
   * Handle popup actions (ratings, notes, etc.)
   */
  private async handlePopupAction(
    sourceId: string,
    paperId: string,
    action: string,
    data: any
  ): Promise<void> {
    const paperManager = this.paperManagerProvider();
    
    if (!paperManager) {
      throw new Error('Paper manager not initialized');
    }
    
    logger.debug(`Handling popup action: ${action}`, { sourceId, paperId });
    
    try {
      if (action === 'rate') {
        await paperManager.updateRating(sourceId, paperId, data.value);
        logger.info(`Updated rating for ${sourceId}:${paperId} to ${data.value}`);
      } 
      else if (action === 'saveNotes') {
        if (data.value) {
          await paperManager.logAnnotation(sourceId, paperId, 'notes', data.value);
          logger.info(`Saved notes for ${sourceId}:${paperId}`);
        }
      }
    } catch (error) {
      logger.error(`Error handling action ${action} for ${sourceId}:${paperId}`, error);
      throw error;
    }
  }
  
  /**
   * Create HTML for paper popup
   */
  private createPopupHtml(paper: PaperMetadata): string {
    return `
      <div class="paper-popup-header">${paper.title || paper.paperId}</div>
      <div class="paper-popup-meta">${paper.authors || ''}</div>
      
      <div class="paper-popup-buttons">
        <button class="vote-button" data-vote="thumbsup" id="btn-thumbsup" ${paper.rating === 'thumbsup' ? 'class="active"' : ''}>👍 Interesting</button>
        <button class="vote-button" data-vote="thumbsdown" id="btn-thumbsdown" ${paper.rating === 'thumbsdown' ? 'class="active"' : ''}>👎 Not Relevant</button>
      </div>
      
      <textarea placeholder="Add notes about this paper..." id="paper-notes"></textarea>
      
      <div class="paper-popup-actions">
        <button class="save-button" id="btn-save">Save</button>
      </div>
    `;
  }
  
  /**
   * Get standard popup event handlers
   */
  private getStandardPopupHandlers(): PopupHandler[] {
    return [
      { selector: '#btn-thumbsup', event: 'click', action: 'rate' },
      { selector: '#btn-thumbsdown', event: 'click', action: 'rate' },
      { selector: '#btn-save', event: 'click', action: 'saveNotes' }
    ];
  }
}



---
File: extension/utils/session-service.ts
---
// session-service.ts
// Simplified session tracking service for background script

import { loguru } from './logger';
import { PaperManager } from '../papers/manager';
import { ReadingSessionData, PaperMetadata } from '../papers/types';

const logger = loguru.getLogger('session-service');

/**
 * Session tracking service for paper reading sessions
 * 
 * Manages session state, heartbeats, and persistence
 * Designed for use in the background script (Service Worker)
 */
export class SessionService {
  private activeSession: {
    sourceId: string;
    paperId: string;
    startTime: Date;
    heartbeatCount: number;
    lastHeartbeatTime: Date;
  } | null = null;
  
  private timeoutId: number | null = null;
  private paperMetadata: Map<string, PaperMetadata> = new Map();
  
  // Configuration
  private readonly HEARTBEAT_TIMEOUT = 15000; // 15 seconds
  
  /**
   * Create a new session service
   */
  constructor(private paperManager: PaperManager | null) {
    logger.debug('Session service initialized');
  }
  
  /**
   * Start a new session for a paper
   */
  startSession(sourceId: string, paperId: string, metadata?: PaperMetadata): void {
    // End any existing session
    this.endSession();
    
    // Create new session
    this.activeSession = {
      sourceId,
      paperId,
      startTime: new Date(),
      heartbeatCount: 0,
      lastHeartbeatTime: new Date()
    };
    
    // Store metadata if provided
    if (metadata) {
      const key = `${sourceId}:${paperId}`;
      this.paperMetadata.set(key, metadata);
      logger.debug(`Stored metadata for ${key}`);
    }
    
    // Start timeout check
    this.scheduleTimeoutCheck();
    
    logger.info(`Started session for ${sourceId}:${paperId}`);
  }
  
  /**
   * Record a heartbeat for the current session
   */
  recordHeartbeat(): boolean {
    if (!this.activeSession) {
      return false;
    }
    
    this.activeSession.heartbeatCount++;
    this.activeSession.lastHeartbeatTime = new Date();
    
    // Reschedule timeout
    this.scheduleTimeoutCheck();
    
    if (this.activeSession.heartbeatCount % 12 === 0) { // Log every minute (12 x 5sec heartbeats)
      logger.debug(`Session received ${this.activeSession.heartbeatCount} heartbeats`);
    }
    
    return true;
  }
  
  /**
   * Schedule a check for heartbeat timeout
   */
  private scheduleTimeoutCheck(): void {
    // Clear existing timeout
    if (this.timeoutId !== null) {
      clearTimeout(this.timeoutId);
    }
    
    // Set new timeout
    this.timeoutId = self.setTimeout(() => {
      this.checkTimeout();
    }, this.HEARTBEAT_TIMEOUT);
  }
  
  /**
   * Check if the session has timed out due to missing heartbeats
   */
  private checkTimeout(): void {
    if (!this.activeSession) return;
    
    const now = Date.now();
    const lastTime = this.activeSession.lastHeartbeatTime.getTime();
    
    if ((now - lastTime) > this.HEARTBEAT_TIMEOUT) {
      logger.info('Session timeout detected');
      this.endSession();
    } else {
      this.scheduleTimeoutCheck();
    }
  }
  
  /**
   * End the current session and get the data
   */
  endSession(): ReadingSessionData | null {
    if (!this.activeSession) return null;
    
    // Clear timeout
    if (this.timeoutId !== null) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    
    const { sourceId, paperId, startTime, heartbeatCount } = this.activeSession;
    const endTime = new Date();
    
    // Calculate duration (5 seconds per heartbeat)
    const duration = heartbeatCount * 5;
    
    // Calculate total elapsed time
    const totalElapsed = endTime.getTime() - startTime.getTime();
    const totalElapsedSeconds = Math.round(totalElapsed / 1000);
    
    // Set idle seconds to the difference (for backward compatibility)
    const idleSeconds = Math.max(0, totalElapsedSeconds - duration);
    
    // Create session data
    const sessionData: ReadingSessionData = {
      session_id: `session_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
      source_id: sourceId,
      paper_id: paperId,
      start_time: startTime.toISOString(),
      end_time: endTime.toISOString(),
      heartbeat_count: heartbeatCount,
      duration_seconds: duration,
      // Legacy fields
      idle_seconds: idleSeconds,
      total_elapsed_seconds: totalElapsedSeconds
    };
    
    // Store session if it was meaningful and we have a paper manager
    if (this.paperManager && heartbeatCount > 0) {
      const metadata = this.getPaperMetadata(sourceId, paperId);
      
      this.paperManager.logReadingSession(sourceId, paperId, sessionData, metadata)
        .catch(err => logger.error('Failed to store session', err));
    }
    
    logger.info(`Ended session for ${sourceId}:${paperId}`, {
      duration,
      heartbeats: heartbeatCount
    });
    
    // Clear active session
    this.activeSession = null;
    
    return sessionData;
  }
  
  /**
   * Check if a session is currently active
   */
  hasActiveSession(): boolean {
    return this.activeSession !== null;
  }
  
  /**
   * Get information about the current session
   */
  getCurrentSession(): { sourceId: string, paperId: string } | null {
    if (!this.activeSession) return null;
    
    return {
      sourceId: this.activeSession.sourceId,
      paperId: this.activeSession.paperId
    };
  }
  
  /**
   * Get paper metadata for the current or specified session
   */
  getPaperMetadata(sourceId?: string, paperId?: string): PaperMetadata | undefined {
    if (!sourceId || !paperId) {
      if (!this.activeSession) return undefined;
      sourceId = this.activeSession.sourceId;
      paperId = this.activeSession.paperId;
    }
    
    return this.paperMetadata.get(`${sourceId}:${paperId}`);
  }
  
  /**
   * Store paper metadata
   */
  storePaperMetadata(metadata: PaperMetadata): void {
    const key = `${metadata.sourceId}:${metadata.paperId}`;
    this.paperMetadata.set(key, metadata);
  }
  
  /**
   * Get time since last heartbeat in milliseconds
   */
  getTimeSinceLastHeartbeat(): number | null {
    if (!this.activeSession) {
      return null;
    }
    
    return Date.now() - this.activeSession.lastHeartbeatTime.getTime();
  }
  
  /**
   * Get session statistics for debugging
   */
  getSessionStats(): any {
    if (!this.activeSession) {
      return { active: false };
    }
    
    return {
      active: true,
      sourceId: this.activeSession.sourceId,
      paperId: this.activeSession.paperId,
      startTime: this.activeSession.startTime.toISOString(),
      heartbeatCount: this.activeSession.heartbeatCount,
      lastHeartbeatTime: this.activeSession.lastHeartbeatTime.toISOString(),
      elapsedTime: Math.round((Date.now() - this.activeSession.startTime.getTime()) / 1000)
    };
  }
}


